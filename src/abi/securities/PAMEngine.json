{
  "address": "0xd295724BE00296e9c6Cce7d786fa48b4FBB57894",
  "abi": [
    {
      "inputs": [],
      "name": "MAX_CYCLE_SIZE",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MAX_EVENT_SCHEDULE_SIZE",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ONE_POINT_ZERO",
      "outputs": [
        {
          "internalType": "int256",
          "name": "",
          "type": "int256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "PRECISION",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum EndOfMonthConvention",
          "name": "eomc",
          "type": "uint8"
        },
        {
          "internalType": "uint256",
          "name": "startTime",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "i",
              "type": "uint256"
            },
            {
              "internalType": "enum P",
              "name": "p",
              "type": "uint8"
            },
            {
              "internalType": "enum S",
              "name": "s",
              "type": "uint8"
            },
            {
              "internalType": "bool",
              "name": "isSet",
              "type": "bool"
            }
          ],
          "internalType": "struct IPS",
          "name": "cycle",
          "type": "tuple"
        }
      ],
      "name": "adjustEndOfMonthConvention",
      "outputs": [
        {
          "internalType": "enum EndOfMonthConvention",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "enum ContractType",
              "name": "contractType",
              "type": "uint8"
            },
            {
              "internalType": "enum Calendar",
              "name": "calendar",
              "type": "uint8"
            },
            {
              "internalType": "enum ContractRole",
              "name": "contractRole",
              "type": "uint8"
            },
            {
              "internalType": "enum DayCountConvention",
              "name": "dayCountConvention",
              "type": "uint8"
            },
            {
              "internalType": "enum BusinessDayConvention",
              "name": "businessDayConvention",
              "type": "uint8"
            },
            {
              "internalType": "enum EndOfMonthConvention",
              "name": "endOfMonthConvention",
              "type": "uint8"
            },
            {
              "internalType": "enum ScalingEffect",
              "name": "scalingEffect",
              "type": "uint8"
            },
            {
              "internalType": "enum FeeBasis",
              "name": "feeBasis",
              "type": "uint8"
            },
            {
              "internalType": "address",
              "name": "currency",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "settlementCurrency",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "marketObjectCodeRateReset",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "statusDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "initialExchangeDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maturityDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "issueDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "purchaseDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "capitalizationEndDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cycleAnchorDateOfInterestPayment",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cycleAnchorDateOfRateReset",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cycleAnchorDateOfScalingIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cycleAnchorDateOfFee",
              "type": "uint256"
            },
            {
              "internalType": "int256",
              "name": "notionalPrincipal",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "nominalInterestRate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "accruedInterest",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "rateMultiplier",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "rateSpread",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "nextResetRate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "feeRate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "feeAccrued",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "premiumDiscountAtIED",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "priceAtPurchaseDate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "priceAtTerminationDate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "lifeCap",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "lifeFloor",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "periodCap",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "periodFloor",
              "type": "int256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IP",
              "name": "gracePeriod",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IP",
              "name": "delinquencyPeriod",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "enum S",
                  "name": "s",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IPS",
              "name": "cycleOfInterestPayment",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "enum S",
                  "name": "s",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IPS",
              "name": "cycleOfRateReset",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "enum S",
                  "name": "s",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IPS",
              "name": "cycleOfScalingIndex",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "enum S",
                  "name": "s",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IPS",
              "name": "cycleOfFee",
              "type": "tuple"
            }
          ],
          "internalType": "struct PAMTerms",
          "name": "terms",
          "type": "tuple"
        },
        {
          "internalType": "uint256",
          "name": "segmentStart",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "segmentEnd",
          "type": "uint256"
        },
        {
          "internalType": "enum EventType",
          "name": "eventType",
          "type": "uint8"
        }
      ],
      "name": "computeCyclicScheduleSegment",
      "outputs": [
        {
          "internalType": "bytes32[]",
          "name": "",
          "type": "bytes32[]"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_event",
          "type": "bytes32"
        },
        {
          "internalType": "enum BusinessDayConvention",
          "name": "bdc",
          "type": "uint8"
        },
        {
          "internalType": "enum Calendar",
          "name": "calendar",
          "type": "uint8"
        },
        {
          "internalType": "uint256",
          "name": "maturityDate",
          "type": "uint256"
        }
      ],
      "name": "computeEventTimeForEvent",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "enum ContractType",
              "name": "contractType",
              "type": "uint8"
            },
            {
              "internalType": "enum Calendar",
              "name": "calendar",
              "type": "uint8"
            },
            {
              "internalType": "enum ContractRole",
              "name": "contractRole",
              "type": "uint8"
            },
            {
              "internalType": "enum DayCountConvention",
              "name": "dayCountConvention",
              "type": "uint8"
            },
            {
              "internalType": "enum BusinessDayConvention",
              "name": "businessDayConvention",
              "type": "uint8"
            },
            {
              "internalType": "enum EndOfMonthConvention",
              "name": "endOfMonthConvention",
              "type": "uint8"
            },
            {
              "internalType": "enum ScalingEffect",
              "name": "scalingEffect",
              "type": "uint8"
            },
            {
              "internalType": "enum FeeBasis",
              "name": "feeBasis",
              "type": "uint8"
            },
            {
              "internalType": "address",
              "name": "currency",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "settlementCurrency",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "marketObjectCodeRateReset",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "statusDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "initialExchangeDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maturityDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "issueDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "purchaseDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "capitalizationEndDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cycleAnchorDateOfInterestPayment",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cycleAnchorDateOfRateReset",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cycleAnchorDateOfScalingIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cycleAnchorDateOfFee",
              "type": "uint256"
            },
            {
              "internalType": "int256",
              "name": "notionalPrincipal",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "nominalInterestRate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "accruedInterest",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "rateMultiplier",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "rateSpread",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "nextResetRate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "feeRate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "feeAccrued",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "premiumDiscountAtIED",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "priceAtPurchaseDate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "priceAtTerminationDate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "lifeCap",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "lifeFloor",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "periodCap",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "periodFloor",
              "type": "int256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IP",
              "name": "gracePeriod",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IP",
              "name": "delinquencyPeriod",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "enum S",
                  "name": "s",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IPS",
              "name": "cycleOfInterestPayment",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "enum S",
                  "name": "s",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IPS",
              "name": "cycleOfRateReset",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "enum S",
                  "name": "s",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IPS",
              "name": "cycleOfScalingIndex",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "enum S",
                  "name": "s",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IPS",
              "name": "cycleOfFee",
              "type": "tuple"
            }
          ],
          "internalType": "struct PAMTerms",
          "name": "terms",
          "type": "tuple"
        }
      ],
      "name": "computeInitialState",
      "outputs": [
        {
          "components": [
            {
              "internalType": "enum ContractPerformance",
              "name": "contractPerformance",
              "type": "uint8"
            },
            {
              "internalType": "uint256",
              "name": "statusDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "nonPerformingDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maturityDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "terminationDate",
              "type": "uint256"
            },
            {
              "internalType": "int256",
              "name": "notionalPrincipal",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "accruedInterest",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "feeAccrued",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "nominalInterestRate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "interestScalingMultiplier",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "notionalScalingMultiplier",
              "type": "int256"
            }
          ],
          "internalType": "struct PAMState",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "enum ContractType",
              "name": "contractType",
              "type": "uint8"
            },
            {
              "internalType": "enum Calendar",
              "name": "calendar",
              "type": "uint8"
            },
            {
              "internalType": "enum ContractRole",
              "name": "contractRole",
              "type": "uint8"
            },
            {
              "internalType": "enum DayCountConvention",
              "name": "dayCountConvention",
              "type": "uint8"
            },
            {
              "internalType": "enum BusinessDayConvention",
              "name": "businessDayConvention",
              "type": "uint8"
            },
            {
              "internalType": "enum EndOfMonthConvention",
              "name": "endOfMonthConvention",
              "type": "uint8"
            },
            {
              "internalType": "enum ScalingEffect",
              "name": "scalingEffect",
              "type": "uint8"
            },
            {
              "internalType": "enum FeeBasis",
              "name": "feeBasis",
              "type": "uint8"
            },
            {
              "internalType": "address",
              "name": "currency",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "settlementCurrency",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "marketObjectCodeRateReset",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "statusDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "initialExchangeDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maturityDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "issueDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "purchaseDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "capitalizationEndDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cycleAnchorDateOfInterestPayment",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cycleAnchorDateOfRateReset",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cycleAnchorDateOfScalingIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cycleAnchorDateOfFee",
              "type": "uint256"
            },
            {
              "internalType": "int256",
              "name": "notionalPrincipal",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "nominalInterestRate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "accruedInterest",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "rateMultiplier",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "rateSpread",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "nextResetRate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "feeRate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "feeAccrued",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "premiumDiscountAtIED",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "priceAtPurchaseDate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "priceAtTerminationDate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "lifeCap",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "lifeFloor",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "periodCap",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "periodFloor",
              "type": "int256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IP",
              "name": "gracePeriod",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IP",
              "name": "delinquencyPeriod",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "enum S",
                  "name": "s",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IPS",
              "name": "cycleOfInterestPayment",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "enum S",
                  "name": "s",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IPS",
              "name": "cycleOfRateReset",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "enum S",
                  "name": "s",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IPS",
              "name": "cycleOfScalingIndex",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "enum S",
                  "name": "s",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IPS",
              "name": "cycleOfFee",
              "type": "tuple"
            }
          ],
          "internalType": "struct PAMTerms",
          "name": "terms",
          "type": "tuple"
        },
        {
          "internalType": "uint256",
          "name": "lastScheduleTime",
          "type": "uint256"
        },
        {
          "internalType": "enum EventType",
          "name": "eventType",
          "type": "uint8"
        }
      ],
      "name": "computeNextCyclicEvent",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "enum ContractType",
              "name": "contractType",
              "type": "uint8"
            },
            {
              "internalType": "enum Calendar",
              "name": "calendar",
              "type": "uint8"
            },
            {
              "internalType": "enum ContractRole",
              "name": "contractRole",
              "type": "uint8"
            },
            {
              "internalType": "enum DayCountConvention",
              "name": "dayCountConvention",
              "type": "uint8"
            },
            {
              "internalType": "enum BusinessDayConvention",
              "name": "businessDayConvention",
              "type": "uint8"
            },
            {
              "internalType": "enum EndOfMonthConvention",
              "name": "endOfMonthConvention",
              "type": "uint8"
            },
            {
              "internalType": "enum ScalingEffect",
              "name": "scalingEffect",
              "type": "uint8"
            },
            {
              "internalType": "enum FeeBasis",
              "name": "feeBasis",
              "type": "uint8"
            },
            {
              "internalType": "address",
              "name": "currency",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "settlementCurrency",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "marketObjectCodeRateReset",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "statusDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "initialExchangeDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maturityDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "issueDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "purchaseDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "capitalizationEndDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cycleAnchorDateOfInterestPayment",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cycleAnchorDateOfRateReset",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cycleAnchorDateOfScalingIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cycleAnchorDateOfFee",
              "type": "uint256"
            },
            {
              "internalType": "int256",
              "name": "notionalPrincipal",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "nominalInterestRate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "accruedInterest",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "rateMultiplier",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "rateSpread",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "nextResetRate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "feeRate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "feeAccrued",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "premiumDiscountAtIED",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "priceAtPurchaseDate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "priceAtTerminationDate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "lifeCap",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "lifeFloor",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "periodCap",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "periodFloor",
              "type": "int256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IP",
              "name": "gracePeriod",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IP",
              "name": "delinquencyPeriod",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "enum S",
                  "name": "s",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IPS",
              "name": "cycleOfInterestPayment",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "enum S",
                  "name": "s",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IPS",
              "name": "cycleOfRateReset",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "enum S",
                  "name": "s",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IPS",
              "name": "cycleOfScalingIndex",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "enum S",
                  "name": "s",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IPS",
              "name": "cycleOfFee",
              "type": "tuple"
            }
          ],
          "internalType": "struct PAMTerms",
          "name": "terms",
          "type": "tuple"
        },
        {
          "internalType": "bytes32",
          "name": "lastNonCyclicEvent",
          "type": "bytes32"
        }
      ],
      "name": "computeNextNonCyclicEvent",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "enum ContractType",
              "name": "contractType",
              "type": "uint8"
            },
            {
              "internalType": "enum Calendar",
              "name": "calendar",
              "type": "uint8"
            },
            {
              "internalType": "enum ContractRole",
              "name": "contractRole",
              "type": "uint8"
            },
            {
              "internalType": "enum DayCountConvention",
              "name": "dayCountConvention",
              "type": "uint8"
            },
            {
              "internalType": "enum BusinessDayConvention",
              "name": "businessDayConvention",
              "type": "uint8"
            },
            {
              "internalType": "enum EndOfMonthConvention",
              "name": "endOfMonthConvention",
              "type": "uint8"
            },
            {
              "internalType": "enum ScalingEffect",
              "name": "scalingEffect",
              "type": "uint8"
            },
            {
              "internalType": "enum FeeBasis",
              "name": "feeBasis",
              "type": "uint8"
            },
            {
              "internalType": "address",
              "name": "currency",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "settlementCurrency",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "marketObjectCodeRateReset",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "statusDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "initialExchangeDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maturityDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "issueDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "purchaseDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "capitalizationEndDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cycleAnchorDateOfInterestPayment",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cycleAnchorDateOfRateReset",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cycleAnchorDateOfScalingIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cycleAnchorDateOfFee",
              "type": "uint256"
            },
            {
              "internalType": "int256",
              "name": "notionalPrincipal",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "nominalInterestRate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "accruedInterest",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "rateMultiplier",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "rateSpread",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "nextResetRate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "feeRate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "feeAccrued",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "premiumDiscountAtIED",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "priceAtPurchaseDate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "priceAtTerminationDate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "lifeCap",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "lifeFloor",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "periodCap",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "periodFloor",
              "type": "int256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IP",
              "name": "gracePeriod",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IP",
              "name": "delinquencyPeriod",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "enum S",
                  "name": "s",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IPS",
              "name": "cycleOfInterestPayment",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "enum S",
                  "name": "s",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IPS",
              "name": "cycleOfRateReset",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "enum S",
                  "name": "s",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IPS",
              "name": "cycleOfScalingIndex",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "enum S",
                  "name": "s",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IPS",
              "name": "cycleOfFee",
              "type": "tuple"
            }
          ],
          "internalType": "struct PAMTerms",
          "name": "terms",
          "type": "tuple"
        },
        {
          "internalType": "uint256",
          "name": "segmentStart",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "segmentEnd",
          "type": "uint256"
        }
      ],
      "name": "computeNonCyclicScheduleSegment",
      "outputs": [
        {
          "internalType": "bytes32[]",
          "name": "",
          "type": "bytes32[]"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "enum ContractType",
              "name": "contractType",
              "type": "uint8"
            },
            {
              "internalType": "enum Calendar",
              "name": "calendar",
              "type": "uint8"
            },
            {
              "internalType": "enum ContractRole",
              "name": "contractRole",
              "type": "uint8"
            },
            {
              "internalType": "enum DayCountConvention",
              "name": "dayCountConvention",
              "type": "uint8"
            },
            {
              "internalType": "enum BusinessDayConvention",
              "name": "businessDayConvention",
              "type": "uint8"
            },
            {
              "internalType": "enum EndOfMonthConvention",
              "name": "endOfMonthConvention",
              "type": "uint8"
            },
            {
              "internalType": "enum ScalingEffect",
              "name": "scalingEffect",
              "type": "uint8"
            },
            {
              "internalType": "enum FeeBasis",
              "name": "feeBasis",
              "type": "uint8"
            },
            {
              "internalType": "address",
              "name": "currency",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "settlementCurrency",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "marketObjectCodeRateReset",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "statusDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "initialExchangeDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maturityDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "issueDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "purchaseDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "capitalizationEndDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cycleAnchorDateOfInterestPayment",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cycleAnchorDateOfRateReset",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cycleAnchorDateOfScalingIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cycleAnchorDateOfFee",
              "type": "uint256"
            },
            {
              "internalType": "int256",
              "name": "notionalPrincipal",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "nominalInterestRate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "accruedInterest",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "rateMultiplier",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "rateSpread",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "nextResetRate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "feeRate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "feeAccrued",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "premiumDiscountAtIED",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "priceAtPurchaseDate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "priceAtTerminationDate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "lifeCap",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "lifeFloor",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "periodCap",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "periodFloor",
              "type": "int256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IP",
              "name": "gracePeriod",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IP",
              "name": "delinquencyPeriod",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "enum S",
                  "name": "s",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IPS",
              "name": "cycleOfInterestPayment",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "enum S",
                  "name": "s",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IPS",
              "name": "cycleOfRateReset",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "enum S",
                  "name": "s",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IPS",
              "name": "cycleOfScalingIndex",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "enum S",
                  "name": "s",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IPS",
              "name": "cycleOfFee",
              "type": "tuple"
            }
          ],
          "internalType": "struct PAMTerms",
          "name": "terms",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "enum ContractPerformance",
              "name": "contractPerformance",
              "type": "uint8"
            },
            {
              "internalType": "uint256",
              "name": "statusDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "nonPerformingDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maturityDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "terminationDate",
              "type": "uint256"
            },
            {
              "internalType": "int256",
              "name": "notionalPrincipal",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "accruedInterest",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "feeAccrued",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "nominalInterestRate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "interestScalingMultiplier",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "notionalScalingMultiplier",
              "type": "int256"
            }
          ],
          "internalType": "struct PAMState",
          "name": "state",
          "type": "tuple"
        },
        {
          "internalType": "bytes32",
          "name": "_event",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "externalData",
          "type": "bytes"
        }
      ],
      "name": "computePayoffForEvent",
      "outputs": [
        {
          "internalType": "int256",
          "name": "",
          "type": "int256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "enum ContractType",
              "name": "contractType",
              "type": "uint8"
            },
            {
              "internalType": "enum Calendar",
              "name": "calendar",
              "type": "uint8"
            },
            {
              "internalType": "enum ContractRole",
              "name": "contractRole",
              "type": "uint8"
            },
            {
              "internalType": "enum DayCountConvention",
              "name": "dayCountConvention",
              "type": "uint8"
            },
            {
              "internalType": "enum BusinessDayConvention",
              "name": "businessDayConvention",
              "type": "uint8"
            },
            {
              "internalType": "enum EndOfMonthConvention",
              "name": "endOfMonthConvention",
              "type": "uint8"
            },
            {
              "internalType": "enum ScalingEffect",
              "name": "scalingEffect",
              "type": "uint8"
            },
            {
              "internalType": "enum FeeBasis",
              "name": "feeBasis",
              "type": "uint8"
            },
            {
              "internalType": "address",
              "name": "currency",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "settlementCurrency",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "marketObjectCodeRateReset",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "statusDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "initialExchangeDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maturityDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "issueDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "purchaseDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "capitalizationEndDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cycleAnchorDateOfInterestPayment",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cycleAnchorDateOfRateReset",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cycleAnchorDateOfScalingIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cycleAnchorDateOfFee",
              "type": "uint256"
            },
            {
              "internalType": "int256",
              "name": "notionalPrincipal",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "nominalInterestRate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "accruedInterest",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "rateMultiplier",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "rateSpread",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "nextResetRate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "feeRate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "feeAccrued",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "premiumDiscountAtIED",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "priceAtPurchaseDate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "priceAtTerminationDate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "lifeCap",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "lifeFloor",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "periodCap",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "periodFloor",
              "type": "int256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IP",
              "name": "gracePeriod",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IP",
              "name": "delinquencyPeriod",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "enum S",
                  "name": "s",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IPS",
              "name": "cycleOfInterestPayment",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "enum S",
                  "name": "s",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IPS",
              "name": "cycleOfRateReset",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "enum S",
                  "name": "s",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IPS",
              "name": "cycleOfScalingIndex",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "enum S",
                  "name": "s",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IPS",
              "name": "cycleOfFee",
              "type": "tuple"
            }
          ],
          "internalType": "struct PAMTerms",
          "name": "terms",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "enum ContractPerformance",
              "name": "contractPerformance",
              "type": "uint8"
            },
            {
              "internalType": "uint256",
              "name": "statusDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "nonPerformingDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maturityDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "terminationDate",
              "type": "uint256"
            },
            {
              "internalType": "int256",
              "name": "notionalPrincipal",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "accruedInterest",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "feeAccrued",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "nominalInterestRate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "interestScalingMultiplier",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "notionalScalingMultiplier",
              "type": "int256"
            }
          ],
          "internalType": "struct PAMState",
          "name": "state",
          "type": "tuple"
        },
        {
          "internalType": "bytes32",
          "name": "_event",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "externalData",
          "type": "bytes"
        }
      ],
      "name": "computeStateForEvent",
      "outputs": [
        {
          "components": [
            {
              "internalType": "enum ContractPerformance",
              "name": "contractPerformance",
              "type": "uint8"
            },
            {
              "internalType": "uint256",
              "name": "statusDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "nonPerformingDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maturityDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "terminationDate",
              "type": "uint256"
            },
            {
              "internalType": "int256",
              "name": "notionalPrincipal",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "accruedInterest",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "feeAccrued",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "nominalInterestRate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "interestScalingMultiplier",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "notionalScalingMultiplier",
              "type": "int256"
            }
          ],
          "internalType": "struct PAMState",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "contractType",
      "outputs": [
        {
          "internalType": "enum ContractType",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_event",
          "type": "bytes32"
        }
      ],
      "name": "decodeEvent",
      "outputs": [
        {
          "internalType": "enum EventType",
          "name": "",
          "type": "uint8"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum EventType",
          "name": "eventType",
          "type": "uint8"
        },
        {
          "internalType": "uint256",
          "name": "scheduleTime",
          "type": "uint256"
        }
      ],
      "name": "encodeEvent",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum EventType",
          "name": "eventType",
          "type": "uint8"
        }
      ],
      "name": "getEpochOffset",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        },
        {
          "components": [
            {
              "internalType": "enum ContractType",
              "name": "contractType",
              "type": "uint8"
            },
            {
              "internalType": "enum Calendar",
              "name": "calendar",
              "type": "uint8"
            },
            {
              "internalType": "enum ContractRole",
              "name": "contractRole",
              "type": "uint8"
            },
            {
              "internalType": "enum DayCountConvention",
              "name": "dayCountConvention",
              "type": "uint8"
            },
            {
              "internalType": "enum BusinessDayConvention",
              "name": "businessDayConvention",
              "type": "uint8"
            },
            {
              "internalType": "enum EndOfMonthConvention",
              "name": "endOfMonthConvention",
              "type": "uint8"
            },
            {
              "internalType": "enum ScalingEffect",
              "name": "scalingEffect",
              "type": "uint8"
            },
            {
              "internalType": "enum FeeBasis",
              "name": "feeBasis",
              "type": "uint8"
            },
            {
              "internalType": "address",
              "name": "currency",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "settlementCurrency",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "marketObjectCodeRateReset",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "statusDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "initialExchangeDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maturityDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "issueDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "purchaseDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "capitalizationEndDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cycleAnchorDateOfInterestPayment",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cycleAnchorDateOfRateReset",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cycleAnchorDateOfScalingIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cycleAnchorDateOfFee",
              "type": "uint256"
            },
            {
              "internalType": "int256",
              "name": "notionalPrincipal",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "nominalInterestRate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "accruedInterest",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "rateMultiplier",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "rateSpread",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "nextResetRate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "feeRate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "feeAccrued",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "premiumDiscountAtIED",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "priceAtPurchaseDate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "priceAtTerminationDate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "lifeCap",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "lifeFloor",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "periodCap",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "periodFloor",
              "type": "int256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IP",
              "name": "gracePeriod",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IP",
              "name": "delinquencyPeriod",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "enum S",
                  "name": "s",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IPS",
              "name": "cycleOfInterestPayment",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "enum S",
                  "name": "s",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IPS",
              "name": "cycleOfRateReset",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "enum S",
                  "name": "s",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IPS",
              "name": "cycleOfScalingIndex",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "i",
                  "type": "uint256"
                },
                {
                  "internalType": "enum P",
                  "name": "p",
                  "type": "uint8"
                },
                {
                  "internalType": "enum S",
                  "name": "s",
                  "type": "uint8"
                },
                {
                  "internalType": "bool",
                  "name": "isSet",
                  "type": "bool"
                }
              ],
              "internalType": "struct IPS",
              "name": "cycleOfFee",
              "type": "tuple"
            }
          ],
          "internalType": "struct PAMTerms",
          "name": "",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "enum ContractPerformance",
              "name": "contractPerformance",
              "type": "uint8"
            },
            {
              "internalType": "uint256",
              "name": "statusDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "nonPerformingDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maturityDate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "terminationDate",
              "type": "uint256"
            },
            {
              "internalType": "int256",
              "name": "notionalPrincipal",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "accruedInterest",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "feeAccrued",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "nominalInterestRate",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "interestScalingMultiplier",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "notionalScalingMultiplier",
              "type": "int256"
            }
          ],
          "internalType": "struct PAMState",
          "name": "state",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "int256",
              "name": "exerciseAmount",
              "type": "int256"
            },
            {
              "internalType": "bool",
              "name": "isSet",
              "type": "bool"
            }
          ],
          "internalType": "struct UnderlyingState",
          "name": "",
          "type": "tuple"
        }
      ],
      "name": "isEventScheduled",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "timestamp",
          "type": "uint256"
        },
        {
          "internalType": "enum BusinessDayConvention",
          "name": "convention",
          "type": "uint8"
        },
        {
          "internalType": "enum Calendar",
          "name": "calendar",
          "type": "uint8"
        },
        {
          "internalType": "uint256",
          "name": "maturityDate",
          "type": "uint256"
        }
      ],
      "name": "shiftCalcTime",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "timestamp",
          "type": "uint256"
        },
        {
          "internalType": "enum BusinessDayConvention",
          "name": "convention",
          "type": "uint8"
        },
        {
          "internalType": "enum Calendar",
          "name": "calendar",
          "type": "uint8"
        },
        {
          "internalType": "uint256",
          "name": "maturityDate",
          "type": "uint256"
        }
      ],
      "name": "shiftEventTime",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x009f1ac9fab1419b166f3b4e1a0efccc5bbfc5772c1b7984011f37c9febec8f8",
  "receipt": {
    "to": null,
    "from": "0xf6bb741F0C106a504943eaE908C3b67bcf4bF1CC",
    "contractAddress": "0xd295724BE00296e9c6Cce7d786fa48b4FBB57894",
    "transactionIndex": 13,
    "gasUsed": "3963128",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x05dfe0762da7d5bb676163d2a9c30578c5a2a18328f130721259872935c3ae5b",
    "transactionHash": "0x009f1ac9fab1419b166f3b4e1a0efccc5bbfc5772c1b7984011f37c9febec8f8",
    "logs": [],
    "blockNumber": 7712997,
    "cumulativeGasUsed": "5498539",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "37e2a100a6f868553298dee57e286371",
  "metadata": "{\"compiler\":{\"version\":\"0.7.4+commit.3f05b770\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"MAX_CYCLE_SIZE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_EVENT_SCHEDULE_SIZE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ONE_POINT_ZERO\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum EndOfMonthConvention\",\"name\":\"eomc\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"enum S\",\"name\":\"s\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IPS\",\"name\":\"cycle\",\"type\":\"tuple\"}],\"name\":\"adjustEndOfMonthConvention\",\"outputs\":[{\"internalType\":\"enum EndOfMonthConvention\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum ContractType\",\"name\":\"contractType\",\"type\":\"uint8\"},{\"internalType\":\"enum Calendar\",\"name\":\"calendar\",\"type\":\"uint8\"},{\"internalType\":\"enum ContractRole\",\"name\":\"contractRole\",\"type\":\"uint8\"},{\"internalType\":\"enum DayCountConvention\",\"name\":\"dayCountConvention\",\"type\":\"uint8\"},{\"internalType\":\"enum BusinessDayConvention\",\"name\":\"businessDayConvention\",\"type\":\"uint8\"},{\"internalType\":\"enum EndOfMonthConvention\",\"name\":\"endOfMonthConvention\",\"type\":\"uint8\"},{\"internalType\":\"enum ScalingEffect\",\"name\":\"scalingEffect\",\"type\":\"uint8\"},{\"internalType\":\"enum FeeBasis\",\"name\":\"feeBasis\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"settlementCurrency\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"marketObjectCodeRateReset\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"statusDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialExchangeDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maturityDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"issueDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"purchaseDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"capitalizationEndDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleAnchorDateOfInterestPayment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleAnchorDateOfRateReset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleAnchorDateOfScalingIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleAnchorDateOfFee\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"notionalPrincipal\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"nominalInterestRate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"accruedInterest\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"rateMultiplier\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"rateSpread\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"nextResetRate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"feeRate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"feeAccrued\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"premiumDiscountAtIED\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"priceAtPurchaseDate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"priceAtTerminationDate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"lifeCap\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"lifeFloor\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"periodCap\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"periodFloor\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IP\",\"name\":\"gracePeriod\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IP\",\"name\":\"delinquencyPeriod\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"enum S\",\"name\":\"s\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IPS\",\"name\":\"cycleOfInterestPayment\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"enum S\",\"name\":\"s\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IPS\",\"name\":\"cycleOfRateReset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"enum S\",\"name\":\"s\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IPS\",\"name\":\"cycleOfScalingIndex\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"enum S\",\"name\":\"s\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IPS\",\"name\":\"cycleOfFee\",\"type\":\"tuple\"}],\"internalType\":\"struct PAMTerms\",\"name\":\"terms\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"segmentStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"segmentEnd\",\"type\":\"uint256\"},{\"internalType\":\"enum EventType\",\"name\":\"eventType\",\"type\":\"uint8\"}],\"name\":\"computeCyclicScheduleSegment\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_event\",\"type\":\"bytes32\"},{\"internalType\":\"enum BusinessDayConvention\",\"name\":\"bdc\",\"type\":\"uint8\"},{\"internalType\":\"enum Calendar\",\"name\":\"calendar\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"maturityDate\",\"type\":\"uint256\"}],\"name\":\"computeEventTimeForEvent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum ContractType\",\"name\":\"contractType\",\"type\":\"uint8\"},{\"internalType\":\"enum Calendar\",\"name\":\"calendar\",\"type\":\"uint8\"},{\"internalType\":\"enum ContractRole\",\"name\":\"contractRole\",\"type\":\"uint8\"},{\"internalType\":\"enum DayCountConvention\",\"name\":\"dayCountConvention\",\"type\":\"uint8\"},{\"internalType\":\"enum BusinessDayConvention\",\"name\":\"businessDayConvention\",\"type\":\"uint8\"},{\"internalType\":\"enum EndOfMonthConvention\",\"name\":\"endOfMonthConvention\",\"type\":\"uint8\"},{\"internalType\":\"enum ScalingEffect\",\"name\":\"scalingEffect\",\"type\":\"uint8\"},{\"internalType\":\"enum FeeBasis\",\"name\":\"feeBasis\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"settlementCurrency\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"marketObjectCodeRateReset\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"statusDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialExchangeDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maturityDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"issueDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"purchaseDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"capitalizationEndDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleAnchorDateOfInterestPayment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleAnchorDateOfRateReset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleAnchorDateOfScalingIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleAnchorDateOfFee\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"notionalPrincipal\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"nominalInterestRate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"accruedInterest\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"rateMultiplier\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"rateSpread\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"nextResetRate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"feeRate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"feeAccrued\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"premiumDiscountAtIED\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"priceAtPurchaseDate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"priceAtTerminationDate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"lifeCap\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"lifeFloor\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"periodCap\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"periodFloor\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IP\",\"name\":\"gracePeriod\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IP\",\"name\":\"delinquencyPeriod\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"enum S\",\"name\":\"s\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IPS\",\"name\":\"cycleOfInterestPayment\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"enum S\",\"name\":\"s\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IPS\",\"name\":\"cycleOfRateReset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"enum S\",\"name\":\"s\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IPS\",\"name\":\"cycleOfScalingIndex\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"enum S\",\"name\":\"s\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IPS\",\"name\":\"cycleOfFee\",\"type\":\"tuple\"}],\"internalType\":\"struct PAMTerms\",\"name\":\"terms\",\"type\":\"tuple\"}],\"name\":\"computeInitialState\",\"outputs\":[{\"components\":[{\"internalType\":\"enum ContractPerformance\",\"name\":\"contractPerformance\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"statusDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonPerformingDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maturityDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"terminationDate\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"notionalPrincipal\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"accruedInterest\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"feeAccrued\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"nominalInterestRate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"interestScalingMultiplier\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"notionalScalingMultiplier\",\"type\":\"int256\"}],\"internalType\":\"struct PAMState\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum ContractType\",\"name\":\"contractType\",\"type\":\"uint8\"},{\"internalType\":\"enum Calendar\",\"name\":\"calendar\",\"type\":\"uint8\"},{\"internalType\":\"enum ContractRole\",\"name\":\"contractRole\",\"type\":\"uint8\"},{\"internalType\":\"enum DayCountConvention\",\"name\":\"dayCountConvention\",\"type\":\"uint8\"},{\"internalType\":\"enum BusinessDayConvention\",\"name\":\"businessDayConvention\",\"type\":\"uint8\"},{\"internalType\":\"enum EndOfMonthConvention\",\"name\":\"endOfMonthConvention\",\"type\":\"uint8\"},{\"internalType\":\"enum ScalingEffect\",\"name\":\"scalingEffect\",\"type\":\"uint8\"},{\"internalType\":\"enum FeeBasis\",\"name\":\"feeBasis\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"settlementCurrency\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"marketObjectCodeRateReset\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"statusDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialExchangeDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maturityDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"issueDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"purchaseDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"capitalizationEndDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleAnchorDateOfInterestPayment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleAnchorDateOfRateReset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleAnchorDateOfScalingIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleAnchorDateOfFee\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"notionalPrincipal\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"nominalInterestRate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"accruedInterest\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"rateMultiplier\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"rateSpread\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"nextResetRate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"feeRate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"feeAccrued\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"premiumDiscountAtIED\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"priceAtPurchaseDate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"priceAtTerminationDate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"lifeCap\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"lifeFloor\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"periodCap\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"periodFloor\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IP\",\"name\":\"gracePeriod\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IP\",\"name\":\"delinquencyPeriod\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"enum S\",\"name\":\"s\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IPS\",\"name\":\"cycleOfInterestPayment\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"enum S\",\"name\":\"s\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IPS\",\"name\":\"cycleOfRateReset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"enum S\",\"name\":\"s\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IPS\",\"name\":\"cycleOfScalingIndex\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"enum S\",\"name\":\"s\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IPS\",\"name\":\"cycleOfFee\",\"type\":\"tuple\"}],\"internalType\":\"struct PAMTerms\",\"name\":\"terms\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"lastScheduleTime\",\"type\":\"uint256\"},{\"internalType\":\"enum EventType\",\"name\":\"eventType\",\"type\":\"uint8\"}],\"name\":\"computeNextCyclicEvent\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum ContractType\",\"name\":\"contractType\",\"type\":\"uint8\"},{\"internalType\":\"enum Calendar\",\"name\":\"calendar\",\"type\":\"uint8\"},{\"internalType\":\"enum ContractRole\",\"name\":\"contractRole\",\"type\":\"uint8\"},{\"internalType\":\"enum DayCountConvention\",\"name\":\"dayCountConvention\",\"type\":\"uint8\"},{\"internalType\":\"enum BusinessDayConvention\",\"name\":\"businessDayConvention\",\"type\":\"uint8\"},{\"internalType\":\"enum EndOfMonthConvention\",\"name\":\"endOfMonthConvention\",\"type\":\"uint8\"},{\"internalType\":\"enum ScalingEffect\",\"name\":\"scalingEffect\",\"type\":\"uint8\"},{\"internalType\":\"enum FeeBasis\",\"name\":\"feeBasis\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"settlementCurrency\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"marketObjectCodeRateReset\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"statusDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialExchangeDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maturityDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"issueDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"purchaseDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"capitalizationEndDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleAnchorDateOfInterestPayment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleAnchorDateOfRateReset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleAnchorDateOfScalingIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleAnchorDateOfFee\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"notionalPrincipal\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"nominalInterestRate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"accruedInterest\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"rateMultiplier\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"rateSpread\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"nextResetRate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"feeRate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"feeAccrued\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"premiumDiscountAtIED\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"priceAtPurchaseDate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"priceAtTerminationDate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"lifeCap\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"lifeFloor\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"periodCap\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"periodFloor\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IP\",\"name\":\"gracePeriod\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IP\",\"name\":\"delinquencyPeriod\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"enum S\",\"name\":\"s\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IPS\",\"name\":\"cycleOfInterestPayment\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"enum S\",\"name\":\"s\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IPS\",\"name\":\"cycleOfRateReset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"enum S\",\"name\":\"s\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IPS\",\"name\":\"cycleOfScalingIndex\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"enum S\",\"name\":\"s\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IPS\",\"name\":\"cycleOfFee\",\"type\":\"tuple\"}],\"internalType\":\"struct PAMTerms\",\"name\":\"terms\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"lastNonCyclicEvent\",\"type\":\"bytes32\"}],\"name\":\"computeNextNonCyclicEvent\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum ContractType\",\"name\":\"contractType\",\"type\":\"uint8\"},{\"internalType\":\"enum Calendar\",\"name\":\"calendar\",\"type\":\"uint8\"},{\"internalType\":\"enum ContractRole\",\"name\":\"contractRole\",\"type\":\"uint8\"},{\"internalType\":\"enum DayCountConvention\",\"name\":\"dayCountConvention\",\"type\":\"uint8\"},{\"internalType\":\"enum BusinessDayConvention\",\"name\":\"businessDayConvention\",\"type\":\"uint8\"},{\"internalType\":\"enum EndOfMonthConvention\",\"name\":\"endOfMonthConvention\",\"type\":\"uint8\"},{\"internalType\":\"enum ScalingEffect\",\"name\":\"scalingEffect\",\"type\":\"uint8\"},{\"internalType\":\"enum FeeBasis\",\"name\":\"feeBasis\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"settlementCurrency\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"marketObjectCodeRateReset\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"statusDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialExchangeDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maturityDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"issueDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"purchaseDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"capitalizationEndDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleAnchorDateOfInterestPayment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleAnchorDateOfRateReset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleAnchorDateOfScalingIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleAnchorDateOfFee\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"notionalPrincipal\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"nominalInterestRate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"accruedInterest\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"rateMultiplier\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"rateSpread\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"nextResetRate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"feeRate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"feeAccrued\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"premiumDiscountAtIED\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"priceAtPurchaseDate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"priceAtTerminationDate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"lifeCap\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"lifeFloor\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"periodCap\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"periodFloor\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IP\",\"name\":\"gracePeriod\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IP\",\"name\":\"delinquencyPeriod\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"enum S\",\"name\":\"s\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IPS\",\"name\":\"cycleOfInterestPayment\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"enum S\",\"name\":\"s\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IPS\",\"name\":\"cycleOfRateReset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"enum S\",\"name\":\"s\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IPS\",\"name\":\"cycleOfScalingIndex\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"enum S\",\"name\":\"s\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IPS\",\"name\":\"cycleOfFee\",\"type\":\"tuple\"}],\"internalType\":\"struct PAMTerms\",\"name\":\"terms\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"segmentStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"segmentEnd\",\"type\":\"uint256\"}],\"name\":\"computeNonCyclicScheduleSegment\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum ContractType\",\"name\":\"contractType\",\"type\":\"uint8\"},{\"internalType\":\"enum Calendar\",\"name\":\"calendar\",\"type\":\"uint8\"},{\"internalType\":\"enum ContractRole\",\"name\":\"contractRole\",\"type\":\"uint8\"},{\"internalType\":\"enum DayCountConvention\",\"name\":\"dayCountConvention\",\"type\":\"uint8\"},{\"internalType\":\"enum BusinessDayConvention\",\"name\":\"businessDayConvention\",\"type\":\"uint8\"},{\"internalType\":\"enum EndOfMonthConvention\",\"name\":\"endOfMonthConvention\",\"type\":\"uint8\"},{\"internalType\":\"enum ScalingEffect\",\"name\":\"scalingEffect\",\"type\":\"uint8\"},{\"internalType\":\"enum FeeBasis\",\"name\":\"feeBasis\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"settlementCurrency\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"marketObjectCodeRateReset\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"statusDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialExchangeDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maturityDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"issueDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"purchaseDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"capitalizationEndDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleAnchorDateOfInterestPayment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleAnchorDateOfRateReset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleAnchorDateOfScalingIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleAnchorDateOfFee\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"notionalPrincipal\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"nominalInterestRate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"accruedInterest\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"rateMultiplier\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"rateSpread\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"nextResetRate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"feeRate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"feeAccrued\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"premiumDiscountAtIED\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"priceAtPurchaseDate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"priceAtTerminationDate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"lifeCap\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"lifeFloor\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"periodCap\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"periodFloor\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IP\",\"name\":\"gracePeriod\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IP\",\"name\":\"delinquencyPeriod\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"enum S\",\"name\":\"s\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IPS\",\"name\":\"cycleOfInterestPayment\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"enum S\",\"name\":\"s\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IPS\",\"name\":\"cycleOfRateReset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"enum S\",\"name\":\"s\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IPS\",\"name\":\"cycleOfScalingIndex\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"enum S\",\"name\":\"s\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IPS\",\"name\":\"cycleOfFee\",\"type\":\"tuple\"}],\"internalType\":\"struct PAMTerms\",\"name\":\"terms\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"enum ContractPerformance\",\"name\":\"contractPerformance\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"statusDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonPerformingDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maturityDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"terminationDate\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"notionalPrincipal\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"accruedInterest\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"feeAccrued\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"nominalInterestRate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"interestScalingMultiplier\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"notionalScalingMultiplier\",\"type\":\"int256\"}],\"internalType\":\"struct PAMState\",\"name\":\"state\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"_event\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"externalData\",\"type\":\"bytes\"}],\"name\":\"computePayoffForEvent\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum ContractType\",\"name\":\"contractType\",\"type\":\"uint8\"},{\"internalType\":\"enum Calendar\",\"name\":\"calendar\",\"type\":\"uint8\"},{\"internalType\":\"enum ContractRole\",\"name\":\"contractRole\",\"type\":\"uint8\"},{\"internalType\":\"enum DayCountConvention\",\"name\":\"dayCountConvention\",\"type\":\"uint8\"},{\"internalType\":\"enum BusinessDayConvention\",\"name\":\"businessDayConvention\",\"type\":\"uint8\"},{\"internalType\":\"enum EndOfMonthConvention\",\"name\":\"endOfMonthConvention\",\"type\":\"uint8\"},{\"internalType\":\"enum ScalingEffect\",\"name\":\"scalingEffect\",\"type\":\"uint8\"},{\"internalType\":\"enum FeeBasis\",\"name\":\"feeBasis\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"settlementCurrency\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"marketObjectCodeRateReset\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"statusDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialExchangeDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maturityDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"issueDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"purchaseDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"capitalizationEndDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleAnchorDateOfInterestPayment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleAnchorDateOfRateReset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleAnchorDateOfScalingIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleAnchorDateOfFee\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"notionalPrincipal\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"nominalInterestRate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"accruedInterest\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"rateMultiplier\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"rateSpread\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"nextResetRate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"feeRate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"feeAccrued\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"premiumDiscountAtIED\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"priceAtPurchaseDate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"priceAtTerminationDate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"lifeCap\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"lifeFloor\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"periodCap\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"periodFloor\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IP\",\"name\":\"gracePeriod\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IP\",\"name\":\"delinquencyPeriod\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"enum S\",\"name\":\"s\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IPS\",\"name\":\"cycleOfInterestPayment\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"enum S\",\"name\":\"s\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IPS\",\"name\":\"cycleOfRateReset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"enum S\",\"name\":\"s\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IPS\",\"name\":\"cycleOfScalingIndex\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"enum S\",\"name\":\"s\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IPS\",\"name\":\"cycleOfFee\",\"type\":\"tuple\"}],\"internalType\":\"struct PAMTerms\",\"name\":\"terms\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"enum ContractPerformance\",\"name\":\"contractPerformance\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"statusDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonPerformingDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maturityDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"terminationDate\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"notionalPrincipal\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"accruedInterest\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"feeAccrued\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"nominalInterestRate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"interestScalingMultiplier\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"notionalScalingMultiplier\",\"type\":\"int256\"}],\"internalType\":\"struct PAMState\",\"name\":\"state\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"_event\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"externalData\",\"type\":\"bytes\"}],\"name\":\"computeStateForEvent\",\"outputs\":[{\"components\":[{\"internalType\":\"enum ContractPerformance\",\"name\":\"contractPerformance\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"statusDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonPerformingDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maturityDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"terminationDate\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"notionalPrincipal\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"accruedInterest\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"feeAccrued\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"nominalInterestRate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"interestScalingMultiplier\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"notionalScalingMultiplier\",\"type\":\"int256\"}],\"internalType\":\"struct PAMState\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractType\",\"outputs\":[{\"internalType\":\"enum ContractType\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_event\",\"type\":\"bytes32\"}],\"name\":\"decodeEvent\",\"outputs\":[{\"internalType\":\"enum EventType\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum EventType\",\"name\":\"eventType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"scheduleTime\",\"type\":\"uint256\"}],\"name\":\"encodeEvent\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum EventType\",\"name\":\"eventType\",\"type\":\"uint8\"}],\"name\":\"getEpochOffset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"enum ContractType\",\"name\":\"contractType\",\"type\":\"uint8\"},{\"internalType\":\"enum Calendar\",\"name\":\"calendar\",\"type\":\"uint8\"},{\"internalType\":\"enum ContractRole\",\"name\":\"contractRole\",\"type\":\"uint8\"},{\"internalType\":\"enum DayCountConvention\",\"name\":\"dayCountConvention\",\"type\":\"uint8\"},{\"internalType\":\"enum BusinessDayConvention\",\"name\":\"businessDayConvention\",\"type\":\"uint8\"},{\"internalType\":\"enum EndOfMonthConvention\",\"name\":\"endOfMonthConvention\",\"type\":\"uint8\"},{\"internalType\":\"enum ScalingEffect\",\"name\":\"scalingEffect\",\"type\":\"uint8\"},{\"internalType\":\"enum FeeBasis\",\"name\":\"feeBasis\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"settlementCurrency\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"marketObjectCodeRateReset\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"statusDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialExchangeDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maturityDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"issueDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"purchaseDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"capitalizationEndDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleAnchorDateOfInterestPayment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleAnchorDateOfRateReset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleAnchorDateOfScalingIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleAnchorDateOfFee\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"notionalPrincipal\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"nominalInterestRate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"accruedInterest\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"rateMultiplier\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"rateSpread\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"nextResetRate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"feeRate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"feeAccrued\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"premiumDiscountAtIED\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"priceAtPurchaseDate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"priceAtTerminationDate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"lifeCap\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"lifeFloor\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"periodCap\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"periodFloor\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IP\",\"name\":\"gracePeriod\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IP\",\"name\":\"delinquencyPeriod\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"enum S\",\"name\":\"s\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IPS\",\"name\":\"cycleOfInterestPayment\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"enum S\",\"name\":\"s\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IPS\",\"name\":\"cycleOfRateReset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"enum S\",\"name\":\"s\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IPS\",\"name\":\"cycleOfScalingIndex\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"enum P\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"enum S\",\"name\":\"s\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct IPS\",\"name\":\"cycleOfFee\",\"type\":\"tuple\"}],\"internalType\":\"struct PAMTerms\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"enum ContractPerformance\",\"name\":\"contractPerformance\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"statusDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonPerformingDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maturityDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"terminationDate\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"notionalPrincipal\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"accruedInterest\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"feeAccrued\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"nominalInterestRate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"interestScalingMultiplier\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"notionalScalingMultiplier\",\"type\":\"int256\"}],\"internalType\":\"struct PAMState\",\"name\":\"state\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"exerciseAmount\",\"type\":\"int256\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct UnderlyingState\",\"name\":\"\",\"type\":\"tuple\"}],\"name\":\"isEventScheduled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"enum BusinessDayConvention\",\"name\":\"convention\",\"type\":\"uint8\"},{\"internalType\":\"enum Calendar\",\"name\":\"calendar\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"maturityDate\",\"type\":\"uint256\"}],\"name\":\"shiftCalcTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"enum BusinessDayConvention\",\"name\":\"convention\",\"type\":\"uint8\"},{\"internalType\":\"enum Calendar\",\"name\":\"calendar\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"maturityDate\",\"type\":\"uint256\"}],\"name\":\"shiftEventTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"All numbers except unix timestamp are represented as multiple of 10 ** 18\",\"kind\":\"dev\",\"methods\":{\"adjustEndOfMonthConvention(uint8,uint256,(uint256,uint8,uint8,bool))\":{\"details\":\"The following is considered to dertermine if schedule dates are shifted to the end of month: - The convention SD (same day) means not adjusting, EM (end of month) means adjusting - Dates are only shifted if the schedule start date is an end-of-month date - Dates are only shifted if the schedule cycle is based on an \\\"M\\\" period unit or multiple thereof\",\"params\":{\"cycle\":\"the cycle struct\",\"eomc\":\"the end of month convention to adjust\",\"startTime\":\"timestamp of the cycle start\"},\"returns\":{\"_0\":\"the adjusted end of month convention\"}},\"computeCyclicScheduleSegment((uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,address,address,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,(uint256,uint8,bool),(uint256,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool)),uint256,uint256,uint8)\":{\"params\":{\"eventType\":\"eventType of the cyclic schedule\",\"segmentEnd\":\"end timestamp of the segement\",\"segmentStart\":\"start timestamp of the segment\",\"terms\":\"terms of the contract\"},\"returns\":{\"_0\":\"event schedule segment\"}},\"computeEventTimeForEvent(bytes32,uint8,uint8,uint256)\":{\"details\":\"For optimization reasons not located in EventUtil by applying the BDC specified in the terms\"},\"computeInitialState((uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,address,address,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,(uint256,uint8,bool),(uint256,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool)))\":{\"params\":{\"terms\":\"terms of the contract\"},\"returns\":{\"_0\":\"the initial state of the contract\"}},\"computeNextCyclicEvent((uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,address,address,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,(uint256,uint8,bool),(uint256,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool)),uint256,uint8)\":{\"params\":{\"eventType\":\"eventType of the cyclic schedule\",\"lastScheduleTime\":\"last occurrence of cyclic event\",\"terms\":\"terms of the contract\"},\"returns\":{\"_0\":\"event schedule segment\"}},\"computeNextNonCyclicEvent((uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,address,address,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,(uint256,uint8,bool),(uint256,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool)),bytes32)\":{\"details\":\"Assumes that non-cyclic events of the same event type have a unique schedule time\",\"params\":{\"lastNonCyclicEvent\":\"last non-cyclic event\",\"terms\":\"terms of the contract\"},\"returns\":{\"_0\":\"next non-cyclic event\"}},\"computeNonCyclicScheduleSegment((uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,address,address,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,(uint256,uint8,bool),(uint256,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool)),uint256,uint256)\":{\"params\":{\"segmentEnd\":\"end timestamp of the segement\",\"segmentStart\":\"start timestamp of the segment\",\"terms\":\"terms of the contract\"},\"returns\":{\"_0\":\"segment of the non-cyclic schedule\"}},\"computePayoffForEvent((uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,address,address,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,(uint256,uint8,bool),(uint256,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool)),(uint8,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256),bytes32,bytes)\":{\"params\":{\"_event\":\"event for which the payoff should be evaluated\",\"externalData\":\"external data needed for POF evaluation (e.g. fxRate)\",\"state\":\"current state of the contract\",\"terms\":\"terms of the contract\"},\"returns\":{\"_0\":\"the payoff of the event\"}},\"computeStateForEvent((uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,address,address,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,(uint256,uint8,bool),(uint256,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool)),(uint8,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256),bytes32,bytes)\":{\"params\":{\"_event\":\"event to be applied to the contract state\",\"externalData\":\"external data needed for STF evaluation (e.g. rate for RR events)\",\"state\":\"current state of the contract\",\"terms\":\"terms of the contract\"},\"returns\":{\"_0\":\"the resulting contract state\"}},\"isEventScheduled(bytes32,(uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,address,address,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,(uint256,uint8,bool),(uint256,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool)),(uint8,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256),(int256,bool))\":{\"params\":{\"state\":\"current state of the contract param underlyingState state of the underlying (empty state object if non-existing)\"},\"returns\":{\"_0\":\"boolean indicating whether event is still scheduled\"}}},\"title\":\"PAMEngine\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"adjustEndOfMonthConvention(uint8,uint256,(uint256,uint8,uint8,bool))\":{\"notice\":\"This function makes an adjustment on the end of month convention.\"},\"computeCyclicScheduleSegment((uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,address,address,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,(uint256,uint8,bool),(uint256,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool)),uint256,uint256,uint8)\":{\"notice\":\"Computes a schedule segment of cyclic contract events based on the contract terms and the specified timestamps.\"},\"computeEventTimeForEvent(bytes32,uint8,uint8,uint256)\":{\"notice\":\"Returns the event time for a given schedule time\"},\"computeInitialState((uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,address,address,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,(uint256,uint8,bool),(uint256,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool)))\":{\"notice\":\"Initialize contract state space based on the contract terms.\"},\"computeNextCyclicEvent((uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,address,address,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,(uint256,uint8,bool),(uint256,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool)),uint256,uint8)\":{\"notice\":\"Computes a schedule segment of cyclic contract events based on the contract terms and the specified timestamps.\"},\"computeNextNonCyclicEvent((uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,address,address,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,(uint256,uint8,bool),(uint256,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool)),bytes32)\":{\"notice\":\"Computes the next non-cyclic contract events based on the contract terms and the timestamp on which the prev. event occured.\"},\"computeNonCyclicScheduleSegment((uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,address,address,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,(uint256,uint8,bool),(uint256,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool)),uint256,uint256)\":{\"notice\":\"Computes a schedule segment of non-cyclic contract events based on the contract terms and the specified timestamps.\"},\"computePayoffForEvent((uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,address,address,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,(uint256,uint8,bool),(uint256,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool)),(uint8,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256),bytes32,bytes)\":{\"notice\":\"Evaluates the payoff for an event under the current state of the contract.\"},\"computeStateForEvent((uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,address,address,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,(uint256,uint8,bool),(uint256,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool)),(uint8,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256),bytes32,bytes)\":{\"notice\":\"Applys an event to the current state of a contract and returns the resulting contract state.\"},\"getEpochOffset(uint8)\":{\"notice\":\"Returns the epoch offset for a given event type to determine the correct order of events if multiple events have the same timestamp\"},\"isEventScheduled(bytes32,(uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,address,address,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,(uint256,uint8,bool),(uint256,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool)),(uint8,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256),(int256,bool))\":{\"notice\":\"Verifies that the provided event is still scheduled under the terms, the current state of the contract and the current state of the underlying. param _event event for which to check if its still scheduled param terms terms of the contract\"},\"shiftCalcTime(uint256,uint8,uint8,uint256)\":{\"notice\":\"Used in POFs and STFs for DCFs. No shifting is applied if a Calc/Shift instead of Shift/Calc BDC is provided.\"}},\"notice\":\"Inherits from BaseEngine by implementing STFs, POFs according to the ACTUS standard for a PAM contract\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/ACTUS/Engines/PAM/PAMEngine.sol\":\"PAMEngine\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0xba96bc371ba999f452985a98717cca1e4c4abb598dc038a9a9c3db08129b1ba4\",\"license\":\"MIT\"},\"@openzeppelin/contracts/math/SignedSafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @title SignedSafeMath\\n * @dev Signed math operations with safety checks that revert on error.\\n */\\nlibrary SignedSafeMath {\\n    int256 constant private _INT256_MIN = -2**255;\\n\\n    /**\\n     * @dev Returns the multiplication of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        require(!(a == -1 && b == _INT256_MIN), \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        int256 c = a * b;\\n        require(c / a == b, \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two signed integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        require(b != 0, \\\"SignedSafeMath: division by zero\\\");\\n        require(!(b == -1 && a == _INT256_MIN), \\\"SignedSafeMath: division overflow\\\");\\n\\n        int256 c = a / b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \\\"SignedSafeMath: subtraction overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a + b;\\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \\\"SignedSafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n}\\n\",\"keccak256\":\"0xba085261d44cf28d2583f7c8cdb2f0a6a495ff1a640f86d995ea9d36b42b0046\",\"license\":\"MIT\"},\"contracts/ACTUS/Core/ACTUSConstants.sol\":{\"content\":\"// \\\"SPDX-License-Identifier: Apache-2.0\\\"\\npragma solidity ^0.7.0;\\n\\n\\n/**\\n * @title ACTUSConstants\\n * @notice Contains all type definitions for ACTUS. See ACTUS-Dictionary for definitions\\n */\\ncontract ACTUSConstants {\\n\\n    // constants used throughout\\n    uint256 constant public PRECISION = 18;\\n    int256 constant public ONE_POINT_ZERO = 1 * 10 ** 18;\\n    uint256 constant public MAX_CYCLE_SIZE = 120;\\n    uint256 constant public MAX_EVENT_SCHEDULE_SIZE = 120;\\n}\\n\",\"keccak256\":\"0x1568471e72800002ad945bf084f96368f5dfb597105f2e3f11534905abda9495\",\"license\":\"Apache-2.0\"},\"contracts/ACTUS/Core/ACTUSTypes.sol\":{\"content\":\"// \\\"SPDX-License-Identifier: Apache-2.0\\\"\\npragma solidity ^0.7.0;\\n\\n/**\\n * Commit: https://github.com/atpar/actus-dictionary/commit/b85b9b378967de6bfc4d8b6687b520c48bce9890\\n * Date: 2020-10-06\\n */\\n\\n// IPS\\nenum P {D, W, M, Q, H, Y} // P=[D=Days, W=Weeks, M=Months, Q=Quarters, H=Halfyear, Y=Year]\\nenum S {LONG, SHORT} // S=[+=long stub,- short stub, {} if S empty then - for short stub]\\nstruct IPS {\\n    uint256 i; // I=Integer\\n    P p;\\n    S s;\\n    bool isSet;\\n}\\n\\nstruct IP {\\n    uint256 i;\\n    P p;\\n    bool isSet;\\n}\\n\\n// Number of enum options should be limited to 256 (8 bits) such that 255 enums can be packed fit into 256 bits (bytes32)\\nenum BusinessDayConvention {NOS, SCF, SCMF, CSF, CSMF, SCP, SCMP, CSP, CSMP}\\nenum Calendar {NC, MF}\\nenum ContractPerformance {PF, DL, DQ, DF, MD, TD}\\nenum ContractReferenceType {CNT, CID, MOC, EID, CST}\\nenum ContractReferenceRole {UDL, FIL, SEL, COVE, COVI}\\nenum ContractRole {RPA, RPL, RFL, PFL, RF, PF, BUY, SEL, COL, CNO, UDL, UDLP, UDLM}\\nenum ContractType {PAM, ANN, NAM, LAM, LAX, CLM, UMP, CSH, STK, COM, SWAPS, SWPPV, FXOUT, CAPFL, FUTUR, OPTNS, CEG, CEC, CERTF, COLLA}\\nenum CouponType {NOC, FIX, FCN, PRF}\\nenum CyclePointOfInterestPayment {B, E}\\nenum CyclePointOfRateReset {B, E}\\nenum DayCountConvention {AA, A360, A365, _30E360ISDA, _30E360, _28E336, ONE, OBYT, HRSAA, MINAA, SECAA}\\nenum EndOfMonthConvention {SD, EOM}\\n//               0   1    2    3    4   5   6   7   8   9  10    11  12   13   14   15   16   17   18   19   20   21   22   23   24   25  26  27    28   29  30  31  32  33\\nenum EventType {NE, CE, ISS, IED, PRD, FP, PR, PD, PY, PP, IP, IPCI, RRF, RR, DIF, DIX, DIP, COF, COP, REF, REX, REP, SPF, SPS, EXO, EXE, ST, SC, IPCB, PRF, MC, TD, MD, AD}\\nenum FeeBasis {A, N}\\n// enum GuaranteedExposure {NO, NI, MV} // not implemented\\n// enum InterestCalculationBase {NT, NTIED, NTL} // not implemented\\n// enum PenaltyType {O, A, N, I}\\n// enum PrepaymentEffect {N, A, M} // not implemented\\nenum RedeemableByIssuer {Y, N}\\nenum ScalingEffect {_000, I00, _0N0, IN0}\\n// enum Seniority {S, J} // not implemented\\n\\nstruct ContractReference {\\n    bytes32 object;\\n    bytes32 object2; // workaround for solc bug (replace object and object2 with single bytes attribute)\\n    ContractReferenceType _type;\\n    ContractReferenceRole role;\\n}\\n\\nstruct UnderlyingState {\\n    int256 exerciseAmount;\\n    bool isSet;\\n}\\n\\nstruct ANNState {\\n    ContractPerformance contractPerformance;\\n\\n    uint256 statusDate;\\n    uint256 nonPerformingDate;\\n    uint256 maturityDate;\\n    uint256 terminationDate;\\n\\n    int256 notionalPrincipal;\\n    // int256 notionalPrincipal2;\\n    int256 accruedInterest;\\n    // int256 accruedInterest2;\\n    int256 feeAccrued;\\n    int256 nominalInterestRate;\\n    // int256 nominalInterestRate2;\\n    // int256 interestCalculationBaseAmount;\\n    int256 interestScalingMultiplier;\\n    int256 notionalScalingMultiplier;\\n    int256 nextPrincipalRedemptionPayment;\\n}\\n\\nstruct CECState {\\n    ContractPerformance contractPerformance;\\n\\n    uint256 statusDate;\\n    uint256 maturityDate;\\n    uint256 exerciseDate;\\n    uint256 terminationDate;\\n\\n    int256 feeAccrued;\\n    int256 exerciseAmount;\\n}\\n\\nstruct CEGState {\\n    ContractPerformance contractPerformance;\\n\\n    uint256 statusDate;\\n    uint256 nonPerformingDate;\\n    uint256 maturityDate;\\n    uint256 exerciseDate;\\n    uint256 terminationDate;\\n\\n    int256 notionalPrincipal;\\n    int256 feeAccrued;\\n    int256 exerciseAmount;\\n}\\n\\nstruct CERTFState {\\n    ContractPerformance contractPerformance;\\n\\n    uint256 statusDate;\\n    uint256 nonPerformingDate;\\n    uint256 maturityDate;\\n    uint256 exerciseDate;\\n    uint256 terminationDate;\\n    uint256 lastCouponFixingDate;\\n\\n    int256 exerciseAmount;\\n    int256 exerciseQuantity;\\n    int256 quantity;\\n    int256 couponAmountFixed;\\n    // int256 exerciseQuantityOrdered;\\n    int256 marginFactor;\\n    int256 adjustmentFactor;\\n}\\n\\nstruct PAMState {\\n    ContractPerformance contractPerformance;\\n\\n    uint256 statusDate;\\n    uint256 nonPerformingDate;\\n    uint256 maturityDate;\\n    uint256 terminationDate;\\n\\n    int256 notionalPrincipal;\\n    // int256 notionalPrincipal2;\\n    int256 accruedInterest;\\n    // int256 accruedInterest2;\\n    int256 feeAccrued;\\n    int256 nominalInterestRate;\\n    // int256 nominalInterestRate2;\\n    // int256 interestCalculationBaseAmount;\\n    int256 interestScalingMultiplier;\\n    int256 notionalScalingMultiplier;\\n}\\n\\nstruct STKState {\\n    ContractPerformance contractPerformance;\\n\\n    uint256 statusDate;\\n    uint256 nonPerformingDate;\\n    uint256 maturityDate;\\n    uint256 exerciseDate;\\n    uint256 terminationDate;\\n    uint256 lastDividendFixingDate;\\n    // uint256 dividendFixingDate; // not implemented\\n    // uint256 dividendExDate; // not implemented\\n    // uint256 dividendPaymentDate; // not implemented\\n    // uint256 splitSettlementDate; // not implemented\\n    // uint256 redemptionExDate; // not implemented\\n    // uint256 redemptionPaymentDate; // not implemented\\n\\n    int256 notionalPrincipal;\\n    int256 exerciseAmount;\\n    int256 exerciseQuantity;\\n    int256 quantity;\\n    int256 couponAmountFixed;\\n    // int256 exerciseQuantityOrdered;\\n    int256 marginFactor;\\n    int256 adjustmentFactor;\\n    int256 dividendPaymentAmount;\\n    int256 splitRatio;\\n}\\n\\nstruct COLLAState {\\n    ContractPerformance contractPerformance;\\n\\n    uint256 statusDate;\\n    uint256 nonPerformingDate;\\n    uint256 maturityDate;\\n    uint256 terminationDate;\\n\\n    int256 notionalPrincipal;\\n    int256 accruedInterest;\\n    int256 nominalInterestRate;\\n    int256 interestScalingMultiplier;\\n    int256 notionalScalingMultiplier;\\n}\\n\\nstruct ANNTerms {\\n    ContractType contractType;\\n    Calendar calendar;\\n    ContractRole contractRole;\\n    DayCountConvention dayCountConvention;\\n    BusinessDayConvention businessDayConvention;\\n    EndOfMonthConvention endOfMonthConvention;\\n    ScalingEffect scalingEffect;\\n    // PenaltyType penaltyType; not implemented\\n    FeeBasis feeBasis;\\n    // ContractPerformance contractPerformance; // state only\\n    // Seniority seniority; // not implemented\\n    // PrepaymentEffect prepaymentEffect; // not implemented\\n    // InterestCalculationBase interestCalculationBase; // not implemented\\n\\n    address currency;\\n    address settlementCurrency;\\n\\n    // bytes32 marketObjectCode; // not implemented\\n    bytes32 marketObjectCodeRateReset;\\n    // bytes32 marketObjectCodeOfScalingIndex; // not implemented\\n\\n    uint256 statusDate;\\n    uint256 initialExchangeDate;\\n    uint256 maturityDate;\\n    uint256 issueDate;\\n    // uint256 terminationDate; // state only\\n    uint256 purchaseDate;\\n    uint256 capitalizationEndDate;\\n    // uint256 ammortizationDate; // not implemented\\n    // uint256 optionExerciseEndDate; // not implemented\\n    // uint256 nonPerformingDate; // state only\\n    uint256 cycleAnchorDateOfInterestPayment;\\n    // uint256 cycleAnchorDateOfInterestCalculationBase; // not implemented\\n    uint256 cycleAnchorDateOfRateReset;\\n    uint256 cycleAnchorDateOfScalingIndex;\\n    uint256 cycleAnchorDateOfFee;\\n    uint256 cycleAnchorDateOfPrincipalRedemption;\\n    // uint256 cycleAnchorDateOfOptionality; // not implemented\\n\\n    int256 notionalPrincipal;\\n    int256 nominalInterestRate;\\n    int256 accruedInterest;\\n    int256 rateMultiplier;\\n    int256 rateSpread;\\n    int256 nextResetRate;\\n    int256 feeRate;\\n    int256 feeAccrued;\\n    // int256 penaltyRate; not implemented\\n    // int256 delinquencyRate; not implemented\\n    int256 premiumDiscountAtIED;\\n    int256 priceAtPurchaseDate;\\n    int256 priceAtTerminationDate;\\n    // int256 creditLineAmount; // not implemented\\n    // int256 scalingIndexAtStatusDate; // not implemented\\n    // int256 marketValueObserved; // not implemented\\n    int256 nextPrincipalRedemptionPayment;\\n    // int256 coverageOfCreditEnhancement;\\n    // int256 interestCalculationBaseAmount; // not implemented\\n    int256 lifeCap;\\n    int256 lifeFloor;\\n    int256 periodCap;\\n    int256 periodFloor;\\n\\n    IP gracePeriod;\\n    IP delinquencyPeriod;\\n    // IP prepaymentPeriod; // not implemented\\n    // IP fixingPeriod; // not implemented\\n\\n    IPS cycleOfInterestPayment;\\n    IPS cycleOfRateReset;\\n    IPS cycleOfScalingIndex;\\n    IPS cycleOfFee;\\n    IPS cycleOfPrincipalRedemption;\\n    // IPS cycleOfOptionality; // not implemented\\n    // IPS cycleOfInterestCalculationBase; // not implemented\\n}\\n\\nstruct CECTerms {\\n    ContractType contractType;\\n    Calendar calendar;\\n    ContractRole contractRole;\\n    DayCountConvention dayCountConvention;\\n    BusinessDayConvention businessDayConvention;\\n    EndOfMonthConvention endOfMonthConvention;\\n    ContractPerformance creditEventTypeCovered;\\n    FeeBasis feeBasis;\\n    // GuaranteedExposure guaranteedExposure; // not implemented\\n\\n    uint256 statusDate;\\n    uint256 maturityDate;\\n    // uint256 exerciseDate; // state only\\n\\n    int256 notionalPrincipal;\\n    int256 feeRate;\\n    // int256 exerciseAmount; // state only\\n    int256 coverageOfCreditEnhancement;\\n\\n    // IP settlementPeriod; // not implemented\\n\\n    // for simplification since terms are limited only two contract references\\n    // - make ContractReference top level and skip ContractStructure\\n    ContractReference contractReference_1;\\n    ContractReference contractReference_2;\\n}\\n\\nstruct CEGTerms {\\n    ContractType contractType;\\n    Calendar calendar;\\n    ContractRole contractRole;\\n    DayCountConvention dayCountConvention;\\n    BusinessDayConvention businessDayConvention;\\n    EndOfMonthConvention endOfMonthConvention;\\n    FeeBasis feeBasis;\\n    // ContractPerformance contractPerformance; // state only\\n    ContractPerformance creditEventTypeCovered;\\n    // GuaranteedExposure guaranteedExposure; // not implemented\\n\\n    address currency;\\n    address settlementCurrency;\\n\\n    uint256 statusDate;\\n    uint256 maturityDate;\\n    uint256 purchaseDate;\\n    uint256 cycleAnchorDateOfFee;\\n    // uint256 exerciseDate; // state only\\n    // uint256 nonPerformingDate; // state only\\n\\n    int256 notionalPrincipal;\\n    // int256 delinquencyRate; not implemented\\n    int256 feeAccrued;\\n    int256 feeRate;\\n    int256 priceAtPurchaseDate;\\n    int256 coverageOfCreditEnhancement;\\n    // int256 exerciseAmount; // state only\\n\\n    IP gracePeriod;\\n    IP delinquencyPeriod;\\n    // IP settlementPeriod; // not implemented\\n\\n    IPS cycleOfFee;\\n\\n    // for simplification since terms are limited only two contract references\\n    // - make ContractReference top level and skip ContractStructure\\n    ContractReference contractReference_1;\\n    ContractReference contractReference_2;\\n}\\n\\nstruct CERTFTerms {\\n    ContractType contractType;\\n    Calendar calendar;\\n    ContractRole contractRole;\\n    DayCountConvention dayCountConvention;\\n    BusinessDayConvention businessDayConvention;\\n    EndOfMonthConvention endOfMonthConvention;\\n    CouponType couponType;\\n    // ContractPerformance contractPerformance; state only\\n\\n    address currency;\\n    address settlementCurrency;\\n\\n    // bytes32 marketObjectCode; // not implemented\\n\\n    uint256 statusDate;\\n    uint256 initialExchangeDate;\\n    uint256 maturityDate;\\n    // uint256 nonPerformingDate; // state only\\n    uint256 issueDate;\\n    // uint256 lastCouponFixingDate; // state only\\n    uint256 cycleAnchorDateOfRedemption;\\n    uint256 cycleAnchorDateOfTermination;\\n    uint256 cycleAnchorDateOfCoupon;\\n\\n    int256 nominalPrice;\\n    int256 issuePrice;\\n    // int256 delinquencyRate; // not implemented\\n    int256 quantity;\\n    // int256 exerciseQuantity; // state only\\n    // int256 exerciseQuantityOrdered; // state only\\n    // int256 marginFactor;  // state only\\n    // int256 adjustmentFactor; // state only\\n    int256 denominationRatio;\\n    int256 couponRate;\\n    // int256 exerciseAmount; // state only\\n    // int256 couponAmountFixed; // state only\\n\\n    IP gracePeriod;\\n    IP delinquencyPeriod;\\n    IP settlementPeriod;\\n    IP fixingPeriod;\\n    IP redemptionRecordPeriod;\\n\\n    IPS cycleOfRedemption;\\n    IPS cycleOfTermination;\\n    IPS cycleOfCoupon;\\n\\n    ContractReference contractReference_1;\\n    ContractReference contractReference_2;\\n}\\n\\nstruct PAMTerms {\\n    ContractType contractType;\\n    Calendar calendar;\\n    ContractRole contractRole;\\n    DayCountConvention dayCountConvention;\\n    BusinessDayConvention businessDayConvention;\\n    EndOfMonthConvention endOfMonthConvention;\\n    ScalingEffect scalingEffect;\\n    // PenaltyType penaltyType; not implemented\\n    FeeBasis feeBasis;\\n    // ContractPerformance contractPerformance; // state only\\n    // Seniority seniority; // not implemented\\n    // PrepaymentEffect prepaymentEffect; // not implemented\\n    // CyclePointOfInterestPayment cyclePointOfInterestPayment; // not implemented\\n    // CyclePointOfRateReset cyclePointOfRateReset; // not implemented\\n\\n    address currency;\\n    address settlementCurrency;\\n\\n    // bytes32 marketObjectCode; // not implemented\\n    bytes32 marketObjectCodeRateReset;\\n    // bytes32 marketObjectCodeOfScalingIndex; // not implemented\\n\\n    uint256 statusDate;\\n    uint256 initialExchangeDate;\\n    uint256 maturityDate;\\n    uint256 issueDate;\\n    // uint256 terminationDate; // state only\\n    uint256 purchaseDate;\\n    uint256 capitalizationEndDate;\\n    // uint256 optionExerciseEndDate; // not implemented\\n    // uint256 nonPerformingDate; // state only\\n    uint256 cycleAnchorDateOfInterestPayment;\\n    uint256 cycleAnchorDateOfRateReset;\\n    uint256 cycleAnchorDateOfScalingIndex;\\n    uint256 cycleAnchorDateOfFee;\\n    // uint256 cycleAnchorDateOfOptionality; // not implemented\\n\\n    int256 notionalPrincipal;\\n    int256 nominalInterestRate;\\n    int256 accruedInterest;\\n    int256 rateMultiplier;\\n    int256 rateSpread;\\n    int256 nextResetRate;\\n    int256 feeRate;\\n    int256 feeAccrued;\\n    // int256 penaltyRate; not implemented\\n    // int256 delinquencyRate; // not implemented\\n    int256 premiumDiscountAtIED;\\n    int256 priceAtPurchaseDate;\\n    int256 priceAtTerminationDate;\\n    // int256 creditLineAmount; // not implemented\\n    // int256 scalingIndexAtStatusDate; // not implemented\\n    // int256 marketValueObserved; // not implemented\\n    int256 lifeCap;\\n    int256 lifeFloor;\\n    int256 periodCap;\\n    int256 periodFloor;\\n\\n    IP gracePeriod;\\n    IP delinquencyPeriod;\\n    // IP prepaymentPeriod; // not implemented\\n    // IP fixingPeriod; // not implemented\\n\\n    IPS cycleOfInterestPayment;\\n    IPS cycleOfRateReset;\\n    IPS cycleOfScalingIndex;\\n    IPS cycleOfFee;\\n    // IPS cycleOfOptionality; // not implemented\\n}\\n\\nstruct STKTerms {\\n    ContractType contractType;\\n    Calendar calendar;\\n    ContractRole contractRole;\\n    DayCountConvention dayCountConvention;\\n    BusinessDayConvention businessDayConvention;\\n    EndOfMonthConvention endOfMonthConvention;\\n    RedeemableByIssuer redeemableByIssuer;\\n    // Seniority seniority; // not implemented\\n\\n    address currency;\\n    address settlementCurrency;\\n\\n    // bytes32 marketObjectCode; // not implemented\\n\\n    uint256 statusDate;\\n    uint256 issueDate;\\n    uint256 purchaseDate;\\n    uint256 cycleAnchorDateOfDividend;\\n\\n    int256 nominalPrice;\\n    int256 notionalPrincipal;\\n    int256 issuePrice;\\n    int256 quantity;\\n    int256 priceAtPurchaseDate;\\n    int256 redemptionPrice;\\n    int256 priceAtTerminationDate;\\n\\n    IP dividendRecordPeriod;\\n    IP dividendPaymentPeriod;\\n    IP splitSettlementPeriod;\\n    IP redemptionRecordPeriod;\\n    IP redemptionPaymentPeriod;\\n\\n    IPS cycleOfDividend;\\n}\\n\\nstruct COLLATerms {\\n    ContractType contractType;\\n    Calendar calendar;\\n    ContractRole contractRole;\\n    DayCountConvention dayCountConvention;\\n    BusinessDayConvention businessDayConvention;\\n    EndOfMonthConvention endOfMonthConvention;\\n    // ContractPerformance contractPerformance; // state only\\n\\n    bytes32 marketObjectCodeOfCollateral;\\n\\n    address currency;\\n    address settlementCurrency;\\n    address collateralCurrency;\\n\\n    uint256 statusDate;\\n    uint256 initialExchangeDate;\\n    uint256 maturityDate;\\n    uint256 capitalizationEndDate;\\n    // uint256 nonPerformingDate; // state only\\n    uint256 cycleAnchorDateOfInterestPayment;\\n\\n    int256 notionalPrincipal;\\n    int256 nominalInterestRate;\\n    int256 accruedInterest;\\n    int256 premiumDiscountAtIED;\\n    int256 coverageOfCollateral;\\n\\n    IP gracePeriod;\\n    IP delinquencyPeriod;\\n\\n    IPS cycleOfInterestPayment;\\n}\\n\",\"keccak256\":\"0x79bdd18aa3c6bdb9bb27e50b140bf43977ced292fdf89c2b2a237a0ec6c719fb\",\"license\":\"Apache-2.0\"},\"contracts/ACTUS/Core/Conventions/BusinessDayConventions.sol\":{\"content\":\"// \\\"SPDX-License-Identifier: Apache-2.0\\\"\\npragma solidity ^0.7.0;\\n\\nimport \\\"../../../external/BokkyPooBah/BokkyPooBahsDateTimeLibrary.sol\\\";\\n\\nimport \\\"../ACTUSTypes.sol\\\";\\n\\n\\n/**\\n * @title BusinessDayConventions\\n * @notice Contains conventions of how to handle non-business days when generating schedules of events.\\n * The events schedule time can be shifted or not, if shifted it is possible that it is shifted to the next\\n * or previous valid business days, etc.\\n */\\ncontract BusinessDayConventions {\\n\\n    /**\\n     * @notice Used in POFs and STFs for DCFs.\\n     * No shifting is applied if a Calc/Shift instead of Shift/Calc BDC is provided.\\n     */\\n    function shiftCalcTime(\\n        uint256 timestamp,\\n        BusinessDayConvention convention,\\n        Calendar calendar,\\n        uint256 maturityDate\\n    )\\n        public\\n        pure\\n        returns (uint256)\\n    {\\n        if (\\n            convention == BusinessDayConvention.CSF ||\\n            convention == BusinessDayConvention.CSMF ||\\n            convention == BusinessDayConvention.CSP ||\\n            convention == BusinessDayConvention.CSMP\\n        ) {\\n            return timestamp;\\n        }\\n\\n        return shiftEventTime(timestamp, convention, calendar, maturityDate);\\n    }\\n\\n    /*\\n     * @notice Used for generating event schedules (for single events and event cycles schedules).\\n     * This convention assumes that when shifting the events schedule time according\\n     * to a BDC, the time is shifted first and calculations are performed thereafter.\\n     * (Calculations in POFs and STFs are based on the shifted time as well)\\n     */\\n    function shiftEventTime(\\n        uint256 timestamp,\\n        BusinessDayConvention convention,\\n        Calendar calendar,\\n        uint256 maturityDate\\n    )\\n        public\\n        pure\\n        returns (uint256)\\n    {\\n        // do not shift if equal to maturity date\\n        if (timestamp == maturityDate) return timestamp;\\n\\n        // Shift/Calc Following, Calc/Shift following\\n        if (convention == BusinessDayConvention.SCF || convention == BusinessDayConvention.CSF) {\\n            return getClosestBusinessDaySameDayOrFollowing(timestamp, calendar);\\n        // Shift/Calc Modified Following, Calc/Shift Modified following\\n        // Same as unmodified if shifted date is in the same month, if not it returns the previous buiness-day\\n        } else if (convention == BusinessDayConvention.SCMF || convention == BusinessDayConvention.CSMF) {\\n            uint256 followingOrSameBusinessDay = getClosestBusinessDaySameDayOrFollowing(timestamp, calendar);\\n            if (BokkyPooBahsDateTimeLibrary.getMonth(followingOrSameBusinessDay) == BokkyPooBahsDateTimeLibrary.getMonth(timestamp)) {\\n                return followingOrSameBusinessDay;\\n            }\\n            return getClosestBusinessDaySameDayOrPreceeding(timestamp, calendar);\\n        // Shift/Calc Preceeding, Calc/Shift Preceeding\\n        } else if (convention == BusinessDayConvention.SCP || convention == BusinessDayConvention.CSP) {\\n            return getClosestBusinessDaySameDayOrPreceeding(timestamp, calendar);\\n        // Shift/Calc Modified Preceeding, Calc/Shift Modified Preceeding\\n        // Same as unmodified if shifted date is in the same month, if not it returns the following buiness-day\\n        } else if (convention == BusinessDayConvention.SCMP || convention == BusinessDayConvention.CSMP) {\\n            uint256 preceedingOrSameBusinessDay = getClosestBusinessDaySameDayOrPreceeding(timestamp, calendar);\\n            if (BokkyPooBahsDateTimeLibrary.getMonth(preceedingOrSameBusinessDay) == BokkyPooBahsDateTimeLibrary.getMonth(timestamp)) {\\n                return preceedingOrSameBusinessDay;\\n            }\\n            return getClosestBusinessDaySameDayOrFollowing(timestamp, calendar);\\n        }\\n\\n        return timestamp;\\n    }\\n\\n    /**\\n     * @notice Returns the following business day if a non-business day is provided.\\n     * (Returns the same day if calendar != MondayToFriday)\\n     */\\n    function getClosestBusinessDaySameDayOrFollowing(uint256 timestamp, Calendar calendar)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        if (calendar == Calendar.MF) {\\n            if (BokkyPooBahsDateTimeLibrary.getDayOfWeek(timestamp) == 6) {\\n                return BokkyPooBahsDateTimeLibrary.addDays(timestamp, 2);\\n            } else if (BokkyPooBahsDateTimeLibrary.getDayOfWeek(timestamp) == 7) {\\n                return BokkyPooBahsDateTimeLibrary.addDays(timestamp, 1);\\n            }\\n        }\\n        return timestamp;\\n    }\\n\\n    /**\\n     * @notice Returns the previous buiness day if a non-businessday is provided.\\n     * (Returns the same day if calendar != MondayToFriday)\\n     */\\n    function getClosestBusinessDaySameDayOrPreceeding(uint256 timestamp, Calendar calendar)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        if (calendar == Calendar.MF) {\\n            if (BokkyPooBahsDateTimeLibrary.getDayOfWeek(timestamp) == 6) {\\n                return BokkyPooBahsDateTimeLibrary.subDays(timestamp, 1);\\n            } else if (BokkyPooBahsDateTimeLibrary.getDayOfWeek(timestamp) == 7) {\\n                return BokkyPooBahsDateTimeLibrary.subDays(timestamp, 2);\\n            }\\n        }\\n        return timestamp;\\n    }\\n}\\n\",\"keccak256\":\"0x1406e47e0631852d7cab09816927778609dd56893df469ecc7a492bb8b45aa67\",\"license\":\"Apache-2.0\"},\"contracts/ACTUS/Core/Conventions/ContractRoleConventions.sol\":{\"content\":\"// \\\"SPDX-License-Identifier: Apache-2.0\\\"\\npragma solidity ^0.7.0;\\n\\nimport \\\"../ACTUSTypes.sol\\\";\\n\\n\\n/**\\n * @title ContractRoleConventions\\n */\\ncontract ContractRoleConventions {\\n\\n    /**\\n     * Returns the role sign for a given Contract Role.\\n     */\\n    function roleSign(ContractRole contractRole)\\n        internal\\n        pure\\n        returns (int8)\\n    {\\n        if (contractRole == ContractRole.RPA) return 1;\\n        if (contractRole == ContractRole.RPL) return -1;\\n\\n        if (contractRole == ContractRole.BUY) return 1;\\n        if (contractRole == ContractRole.SEL) return -1;\\n\\n        if (contractRole == ContractRole.RFL) return 1;\\n        if (contractRole == ContractRole.PFL) return -1;\\n\\n        revert(\\\"ContractRoleConvention.roleSign: ATTRIBUTE_NOT_FOUND\\\");\\n    }\\n}\\n\",\"keccak256\":\"0xf9a875b4c55500a23f8ac6bc854cb0f7bbc679f76127bf22e8a09410582641cc\",\"license\":\"Apache-2.0\"},\"contracts/ACTUS/Core/Conventions/DayCountConventions.sol\":{\"content\":\"// \\\"SPDX-License-Identifier: Apache-2.0\\\"\\npragma solidity ^0.7.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SignedSafeMath.sol\\\";\\nimport \\\"../../../external/BokkyPooBah/BokkyPooBahsDateTimeLibrary.sol\\\";\\n\\nimport \\\"../ACTUSTypes.sol\\\";\\nimport \\\"../ACTUSConstants.sol\\\";\\n\\nimport \\\"../SignedMath.sol\\\";\\n\\n\\n/**\\n * @title DayCountConventions\\n * @notice Implements various ISDA day count conventions as specified by ACTUS\\n */\\ncontract DayCountConventions is ACTUSConstants {\\n\\n    using SafeMath for uint;\\n    using SignedSafeMath for int;\\n    using SignedMath for int;\\n\\n    /**\\n     * Returns the fraction of the year between two timestamps.\\n     */\\n    function yearFraction(\\n        uint256 startTimestamp,\\n        uint256 endTimestamp,\\n        DayCountConvention ipdc,\\n        uint256 maturityDate\\n    )\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        require(endTimestamp >= startTimestamp, \\\"Core.yearFraction: START_NOT_BEFORE_END\\\");\\n        if (ipdc == DayCountConvention.AA) {\\n            return actualActual(startTimestamp, endTimestamp);\\n        } else if (ipdc == DayCountConvention.A360) {\\n            return actualThreeSixty(startTimestamp, endTimestamp);\\n        } else if (ipdc == DayCountConvention.A365) {\\n            return actualThreeSixtyFive(startTimestamp, endTimestamp);\\n        } else if (ipdc == DayCountConvention._30E360) {\\n            return thirtyEThreeSixty(startTimestamp, endTimestamp);\\n        } else if (ipdc == DayCountConvention._30E360ISDA) {\\n            return thirtyEThreeSixtyISDA(startTimestamp, endTimestamp, maturityDate);\\n        } else if (ipdc == DayCountConvention._28E336) {\\n            return twentyEightEThreeThirtySix(startTimestamp, endTimestamp, maturityDate);\\n        } else if (ipdc == DayCountConvention.ONE) {\\n            return one(startTimestamp, endTimestamp);\\n        } else if (ipdc == DayCountConvention.OBYT) {\\n            return oneByTwelve(startTimestamp, endTimestamp);\\n        } else if (ipdc == DayCountConvention.HRSAA) {\\n            return hoursActualActual(startTimestamp, endTimestamp);\\n        } else if (ipdc == DayCountConvention.MINAA) {\\n            return minutesActualActual(startTimestamp, endTimestamp);\\n        } else if (ipdc == DayCountConvention.SECAA) {\\n            return secondsActualActual(startTimestamp, endTimestamp);\\n        } else {\\n            revert(\\\"DayCountConvention.yearFraction: ATTRIBUTE_NOT_FOUND.\\\");\\n        }\\n    }\\n\\n    /**\\n     * ISDA A/A day count convention\\n     */\\n    function actualActual(uint256 startTime, uint256 endTime)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        uint256 d1Year = BokkyPooBahsDateTimeLibrary.getYear(startTime);\\n        uint256 d2Year = BokkyPooBahsDateTimeLibrary.getYear(endTime);\\n\\n        int256 firstBasis = (BokkyPooBahsDateTimeLibrary.isLeapYear(startTime)) ? 366 : 365;\\n\\n        if (d1Year == d2Year) {\\n            return int256(BokkyPooBahsDateTimeLibrary.diffDays(startTime, endTime)).floatDiv(firstBasis);\\n        }\\n\\n        int256 secondBasis = (BokkyPooBahsDateTimeLibrary.isLeapYear(endTime)) ? 366 : 365;\\n\\n        int256 firstFraction = int256(BokkyPooBahsDateTimeLibrary.diffDays(\\n            startTime,\\n            BokkyPooBahsDateTimeLibrary.timestampFromDate(d1Year.add(1), 1, 1)\\n        )).floatDiv(firstBasis);\\n        int256 secondFraction = int256(BokkyPooBahsDateTimeLibrary.diffDays(\\n            BokkyPooBahsDateTimeLibrary.timestampFromDate(d2Year, 1, 1),\\n            endTime\\n        )).floatDiv(secondBasis);\\n\\n        return firstFraction.add(secondFraction).add(int256(d2Year.sub(d1Year).sub(1)));\\n    }\\n\\n    /**\\n     * ISDA A/360 day count convention\\n     */\\n    function actualThreeSixty(uint256 startTime, uint256 endTime)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        return (int256((endTime.sub(startTime)).div(86400)).floatDiv(360));\\n    }\\n\\n    /**\\n     * ISDA A/365-Fixed day count convention\\n     */\\n    function actualThreeSixtyFive(uint256 startTime, uint256 endTime)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        return (int256((endTime.sub(startTime)).div(86400)).floatDiv(365));\\n    }\\n\\n    /**\\n     * ISDA 30E/360 day count convention\\n     */\\n    function thirtyEThreeSixty(uint256 startTime, uint256 endTime)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        uint256 d1Day;\\n        uint256 d1Month;\\n        uint256 d1Year;\\n\\n        uint256 d2Day;\\n        uint256 d2Month;\\n        uint256 d2Year;\\n\\n        (d1Year, d1Month, d1Day) = BokkyPooBahsDateTimeLibrary.timestampToDate(startTime);\\n        (d2Year, d2Month, d2Day) = BokkyPooBahsDateTimeLibrary.timestampToDate(endTime);\\n\\n        if (d1Day == 31) {\\n            d1Day = 30;\\n        }\\n\\n        if (d2Day == 31) {\\n            d2Day = 30;\\n        }\\n\\n        int256 delD = int256(d2Day).sub(int256(d1Day));\\n        int256 delM = int256(d2Month).sub(int256(d1Month));\\n        int256 delY = int256(d2Year).sub(int256(d1Year));\\n\\n        return ((delY.mul(360).add(delM.mul(30)).add(delD)).floatDiv(360));\\n    }\\n\\n    /**\\n     * ISDA 30E/360-ISDA day count convention\\n     */\\n    function thirtyEThreeSixtyISDA(uint256 startTime, uint256 endTime, uint256 maturityDate)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        uint256 d1Day;\\n        uint256 d1Month;\\n        uint256 d1Year;\\n\\n        uint256 d2Day;\\n        uint256 d2Month;\\n        uint256 d2Year;\\n\\n        (d1Year, d1Month, d1Day) = BokkyPooBahsDateTimeLibrary.timestampToDate(startTime);\\n        (d2Year, d2Month, d2Day) = BokkyPooBahsDateTimeLibrary.timestampToDate(endTime);\\n\\n        if (d1Day == BokkyPooBahsDateTimeLibrary.getDaysInMonth(startTime)) {\\n            d1Day = 30;\\n        }\\n\\n        if (!(endTime == maturityDate && d2Month == 2) && d2Day == BokkyPooBahsDateTimeLibrary.getDaysInMonth(endTime)) {\\n            d2Day = 30;\\n        }\\n\\n        int256 delD = int256(d2Day).sub(int256(d1Day));\\n        int256 delM = int256(d2Month).sub(int256(d1Month));\\n        int256 delY = int256(d2Year).sub(int256(d1Year));\\n\\n        return ((delY.mul(360).add(delM.mul(30)).add(delD)).floatDiv(360));\\n    }\\n\\n    /**\\n     * ISDA 28E/336 day count convention\\n     */\\n    function twentyEightEThreeThirtySix(uint256 startTime, uint256 endTime, uint256 maturityDate)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        (uint256 d1Year, uint256 d1Month, uint256 d1Day) = BokkyPooBahsDateTimeLibrary.timestampToDate(startTime);\\n        (uint256 d2Year, uint256 d2Month, uint256 d2Day) = BokkyPooBahsDateTimeLibrary.timestampToDate(endTime);\\n\\n        if (d1Day == BokkyPooBahsDateTimeLibrary.getDaysInMonth(startTime)) {\\n            d1Day = 28;\\n        }\\n\\n        // if (!(endTime == maturityDate && d2Month == 2) && d2Day == BokkyPooBahsDateTimeLibrary.getDaysInMonth(endTime)) {\\n        if (!(endTime == maturityDate && d2Month == 2) && (d2Day == BokkyPooBahsDateTimeLibrary.getDaysInMonth(startTime) || d2Day > 28)) {\\n            d2Day = 28;\\n        }\\n\\n        int256 delD = int256(d2Day).sub(int256(d1Day));\\n        int256 delM = int256(d2Month).sub(int256(d1Month));\\n        int256 delY = int256(d2Year).sub(int256(d1Year));\\n\\n        return ((delY.mul(336).add(delM.mul(28)).add(delD)).floatDiv(336));\\n    }\\n\\n    /**\\n     * One\\n     */\\n    function one(uint256 startTime, uint256 endTime)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        return ONE_POINT_ZERO;\\n    }\\n\\n    /**\\n     * One By Twelve\\n     */\\n    function oneByTwelve(uint256 startTime, uint256 endTime)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        return int256(ONE_POINT_ZERO).floatDiv(12 * ONE_POINT_ZERO);\\n    }\\n\\n    /**\\n     * Hours/Actual/Actual\\n     */\\n    function hoursActualActual(uint256 startTime, uint256 endTime)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        uint256 d1Year = BokkyPooBahsDateTimeLibrary.getYear(startTime);\\n        uint256 d2Year = BokkyPooBahsDateTimeLibrary.getYear(endTime);\\n\\n        // no risk of overflow\\n        // 366 * 24, 365 * 24\\n        int256 firstBasis = (BokkyPooBahsDateTimeLibrary.isLeapYear(startTime)) ? 8784 : 8760;\\n\\n        if (d1Year == d2Year) {\\n            return int256(BokkyPooBahsDateTimeLibrary.diffHours(startTime, endTime)).floatDiv(firstBasis);\\n        }\\n\\n        // no risk of overflow\\n        // 366 * 24, 365 * 24\\n        int256 secondBasis = (BokkyPooBahsDateTimeLibrary.isLeapYear(endTime)) ? 8784 : 8760;\\n\\n        int256 firstFraction = int256(BokkyPooBahsDateTimeLibrary.diffHours(\\n            startTime,\\n            BokkyPooBahsDateTimeLibrary.timestampFromDate(d1Year.add(1), 1, 1)\\n        )).floatDiv(firstBasis);\\n        int256 secondFraction = int256(BokkyPooBahsDateTimeLibrary.diffHours(\\n            BokkyPooBahsDateTimeLibrary.timestampFromDate(d2Year, 1, 1),\\n            endTime\\n        )).floatDiv(secondBasis);\\n\\n        return firstFraction.add(secondFraction).add(int256(d2Year.sub(d1Year).sub(1)));\\n    }\\n\\n    /**\\n     * Minutes/Actual/Actual\\n     */\\n    function minutesActualActual(uint256 startTime, uint256 endTime)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        uint256 d1Year = BokkyPooBahsDateTimeLibrary.getYear(startTime);\\n        uint256 d2Year = BokkyPooBahsDateTimeLibrary.getYear(endTime);\\n\\n        // no risk of overflow\\n        // 366 * 1440, 365 * 1440\\n        int256 firstBasis = (BokkyPooBahsDateTimeLibrary.isLeapYear(startTime)) ? 527040 : 525600;\\n\\n        if (d1Year == d2Year) {\\n            return int256(BokkyPooBahsDateTimeLibrary.diffMinutes(startTime, endTime)).floatDiv(firstBasis);\\n        }\\n\\n        // no risk of overflow\\n        // 366 * 1440, 365 * 1440\\n        int256 secondBasis = (BokkyPooBahsDateTimeLibrary.isLeapYear(endTime)) ? 527040 : 525600;\\n\\n        int256 firstFraction = int256(BokkyPooBahsDateTimeLibrary.diffMinutes(\\n            startTime,\\n            BokkyPooBahsDateTimeLibrary.timestampFromDate(d1Year.add(1), 1, 1)\\n        )).floatDiv(firstBasis);\\n        int256 secondFraction = int256(BokkyPooBahsDateTimeLibrary.diffMinutes(\\n            BokkyPooBahsDateTimeLibrary.timestampFromDate(d2Year, 1, 1),\\n            endTime\\n        )).floatDiv(secondBasis);\\n\\n        return firstFraction.add(secondFraction).add(int256(d2Year.sub(d1Year).sub(1)));\\n    }\\n\\n    /**\\n     * Seconds/Actual/Actual\\n     */\\n    function secondsActualActual(uint256 startTime, uint256 endTime)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        uint256 d1Year = BokkyPooBahsDateTimeLibrary.getYear(startTime);\\n        uint256 d2Year = BokkyPooBahsDateTimeLibrary.getYear(endTime);\\n\\n        // no risk of overflow\\n        // 366 * 86400, 365 * 86400\\n        int256 firstBasis = (BokkyPooBahsDateTimeLibrary.isLeapYear(startTime)) ? 31622400 : 31536000;\\n\\n        if (d1Year == d2Year) {\\n            return int256(BokkyPooBahsDateTimeLibrary.diffSeconds(startTime, endTime)).floatDiv(firstBasis);\\n        }\\n\\n        // no risk of overflow\\n        // 366 * 86400, 365 * 86400\\n        int256 secondBasis = (BokkyPooBahsDateTimeLibrary.isLeapYear(endTime)) ? 31622400 : 31536000;\\n\\n        int256 firstFraction = int256(BokkyPooBahsDateTimeLibrary.diffSeconds(\\n            startTime,\\n            BokkyPooBahsDateTimeLibrary.timestampFromDate(d1Year.add(1), 1, 1)\\n        )).floatDiv(firstBasis);\\n        int256 secondFraction = int256(BokkyPooBahsDateTimeLibrary.diffSeconds(\\n            BokkyPooBahsDateTimeLibrary.timestampFromDate(d2Year, 1, 1),\\n            endTime\\n        )).floatDiv(secondBasis);\\n\\n        return firstFraction.add(secondFraction).add(int256(d2Year.sub(d1Year).sub(1)));\\n    }\\n}\\n\",\"keccak256\":\"0x4fcc109bba8539931926e96cff0a341c755bfff481015cec227a38f9493d0210\",\"license\":\"Apache-2.0\"},\"contracts/ACTUS/Core/Conventions/EndOfMonthConventions.sol\":{\"content\":\"// \\\"SPDX-License-Identifier: Apache-2.0\\\"\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../../external/BokkyPooBah/BokkyPooBahsDateTimeLibrary.sol\\\";\\n\\nimport \\\"../ACTUSTypes.sol\\\";\\n\\n\\n/**\\n * @title EndOfMonthConventions\\n * @notice Implements the ACTUS end of month convention.\\n */\\ncontract EndOfMonthConventions {\\n\\n    /**\\n     * This function makes an adjustment on the end of month convention.\\n     * @dev The following is considered to dertermine if schedule dates are shifted to the end of month:\\n     * - The convention SD (same day) means not adjusting, EM (end of month) means adjusting\\n     * - Dates are only shifted if the schedule start date is an end-of-month date\\n     * - Dates are only shifted if the schedule cycle is based on an \\\"M\\\" period unit or multiple thereof\\n     * @param eomc the end of month convention to adjust\\n     * @param startTime timestamp of the cycle start\\n     * @param cycle the cycle struct\\n     * @return the adjusted end of month convention\\n     */\\n    function adjustEndOfMonthConvention(\\n        EndOfMonthConvention eomc,\\n        uint256 startTime,\\n        IPS memory cycle\\n    )\\n        public\\n        pure\\n        returns (EndOfMonthConvention)\\n    {\\n        if (eomc == EndOfMonthConvention.EOM) {\\n            // check if startTime is last day in month and schedule has month based period\\n            // otherwise switch to SD convention\\n            if (\\n                BokkyPooBahsDateTimeLibrary.getDay(startTime) == BokkyPooBahsDateTimeLibrary.getDaysInMonth(startTime) &&\\n                (cycle.p == P.M || cycle.p == P.Q || cycle.p == P.H)\\n            ) {\\n                return EndOfMonthConvention.EOM;\\n            }\\n            return EndOfMonthConvention.SD;\\n        } else if (eomc == EndOfMonthConvention.SD) {\\n            return EndOfMonthConvention.SD;\\n        }\\n        revert(\\\"EndOfMonthConvention.adjustEndOfMonthConvention: ATTRIBUTE_NOT_FOUND.\\\");\\n    }\\n\\n    /**\\n\\t * This function is for the EndOfMonthConvention.EOM convention and\\n\\t * shifts a timestamp to the last day of the month.\\n\\t * @param timestamp the timestmap to shift\\n\\t * @return the shifted timestamp\\n\\t */\\n\\tfunction shiftEndOfMonth(uint256 timestamp)\\n\\t  internal\\n\\t  pure\\n\\t  returns (uint256)\\n\\t{\\n        // // check if startTime is last day in month and schedule has month based period\\n        // // otherwise switch to SD convention\\n        // if (\\n        //     eomc != EndOfMonthConvention.EOM\\n        //     || BokkyPooBahsDateTimeLibrary.getDay(startTime) != BokkyPooBahsDateTimeLibrary.getDaysInMonth(startTime)\\n        //     || (cycle.p == P.M || cycle.p == P.Q || cycle.p == P.H)\\n        // ) {\\n        //     // SD\\n        //     return timestamp;\\n        // }\\n\\n\\t\\tuint256 year;\\n\\t\\tuint256 month;\\n\\t\\tuint256 day;\\n\\t\\t(year, month, day) = BokkyPooBahsDateTimeLibrary.timestampToDate(timestamp);\\n\\t\\tuint256 lastDayOfMonth = BokkyPooBahsDateTimeLibrary._getDaysInMonth(year, month);\\n\\n\\t\\treturn BokkyPooBahsDateTimeLibrary.timestampFromDate(year, month, lastDayOfMonth);\\n\\t}\\n}\\n\",\"keccak256\":\"0xdf4d28ba01767a6e737bdcf2e8e9e08143f9cd08a6d62ed90780031c4811876f\",\"license\":\"Apache-2.0\"},\"contracts/ACTUS/Core/Core.sol\":{\"content\":\"// \\\"SPDX-License-Identifier: Apache-2.0\\\"\\r\\npragma solidity ^0.7.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"./ACTUSTypes.sol\\\";\\r\\nimport \\\"./ACTUSConstants.sol\\\";\\r\\nimport \\\"./Utils/Utils.sol\\\";\\r\\nimport \\\"./Conventions/BusinessDayConventions.sol\\\";\\r\\nimport \\\"./Conventions/ContractRoleConventions.sol\\\";\\r\\nimport \\\"./Conventions/DayCountConventions.sol\\\";\\r\\nimport \\\"./Conventions/EndOfMonthConventions.sol\\\";\\r\\n\\r\\n\\r\\n/**\\r\\n * @title Core\\r\\n * @notice Contains all type definitions, conventions as specified by the ACTUS Standard\\r\\n * and utility methods for generating event schedules\\r\\n */\\r\\ncontract Core is\\r\\n    ACTUSConstants,\\r\\n    ContractRoleConventions,\\r\\n    DayCountConventions,\\r\\n    EndOfMonthConventions,\\r\\n    Utils\\r\\n{}\\r\\n\",\"keccak256\":\"0x4f0be10497e1c0e5facce3686a8454bed5989ce9cc440e8438057f07ff5c04f8\",\"license\":\"Apache-2.0\"},\"contracts/ACTUS/Core/SignedMath.sol\":{\"content\":\"// \\\"SPDX-License-Identifier: Apache-2.0\\\"\\npragma solidity ^0.7.0;\\n\\n\\n/**\\n * Advanced math library for signed integers\\n * (including floats which are represented as multiples of 10 ** 18)\\n */\\nlibrary SignedMath {\\n\\n    int256 constant private INT256_MIN = -2 ** 255;\\n\\n    uint256 constant public PRECISION = 18;\\n    uint256 constant public MULTIPLICATOR = 10 ** PRECISION;\\n\\n\\n    /**\\n     * @dev The product of a and b has to be less than INT256_MAX (~10 ** 76),\\n     * as devision (normalization) is performed after multiplication\\n     * Upper boundary would be (10 ** 58) * (MULTIPLICATOR) == ~10 ** 76\\n     */\\n    function floatMult(int256 a, int256 b)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        if (a == 0 || b == 0) return 0;\\n\\n        require(!(a == -1 && b == INT256_MIN), \\\"SignedMath.floatMult: OVERFLOW_DETECTED\\\");\\n        int256 c = a * b;\\n        require(c / a == b, \\\"SignedMath.floatMult: OVERFLOW_DETECTED\\\");\\n\\n        // normalize (divide by MULTIPLICATOR)\\n        int256 d = c / int256(MULTIPLICATOR);\\n        require(d != 0, \\\"SignedMath.floatMult: CANNOT_REPRESENT_GRANULARITY\\\");\\n\\n        return d;\\n    }\\n\\n    function floatDiv(int256 a, int256 b)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        require(b != 0, \\\"SignedMath.floatDiv: DIVIDED_BY_ZERO\\\");\\n\\n        // normalize (multiply by MULTIPLICATOR)\\n        if (a == 0) return 0;\\n        int256 c = a * int256(MULTIPLICATOR);\\n        require(c / a == int256(MULTIPLICATOR), \\\"SignedMath.floatDiv: OVERFLOW_DETECTED\\\");\\n\\n        require(!(b == -1 && a == INT256_MIN), \\\"SignedMath.floatDiv: OVERFLOW_DETECTED\\\");\\n        int256 d = c / b;\\n        require(d != 0, \\\"SignedMath.floatDiv: CANNOT_REPRESENT_GRANULARITY\\\");\\n\\n        return d;\\n    }\\n\\n    /**\\n        * @dev Returns the smallest of two signed numbers.\\n        */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n            return a <= b ? a : b;\\n    }\\n\\n    /**\\n        * @dev Returns the largest of two signed numbers.\\n        */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n            return a >= b ? a : b;\\n    }\\n}\\n\",\"keccak256\":\"0x884bb3aec6597cb12c2ce3417ec60a1ffc82970342eefde5b195fad728efa233\",\"license\":\"Apache-2.0\"},\"contracts/ACTUS/Core/Utils/CycleUtils.sol\":{\"content\":\"// \\\"SPDX-License-Identifier: Apache-2.0\\\"\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport {SafeMath as SafeMul} from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../../../external/BokkyPooBah/BokkyPooBahsDateTimeLibrary.sol\\\";\\n\\nimport \\\"../ACTUSTypes.sol\\\";\\nimport \\\"../ACTUSConstants.sol\\\";\\nimport \\\"../Conventions/EndOfMonthConventions.sol\\\";\\nimport \\\"./PeriodUtils.sol\\\";\\n\\n\\n/**\\n * @title Schedule\\n * @notice Methods related to generating event schedules.\\n */\\ncontract CycleUtils is ACTUSConstants, EndOfMonthConventions, PeriodUtils {\\n\\n    using BokkyPooBahsDateTimeLibrary for uint;\\n    using SafeMul for uint;\\n\\n    /**\\n     * @notice Applies the cycle n - times (n := cycleIndex) to a given date\\n     */\\n    function getNextCycleDate(IPS memory cycle, uint256 cycleStart, uint256 cycleIndex)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 newTimestamp;\\n\\n        if (cycle.p == P.D) {\\n            newTimestamp = cycleStart.addDays(cycle.i.mul(cycleIndex));\\n        } else if (cycle.p == P.W) {\\n            newTimestamp = cycleStart.addDays(cycle.i.mul(7).mul(cycleIndex));\\n        } else if (cycle.p == P.M) {\\n            newTimestamp = cycleStart.addMonths(cycle.i.mul(cycleIndex));\\n        } else if (cycle.p == P.Q) {\\n            newTimestamp = cycleStart.addMonths(cycle.i.mul(3).mul(cycleIndex));\\n        } else if (cycle.p == P.H) {\\n            newTimestamp = cycleStart.addMonths(cycle.i.mul(6).mul(cycleIndex));\\n        } else if (cycle.p == P.Y) {\\n            newTimestamp = cycleStart.addYears(cycle.i.mul(cycleIndex));\\n        } else {\\n            revert(\\\"CycleUtils.getNextCycleDate: ATTRIBUTE_NOT_FOUND\\\");\\n        }\\n\\n        return newTimestamp;\\n    }\\n\\n    /**\\n     * Computes an array of timestamps that represent dates in a cycle falling within a given segment.\\n     * @dev There are some notable edge cases: If the cycle is \\\"not set\\\" we return the start end end dates\\n     * of the cycle if they lie within the segment. Otherwise and empty array is returned.\\n     * @param cycleStart start time of the cycle\\n     * @param cycleEnd end time of the cycle\\n     * @param cycle IPS cycle\\n     * @param eomc end of month convention\\n     * @param addEndDate end date of the cycle should be added to the result if it falls in the segment\\n     * @param segmentStart start time of the segment\\n     * @param segmentEnd end time of the segment\\n     * @return an array of timestamps from the given cycle that fall within the specified segement\\n     */\\n    function computeDatesFromCycleSegment(\\n        uint256 cycleStart,\\n        uint256 cycleEnd,\\n        IPS memory cycle,\\n        EndOfMonthConvention eomc,\\n        bool addEndDate,\\n        uint256 segmentStart,\\n        uint256 segmentEnd\\n    )\\n        internal\\n        pure\\n        returns (uint256[MAX_CYCLE_SIZE] memory)\\n    {\\n        uint256[MAX_CYCLE_SIZE] memory dates;\\n        uint256 index;\\n\\n        // if the cycle is not set we return only the cycle start end end dates under these conditions:\\n        // we return the cycle start, if it's in the segment\\n        // in case of addEntTime = true, the cycle end is also returned if in the segment\\n        if (cycle.isSet == false) {\\n            if (isInSegment(cycleStart, segmentStart, segmentEnd)) {\\n                dates[index] = cycleStart;\\n                index++;\\n            }\\n            if (isInSegment(cycleEnd, segmentStart, segmentEnd)) {\\n                if (addEndDate == true) dates[index] = cycleEnd;\\n            }\\n            return dates;\\n        }\\n\\n        uint256 date = cycleStart;\\n        uint256 cycleIndex;\\n\\n        EndOfMonthConvention actualEOMC = adjustEndOfMonthConvention(eomc, cycleStart, cycle);\\n\\n        // walk through the cycle and create the cycle dates to be returned\\n        while (date < cycleEnd) {\\n            // if date is in segment and MAX_CYCLE_SIZE is not reached add it to the output array\\n            if (isInSegment(date, segmentStart, segmentEnd)) {\\n                require(index < (MAX_CYCLE_SIZE - 2), \\\"CycleUtils.computeDatesFromCycle: MAX_CYCLE_SIZE\\\");\\n                dates[index] = date;\\n                index++;\\n            }\\n\\n            cycleIndex++;\\n\\n            date = (actualEOMC == EndOfMonthConvention.EOM)\\n                ? shiftEndOfMonth(getNextCycleDate(cycle, cycleStart, cycleIndex))\\n                : getNextCycleDate(cycle, cycleStart, cycleIndex);\\n        }\\n\\n        // add additional time at the end if addEndDate\\n        if (addEndDate == true) {\\n            if (isInSegment(cycleEnd, segmentStart, segmentEnd)) {\\n                dates[index] = cycleEnd;\\n            }\\n        }\\n\\n        // handle a special case where S is set to LONG (e.g. for trimming a cycle to the maturity date)\\n        if (index > 0 && isInSegment(dates[index - 1], segmentStart, segmentEnd)) {\\n            if (cycle.s == S.LONG && index > 1 && cycleEnd != date) {\\n                dates[index - 1] = dates[index];\\n                delete dates[index];\\n            }\\n        }\\n\\n        return dates;\\n    }\\n\\n    /**\\n     * Computes the next date for a given an IPS cycle.\\n     * @param cycle IPS cycle\\n     * @param eomc end of month convention\\n     * @param anchorDate anchor date of the cycle\\n     * @param precedingDate the previous date of the cycle\\n     * @param addEndDate end date of the cycle should be added to the result if it falls in the segment\\n     * @param cycleEnd end date of the cyclic schedule\\n     * @return next date of the cycle\\n     */\\n    function computeNextCycleDateFromPrecedingDate(\\n        IPS memory cycle,\\n        EndOfMonthConvention eomc,\\n        uint256 anchorDate,\\n        uint256 precedingDate,\\n        bool addEndDate,\\n        uint256 cycleEnd\\n    )\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        if (cycle.isSet == false || precedingDate == 0) return anchorDate;\\n\\n        uint256 nextCyclicDate = (adjustEndOfMonthConvention(eomc, anchorDate, cycle) == EndOfMonthConvention.EOM)\\n            ? shiftEndOfMonth(getNextCycleDate(cycle, precedingDate, 1))\\n            : getNextCycleDate(cycle, precedingDate, 1);\\n\\n        if (addEndDate && cycleEnd != 0) {\\n            // handle infinite loop (since preceding date is cycleEnd)\\n            if (precedingDate == cycleEnd) return 0;\\n            // add occurence at cycle end if date is greater than cycle end\\n            if (nextCyclicDate > cycleEnd) return cycleEnd;\\n        }\\n        // remove occurence if it is one cycle end\\n        if (addEndDate == false && cycleEnd != 0 && nextCyclicDate == cycleEnd) return 0;\\n\\n        return nextCyclicDate;\\n    }\\n\\n    /*\\n     * @notice Checks if a timestamp is in a given range.\\n     */\\n    function isInSegment(\\n        uint256 timestamp,\\n        uint256 startTimestamp,\\n        uint256 endTimestamp\\n    )\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        if (startTimestamp > endTimestamp) return false;\\n        if (startTimestamp <= timestamp && timestamp <= endTimestamp) return true;\\n        return false;\\n    }\\n}\\n\",\"keccak256\":\"0x93c64a514dea64d4f854183d2b60061eca88f3d828804cfee63ac9999bb449dc\",\"license\":\"Apache-2.0\"},\"contracts/ACTUS/Core/Utils/EventUtils.sol\":{\"content\":\"// \\\"SPDX-License-Identifier: Apache-2.0\\\"\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../ACTUSTypes.sol\\\";\\n\\n/**\\n * @title EventUtils\\n * @notice Methods for encoding decoding events\\n */\\ncontract EventUtils {\\n\\n    function encodeEvent(EventType eventType, uint256 scheduleTime)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        return (\\n            bytes32(uint256(uint8(eventType))) << 248 |\\n            bytes32(scheduleTime)\\n        );\\n    }\\n\\n    function decodeEvent(bytes32 _event)\\n        public\\n        pure\\n        returns (EventType, uint256)\\n    {\\n        EventType eventType = EventType(uint8(uint256(_event >> 248)));\\n        uint256 scheduleTime = uint256(uint64(uint256(_event)));\\n\\n        return (eventType, scheduleTime);\\n    }\\n\\n    /**\\n     * @notice Returns the epoch offset for a given event type to determine the\\n     * correct order of events if multiple events have the same timestamp\\n     */\\n    function getEpochOffset(EventType eventType)\\n        public\\n        pure\\n        returns (uint256)\\n    {\\n        return uint256(eventType);\\n    }\\n}\\n\",\"keccak256\":\"0x0b57772142cc74943c55eea2bd2c8d2fd035bead19592b75cd4f7ad3159f96ee\",\"license\":\"Apache-2.0\"},\"contracts/ACTUS/Core/Utils/PeriodUtils.sol\":{\"content\":\"// \\\"SPDX-License-Identifier: Apache-2.0\\\"\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport {SafeMath as SafeMul} from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../../../external/BokkyPooBah/BokkyPooBahsDateTimeLibrary.sol\\\";\\n\\nimport \\\"../ACTUSTypes.sol\\\";\\n\\n/**\\n * @title PeriodUtils\\n * @notice Utility methods for dealing with Periods\\n */\\ncontract PeriodUtils {\\n\\n    using BokkyPooBahsDateTimeLibrary for uint;\\n    using SafeMul for uint;\\n\\n    /**\\n     * @notice Applies a period in IP notation to a given timestamp\\n     */\\n    function getTimestampPlusPeriod(IP memory period, uint256 timestamp)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 newTimestamp;\\n\\n        if (period.p == P.D) {\\n            newTimestamp = timestamp.addDays(period.i);\\n        } else if (period.p == P.W) {\\n            newTimestamp = timestamp.addDays(period.i.mul(7));\\n        } else if (period.p == P.M) {\\n            newTimestamp = timestamp.addMonths(period.i);\\n        } else if (period.p == P.Q) {\\n            newTimestamp = timestamp.addMonths(period.i.mul(3));\\n        } else if (period.p == P.H) {\\n            newTimestamp = timestamp.addMonths(period.i.mul(6));\\n        } else if (period.p == P.Y) {\\n            newTimestamp = timestamp.addYears(period.i);\\n        } else {\\n            revert(\\\"PeriodUtils.getTimestampPlusPeriod: ATTRIBUTE_NOT_FOUND\\\");\\n        }\\n\\n        return newTimestamp;\\n    }\\n}\\n\",\"keccak256\":\"0x7ba86e98c89c11d4b16bb7cf81339679e01c7a73d099a980e71335bb890e82d9\",\"license\":\"Apache-2.0\"},\"contracts/ACTUS/Core/Utils/Utils.sol\":{\"content\":\"// \\\"SPDX-License-Identifier: Apache-2.0\\\"\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../ACTUSTypes.sol\\\";\\nimport \\\"../Conventions/BusinessDayConventions.sol\\\";\\n\\nimport \\\"./EventUtils.sol\\\";\\nimport \\\"./PeriodUtils.sol\\\";\\nimport \\\"./CycleUtils.sol\\\";\\n\\n\\n/**\\n * @title Utils\\n * @notice Utility methods used throughout Core and all Engines\\n */\\ncontract Utils is BusinessDayConventions, EventUtils, PeriodUtils, CycleUtils {\\n\\n    /**\\n     * @notice Returns the event time for a given schedule time\\n     * @dev For optimization reasons not located in EventUtil\\n     * by applying the BDC specified in the terms\\n     */\\n    function computeEventTimeForEvent(bytes32 _event, BusinessDayConvention bdc, Calendar calendar, uint256 maturityDate)\\n        public\\n        pure\\n        returns (uint256)\\n    {\\n        (, uint256 scheduleTime) = decodeEvent(_event);\\n\\n        // handle maturity date\\n        return shiftEventTime(scheduleTime, bdc, calendar, maturityDate);\\n    }\\n}\\n\",\"keccak256\":\"0x0ab55d9aea5c5ba13eb25b08ec98afa1f48693644022c58b0f212dddcbc8a2a4\",\"license\":\"Apache-2.0\"},\"contracts/ACTUS/Engines/IEngine.sol\":{\"content\":\"// \\\"SPDX-License-Identifier: Apache-2.0\\\"\\npragma solidity ^0.7.0;\\n\\nimport \\\"../Core/ACTUSTypes.sol\\\";\\n\\n\\ninterface IEngine {\\n    function contractType() external pure returns (ContractType);\\n}\",\"keccak256\":\"0xe2ecdc18616473e64d932c47ccf8408e5a35c100fa24e3157ad9f530556135bb\",\"license\":\"Apache-2.0\"},\"contracts/ACTUS/Engines/PAM/IPAMEngine.sol\":{\"content\":\"// \\\"SPDX-License-Identifier: Apache-2.0\\\"\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../Core/ACTUSTypes.sol\\\";\\nimport \\\"../IEngine.sol\\\";\\n\\n\\n/**\\n * @title IEngine\\n * @notice Interface which all Engines have to implement\\n */\\ninterface IPAMEngine is IEngine {\\n\\n    /**\\n     * @notice Initialize contract state space based on the contract terms.\\n     * @param terms terms of the contract\\n     * @return initial state of the contract\\n     */\\n    function computeInitialState(PAMTerms calldata terms)\\n        external\\n        pure\\n        returns (PAMState memory);\\n\\n    /**\\n     * Applys an event to the current state of a contract and returns the resulting contract state.\\n     * @param terms terms of the contract\\n     * @param state current state of the contract\\n     * @param _event event to be applied to the contract state\\n     * @param externalData external data needed for STF evaluation (e.g. rate for RR events)\\n     * @return the resulting contract state\\n     */\\n    function computeStateForEvent(\\n        PAMTerms calldata terms,\\n        PAMState calldata state,\\n        bytes32 _event,\\n        bytes calldata externalData\\n    )\\n        external\\n        pure\\n        returns (PAMState memory);\\n\\n    /**\\n     * Evaluates the payoff for an event under the current state of the contract.\\n     * @param terms terms of the contract\\n     * @param state current state of the contract\\n     * @param _event event for which the payoff should be evaluated\\n     * @param externalData external data needed for POF evaluation (e.g. fxRate)\\n     * @return the payoff of the event\\n     */\\n    function computePayoffForEvent(\\n        PAMTerms calldata terms,\\n        PAMState calldata state,\\n        bytes32 _event,\\n        bytes calldata externalData\\n    )\\n        external\\n        pure\\n        returns (int256);\\n\\n    /**\\n     * @notice Computes a schedule segment of non-cyclic contract events based on the contract terms\\n     * and the specified timestamps.\\n     * @param terms terms of the contract\\n     * @param segmentStart start timestamp of the segment\\n     * @param segmentEnd end timestamp of the segement\\n     * @return segment of the non-cyclic schedule\\n     */\\n    function computeNonCyclicScheduleSegment(\\n        PAMTerms calldata terms,\\n        uint256 segmentStart,\\n        uint256 segmentEnd\\n    )\\n        external\\n        pure\\n        returns (bytes32[] memory);\\n\\n    /**\\n     * @notice Computes the next non-cyclic contract events based on the contract terms\\n     * and the timestamp on which the prev. event occured.\\n     * @dev Assumes that non-cyclic events of the same event type have a unique schedule time\\n     * @param terms terms of the contract\\n     * @param lastNonCyclicEvent last non-cyclic event\\n     * @return next non-cyclic event\\n     */\\n    function computeNextNonCyclicEvent(\\n        PAMTerms calldata terms,\\n        bytes32 lastNonCyclicEvent\\n    )\\n        external\\n        pure\\n        returns (bytes32);\\n\\n    /**\\n     * @notice Computes a schedule segment of cyclic contract events based on the contract terms\\n     * and the specified timestamps.\\n     * @param terms terms of the contract\\n     * @param lastScheduleTime last occurrence of cyclic event\\n     * @param eventType eventType of the cyclic schedule\\n     * @return event schedule segment\\n     */\\n    function computeNextCyclicEvent(\\n        PAMTerms calldata terms,\\n        uint256 lastScheduleTime,\\n        EventType eventType\\n    )\\n        external\\n        pure\\n        returns(bytes32);\\n\\n    /**\\n     * @notice Computes a schedule segment of cyclic contract events based on the contract terms\\n     * and the specified timestamps.\\n     * @param terms terms of the contract\\n     * @param segmentStart start timestamp of the segment\\n     * @param segmentEnd end timestamp of the segement\\n     * @param eventType eventType of the cyclic schedule\\n     * @return event schedule segment\\n     */\\n    function computeCyclicScheduleSegment(\\n        PAMTerms calldata terms,\\n        uint256 segmentStart,\\n        uint256 segmentEnd,\\n        EventType eventType\\n    )\\n        external\\n        pure\\n        returns (bytes32[] memory);\\n\\n    /**\\n     * @notice Verifies that the provided event is still scheduled under the terms, the current state of the\\n     * contract and the current state of the underlying.\\n     * @param _event event for which to check if its still scheduled\\n     * @param terms terms of the contract\\n     * @param state current state of the contract\\n     * @param underlyingState state of the underlying (empty state object if non-existing)\\n     * @return boolean indicating whether event is still scheduled\\n     */\\n    function isEventScheduled(\\n        bytes32 _event,\\n        PAMTerms calldata terms,\\n        PAMState calldata state,\\n        UnderlyingState calldata underlyingState\\n    )\\n        external\\n        pure\\n        returns (bool);\\n}\\n\",\"keccak256\":\"0xbd4f187db92cc9ae062f0a17489212f37b56d9f63320427c7bcbb21fea27fd52\",\"license\":\"Apache-2.0\"},\"contracts/ACTUS/Engines/PAM/PAMEngine.sol\":{\"content\":\"// \\\"SPDX-License-Identifier: Apache-2.0\\\"\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/SignedSafeMath.sol\\\";\\n\\nimport \\\"../../Core/Core.sol\\\";\\nimport \\\"../../Core/SignedMath.sol\\\";\\nimport \\\"./IPAMEngine.sol\\\";\\nimport \\\"./PAMSTF.sol\\\";\\nimport \\\"./PAMPOF.sol\\\";\\n\\n\\n/**\\n * @title PAMEngine\\n * @notice Inherits from BaseEngine by implementing STFs, POFs according to the ACTUS standard for a PAM contract\\n * @dev All numbers except unix timestamp are represented as multiple of 10 ** 18\\n */\\ncontract PAMEngine is Core, PAMSTF, PAMPOF, IPAMEngine {\\n\\n    using SignedSafeMath for int;\\n    using SignedMath for int;\\n\\n\\n    function contractType() external pure override returns (ContractType) {\\n        return ContractType.PAM;\\n    }\\n\\n    /**\\n     * Applys an event to the current state of a contract and returns the resulting contract state.\\n     * @param terms terms of the contract\\n     * @param state current state of the contract\\n     * @param _event event to be applied to the contract state\\n     * @param externalData external data needed for STF evaluation (e.g. rate for RR events)\\n     * @return the resulting contract state\\n     */\\n    function computeStateForEvent(\\n        PAMTerms calldata terms,\\n        PAMState calldata state,\\n        bytes32 _event,\\n        bytes calldata externalData\\n    )\\n        external\\n        pure\\n        override\\n        returns (PAMState memory)\\n    {\\n        return stateTransitionFunction(\\n            terms,\\n            state,\\n            _event,\\n            externalData\\n        );\\n    }\\n\\n    /**\\n     * Evaluates the payoff for an event under the current state of the contract.\\n     * @param terms terms of the contract\\n     * @param state current state of the contract\\n     * @param _event event for which the payoff should be evaluated\\n     * @param externalData external data needed for POF evaluation (e.g. fxRate)\\n     * @return the payoff of the event\\n     */\\n    function computePayoffForEvent(\\n        PAMTerms calldata terms,\\n        PAMState calldata state,\\n        bytes32 _event,\\n        bytes calldata externalData\\n    )\\n        external\\n        pure\\n        override\\n        returns (int256)\\n    {\\n        // if alternative settlementCurrency is set then apply fxRate to payoff\\n        if (terms.settlementCurrency != address(0) && terms.currency != terms.settlementCurrency) {\\n            return payoffFunction(\\n                terms,\\n                state,\\n                _event,\\n                externalData\\n            ).floatMult(abi.decode(externalData, (int256)));\\n        }\\n\\n        return payoffFunction(\\n            terms,\\n            state,\\n            _event,\\n            externalData\\n        );\\n    }\\n\\n    /**\\n     * @notice Initialize contract state space based on the contract terms.\\n     * @param terms terms of the contract\\n     * @return the initial state of the contract\\n     */\\n    function computeInitialState(PAMTerms calldata terms)\\n        external\\n        pure\\n        override\\n        returns (PAMState memory)\\n    {\\n        PAMState memory state;\\n\\n        state.contractPerformance = ContractPerformance.PF;\\n        state.notionalScalingMultiplier = ONE_POINT_ZERO;\\n        state.interestScalingMultiplier = ONE_POINT_ZERO;\\n        state.statusDate = terms.statusDate;\\n        state.maturityDate = terms.maturityDate;\\n        state.notionalPrincipal = terms.notionalPrincipal;\\n        state.nominalInterestRate = terms.nominalInterestRate;\\n        state.accruedInterest = terms.accruedInterest;\\n        state.feeAccrued = terms.feeAccrued;\\n\\n        return state;\\n    }\\n\\n    /**\\n     * @notice Computes a schedule segment of non-cyclic contract events based on the contract terms\\n     * and the specified timestamps.\\n     * @param terms terms of the contract\\n     * @param segmentStart start timestamp of the segment\\n     * @param segmentEnd end timestamp of the segement\\n     * @return segment of the non-cyclic schedule\\n     */\\n    function computeNonCyclicScheduleSegment(\\n        PAMTerms calldata terms,\\n        uint256 segmentStart,\\n        uint256 segmentEnd\\n    )\\n        external\\n        pure\\n        override\\n        returns (bytes32[] memory)\\n    {\\n        bytes32[MAX_EVENT_SCHEDULE_SIZE] memory events;\\n        uint16 index;\\n\\n        // issuance\\n        if (terms.issueDate != 0) {\\n            if (isInSegment(terms.issueDate, segmentStart, segmentEnd)) {\\n                events[index] = encodeEvent(EventType.ISS, terms.issueDate);\\n                index++;\\n            }\\n        }\\n\\n        // initial exchange\\n        if (terms.initialExchangeDate != 0) {\\n            if (terms.purchaseDate == 0 && isInSegment(terms.initialExchangeDate, segmentStart, segmentEnd)) {\\n                events[index] = encodeEvent(EventType.IED, terms.initialExchangeDate);\\n                index++;\\n            }\\n        }\\n\\n        // purchase\\n        if (terms.purchaseDate != 0) {\\n            if (isInSegment(terms.purchaseDate, segmentStart, segmentEnd)) {\\n                events[index] = encodeEvent(EventType.PRD, terms.purchaseDate);\\n                index++;\\n            }\\n        }\\n\\n        // principal redemption\\n        if (terms.maturityDate != 0) {\\n            if (isInSegment(terms.maturityDate, segmentStart, segmentEnd)) {\\n                events[index] = encodeEvent(EventType.MD, terms.maturityDate);\\n                index++;\\n            }\\n        }\\n\\n        // remove null entries from returned array\\n        bytes32[] memory schedule = new bytes32[](index);\\n        for (uint256 i = 0; i < index; i++) {\\n            schedule[i] = events[i];\\n        }\\n\\n        return schedule;\\n    }\\n\\n    /**\\n     * @notice Computes a schedule segment of cyclic contract events based on the contract terms\\n     * and the specified timestamps.\\n     * @param terms terms of the contract\\n     * @param segmentStart start timestamp of the segment\\n     * @param segmentEnd end timestamp of the segement\\n     * @param eventType eventType of the cyclic schedule\\n     * @return event schedule segment\\n     */\\n    function computeCyclicScheduleSegment(\\n        PAMTerms calldata terms,\\n        uint256 segmentStart,\\n        uint256 segmentEnd,\\n        EventType eventType\\n    )\\n        external\\n        pure\\n        override\\n        returns(bytes32[] memory)\\n    {\\n        bytes32[MAX_EVENT_SCHEDULE_SIZE] memory events;\\n        uint256 index;\\n\\n        // IP\\n        // interest payment related (starting with PRANX interest is paid following the PR schedule)\\n        if (eventType == EventType.IP) {\\n            if (terms.cycleAnchorDateOfInterestPayment != 0) {\\n                uint256[MAX_CYCLE_SIZE] memory interestPaymentSchedule = computeDatesFromCycleSegment(\\n                    terms.cycleAnchorDateOfInterestPayment,\\n                    terms.maturityDate,\\n                    terms.cycleOfInterestPayment,\\n                    terms.endOfMonthConvention,\\n                    true,\\n                    segmentStart,\\n                    segmentEnd\\n                );\\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\\n                    if (interestPaymentSchedule[i] == 0) break;\\n                    if (interestPaymentSchedule[i] <= terms.capitalizationEndDate) continue;\\n                    if (isInSegment(interestPaymentSchedule[i], segmentStart, segmentEnd) == false) continue;\\n                    events[index] = encodeEvent(EventType.IP, interestPaymentSchedule[i]);\\n                    index++;\\n                }\\n            }\\n        }\\n\\n        // IPCI\\n        if (eventType == EventType.IPCI) {\\n            if (terms.cycleAnchorDateOfInterestPayment != 0 && terms.capitalizationEndDate != 0) {\\n                IPS memory cycleOfInterestCapitalization = terms.cycleOfInterestPayment;\\n                cycleOfInterestCapitalization.s = S.SHORT;\\n                uint256[MAX_CYCLE_SIZE] memory interestPaymentSchedule = computeDatesFromCycleSegment(\\n                    terms.cycleAnchorDateOfInterestPayment,\\n                    terms.capitalizationEndDate,\\n                    cycleOfInterestCapitalization,\\n                    terms.endOfMonthConvention,\\n                    true,\\n                    segmentStart,\\n                    segmentEnd\\n                );\\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\\n                    if (interestPaymentSchedule[i] == 0) break;\\n                    if (isInSegment(interestPaymentSchedule[i], segmentStart, segmentEnd) == false) continue;\\n                    events[index] = encodeEvent(EventType.IPCI, interestPaymentSchedule[i]);\\n                    index++;\\n                }\\n            }\\n        }\\n\\n        // rate reset\\n        if (eventType == EventType.RR) {\\n            if (terms.cycleAnchorDateOfRateReset != 0) {\\n                uint256[MAX_CYCLE_SIZE] memory rateResetSchedule = computeDatesFromCycleSegment(\\n                    terms.cycleAnchorDateOfRateReset,\\n                    terms.maturityDate,\\n                    terms.cycleOfRateReset,\\n                    terms.endOfMonthConvention,\\n                    false,\\n                    segmentStart,\\n                    segmentEnd\\n                );\\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\\n                    if (rateResetSchedule[i] == 0) break;\\n                    if (isInSegment(rateResetSchedule[i], segmentStart, segmentEnd) == false) continue;\\n                    events[index] = encodeEvent(EventType.RR, rateResetSchedule[i]);\\n                    index++;\\n                }\\n            }\\n            // ... nextRateReset\\n        }\\n\\n        // fees\\n        if (eventType == EventType.FP) {\\n            if (terms.cycleAnchorDateOfFee != 0) {\\n                uint256[MAX_CYCLE_SIZE] memory feeSchedule = computeDatesFromCycleSegment(\\n                    terms.cycleAnchorDateOfFee,\\n                    terms.maturityDate,\\n                    terms.cycleOfFee,\\n                    terms.endOfMonthConvention,\\n                    true,\\n                    segmentStart,\\n                    segmentEnd\\n                );\\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\\n                    if (feeSchedule[i] == 0) break;\\n                    if (isInSegment(feeSchedule[i], segmentStart, segmentEnd) == false) continue;\\n                    events[index] = encodeEvent(EventType.FP, feeSchedule[i]);\\n                    index++;\\n                }\\n            }\\n        }\\n\\n        // scaling\\n        if (eventType == EventType.SC) {\\n            if ((terms.scalingEffect != ScalingEffect._000) && terms.cycleAnchorDateOfScalingIndex != 0) {\\n                uint256[MAX_CYCLE_SIZE] memory scalingSchedule = computeDatesFromCycleSegment(\\n                    terms.cycleAnchorDateOfScalingIndex,\\n                    terms.maturityDate,\\n                    terms.cycleOfScalingIndex,\\n                    terms.endOfMonthConvention,\\n                    true,\\n                    segmentStart,\\n                    segmentEnd\\n                );\\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\\n                    if (scalingSchedule[i] == 0) break;\\n                    if (isInSegment(scalingSchedule[i], segmentStart, segmentEnd) == false) continue;\\n                    events[index] = encodeEvent(EventType.SC, scalingSchedule[i]);\\n                    index++;\\n                }\\n            }\\n        }\\n\\n        // remove null entries from returned array\\n        bytes32[] memory schedule = new bytes32[](index);\\n        for (uint256 i = 0; i < index; i++) {\\n            schedule[i] = events[i];\\n        }\\n\\n        return schedule;\\n    }\\n\\n    /**\\n     * @notice Computes the next non-cyclic contract events based on the contract terms\\n     * and the timestamp on which the prev. event occured.\\n     * @dev Assumes that non-cyclic events of the same event type have a unique schedule time\\n     * @param terms terms of the contract\\n     * @param lastNonCyclicEvent last non-cyclic event\\n     * @return next non-cyclic event\\n     */\\n    function computeNextNonCyclicEvent(\\n        PAMTerms calldata terms,\\n        bytes32 lastNonCyclicEvent\\n    )\\n        external\\n        pure\\n        override\\n        returns (bytes32)\\n    {\\n        (EventType lastEventType, uint256 lastScheduleTime) = decodeEvent(lastNonCyclicEvent);\\n\\n        EventType eventTypeNextEvent;\\n        uint256 scheduleTimeNextEvent;\\n\\n        // EventTypes ordered after epoch offset - so we don't have make an additional epochOffset check\\n\\n        // issuance\\n        if (\\n            // date for event has to be set in terms and date of event can be in the past\\n            (terms.issueDate != 0 && (lastScheduleTime <= terms.issueDate))\\n            // date for event has to come before previous candidate for the next event\\n            && (scheduleTimeNextEvent == 0 || terms.issueDate < scheduleTimeNextEvent)\\n            // avoid endless loop by requiring that the event is not the lastNonCyclicEvent\\n            && (lastScheduleTime != terms.issueDate || lastEventType != EventType.ISS)\\n        ) {\\n            eventTypeNextEvent = EventType.ISS;\\n            scheduleTimeNextEvent = terms.issueDate;\\n        }\\n\\n        // initial exchange\\n        if (\\n            // date for event has to be set in terms and date of event can be in the past\\n            (terms.initialExchangeDate != 0 && (lastScheduleTime <= terms.initialExchangeDate))\\n            && (scheduleTimeNextEvent == 0 || terms.initialExchangeDate < scheduleTimeNextEvent)\\n            && (lastScheduleTime != terms.initialExchangeDate || lastEventType != EventType.IED)\\n        ) {\\n            eventTypeNextEvent = EventType.IED;\\n            scheduleTimeNextEvent = terms.initialExchangeDate;\\n        }\\n\\n        // purchase\\n        if (\\n            (terms.purchaseDate != 0 && (lastScheduleTime <= terms.purchaseDate))\\n            && (scheduleTimeNextEvent == 0 || terms.purchaseDate < scheduleTimeNextEvent)\\n            && (lastScheduleTime != terms.purchaseDate || lastEventType != EventType.PRD)\\n        ) {\\n            eventTypeNextEvent = EventType.PRD;\\n            scheduleTimeNextEvent = terms.purchaseDate;\\n        }\\n\\n        // principal redemption at maturity\\n        if (\\n            (terms.maturityDate != 0 && (lastScheduleTime <= terms.maturityDate))\\n            && (scheduleTimeNextEvent == 0 || terms.maturityDate < scheduleTimeNextEvent)\\n            && (lastScheduleTime != terms.maturityDate || lastEventType != EventType.MD)\\n        ) {\\n            eventTypeNextEvent = EventType.MD;\\n            scheduleTimeNextEvent = terms.maturityDate;\\n        }\\n\\n        return encodeEvent(eventTypeNextEvent, scheduleTimeNextEvent);\\n    }\\n\\n    /**\\n     * @notice Computes a schedule segment of cyclic contract events based on the contract terms\\n     * and the specified timestamps.\\n     * @param terms terms of the contract\\n     * @param lastScheduleTime last occurrence of cyclic event\\n     * @param eventType eventType of the cyclic schedule\\n     * @return event schedule segment\\n     */\\n    function computeNextCyclicEvent(\\n        PAMTerms calldata terms,\\n        uint256 lastScheduleTime,\\n        EventType eventType\\n    )\\n        external\\n        pure\\n        override\\n        returns(bytes32)\\n    {\\n        // IP\\n        // interest payment related (starting with PRANX interest is paid following the PR schedule)\\n        if (eventType == EventType.IP) {\\n            if (terms.cycleOfInterestPayment.isSet == true && terms.cycleAnchorDateOfInterestPayment != 0) {\\n                uint256 nextInterestPaymentDate = computeNextCycleDateFromPrecedingDate(\\n                    terms.cycleOfInterestPayment,\\n                    terms.endOfMonthConvention,\\n                    terms.cycleAnchorDateOfInterestPayment,\\n                    lastScheduleTime,\\n                    true,\\n                    terms.maturityDate\\n                );\\n                if (nextInterestPaymentDate == 0) return bytes32(0);\\n                if (nextInterestPaymentDate <= terms.capitalizationEndDate) return bytes32(0);\\n                return encodeEvent(EventType.IP, nextInterestPaymentDate);\\n            }\\n        }\\n\\n        // IPCI\\n        if (eventType == EventType.IPCI) {\\n            if (terms.cycleAnchorDateOfInterestPayment != 0 && terms.capitalizationEndDate != 0) {\\n                IPS memory cycleOfInterestCapitalization = terms.cycleOfInterestPayment;\\n                cycleOfInterestCapitalization.s = S.SHORT;\\n                uint256 nextInterestCapitalizationDate = computeNextCycleDateFromPrecedingDate(\\n                    cycleOfInterestCapitalization,\\n                    terms.endOfMonthConvention,\\n                    terms.cycleAnchorDateOfInterestPayment,\\n                    lastScheduleTime,\\n                    true,\\n                    terms.maturityDate\\n                );\\n                if (nextInterestCapitalizationDate == 0) return bytes32(0);\\n                return encodeEvent(EventType.IPCI, nextInterestCapitalizationDate);\\n            }\\n        }\\n\\n        // rate reset\\n        if (eventType == EventType.RR) {\\n            if (terms.cycleAnchorDateOfRateReset != 0) {\\n                uint256 nextRateResetDate = computeNextCycleDateFromPrecedingDate(\\n                    terms.cycleOfRateReset,\\n                    terms.endOfMonthConvention,\\n                    terms.cycleAnchorDateOfRateReset,\\n                    lastScheduleTime,\\n                    true,\\n                    terms.maturityDate\\n                );\\n                if (nextRateResetDate == 0) return bytes32(0);\\n                return encodeEvent(EventType.RR, nextRateResetDate);\\n            }\\n            // ... nextRateReset\\n        }\\n\\n        // fees\\n        if (eventType == EventType.FP) {\\n            if (terms.cycleAnchorDateOfFee != 0) {\\n                uint256 nextFeeDate = computeNextCycleDateFromPrecedingDate(\\n                    terms.cycleOfFee,\\n                    terms.endOfMonthConvention,\\n                    terms.cycleAnchorDateOfFee,\\n                    lastScheduleTime,\\n                    true,\\n                    terms.maturityDate\\n                );\\n                if (nextFeeDate == 0) return bytes32(0);\\n                return encodeEvent(EventType.FP, nextFeeDate);\\n            }\\n        }\\n\\n        // scaling\\n        if (eventType == EventType.SC) {\\n            if ((terms.scalingEffect != ScalingEffect._000) && terms.cycleAnchorDateOfScalingIndex != 0) {\\n                uint256 nextScalingDate = computeNextCycleDateFromPrecedingDate(\\n                    terms.cycleOfScalingIndex,\\n                    terms.endOfMonthConvention,\\n                    terms.cycleAnchorDateOfScalingIndex,\\n                    lastScheduleTime,\\n                    true,\\n                    terms.maturityDate\\n                );\\n                if (nextScalingDate == 0) return bytes32(0);\\n                return encodeEvent(EventType.SC, nextScalingDate);\\n            }\\n        }\\n\\n        return bytes32(0);\\n    }\\n\\n    /**\\n     * @notice Verifies that the provided event is still scheduled under the terms, the current state of the\\n     * contract and the current state of the underlying.\\n     * param _event event for which to check if its still scheduled\\n     * param terms terms of the contract\\n     * @param state current state of the contract\\n     * param underlyingState state of the underlying (empty state object if non-existing)\\n     * @return boolean indicating whether event is still scheduled\\n     */\\n    function isEventScheduled(\\n        bytes32 /* _event */,\\n        PAMTerms calldata /* terms */,\\n        PAMState calldata state,\\n        UnderlyingState calldata /* underlyingState */\\n    )\\n        external\\n        pure\\n        override\\n        returns (bool)\\n    {\\n         if (\\n            state.contractPerformance == ContractPerformance.DF\\n            || state.contractPerformance == ContractPerformance.MD\\n            || state.contractPerformance == ContractPerformance.TD\\n        ) { return false; }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Implements abstract method which is defined in BaseEngine.\\n     * Applies an event to the current state of the contract and returns the resulting state.\\n     * The inheriting Engine contract has to map the events type to the designated STF.\\n     * todo Annuity calculator for RR/RRF events, IPCB events and ICB state variable\\n     * @param terms terms of the contract\\n     * @param state current state of the contract\\n     * @param _event event for which to evaluate the next state for\\n     * @param externalData external data needed for STF evaluation (e.g. rate for RR events)\\n     * @return the resulting contract state\\n     */\\n    function stateTransitionFunction(\\n        PAMTerms memory terms,\\n        PAMState memory state,\\n        bytes32 _event,\\n        bytes calldata externalData\\n    )\\n        internal\\n        pure\\n        returns (PAMState memory)\\n    {\\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\\n\\n        /*\\n         * Note:\\n         * Not supported: PRD (Purchase) events\\n         */\\n\\n        if (eventType == EventType.AD) return STF_PAM_AD(terms, state, scheduleTime, externalData);\\n        if (eventType == EventType.ISS) return STF_PAM_ISS(terms, state, scheduleTime, externalData);\\n        if (eventType == EventType.IED) return STF_PAM_IED(terms, state, scheduleTime, externalData);\\n        if (eventType == EventType.IPCI) return STF_PAM_IPCI(terms, state, scheduleTime, externalData);\\n        if (eventType == EventType.IP) return STF_PAM_IP(terms, state, scheduleTime, externalData);\\n        if (eventType == EventType.FP) return STF_PAM_FP(terms, state, scheduleTime, externalData);\\n        if (eventType == EventType.PP) return STF_PAM_PP(terms, state, scheduleTime, externalData);\\n        if (eventType == EventType.MD) return STF_PAM_MD(terms, state, scheduleTime, externalData);\\n        if (eventType == EventType.RRF) return STF_PAM_RRF(terms, state, scheduleTime, externalData);\\n        if (eventType == EventType.RR) return STF_PAM_RR(terms, state, scheduleTime, externalData);\\n        if (eventType == EventType.SC) return STF_PAM_SC(terms, state, scheduleTime, externalData);\\n        if (eventType == EventType.TD) return STF_PAM_TD(terms, state, scheduleTime, externalData);\\n        if (eventType == EventType.CE)  return STF_PAM_CE(terms, state, scheduleTime, externalData);\\n\\n        revert(\\\"PAMEngine.stateTransitionFunction: ATTRIBUTE_NOT_FOUND\\\");\\n    }\\n\\n    /**\\n     * @notice Implements abstract method which is defined in BaseEngine.\\n     * Computes the payoff for an event under the current state of the contract.\\n     * The inheriting Engine contract has to map the events type to the designated POF.\\n     * todo IPCB events and Icb state variable, Icb state variable updates in IP-paying events\\n     * @param terms terms of the contract\\n     * @param state current state of the contract\\n     * @param _event event for which the payoff should be evaluated\\n     * @param externalData external data needed for POF evaluation (e.g. fxRate)\\n     * @return the payoff of the event\\n     */\\n    function payoffFunction(\\n        PAMTerms memory terms,\\n        PAMState memory state,\\n        bytes32 _event,\\n        bytes calldata externalData\\n    )\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\\n\\n        /*\\n         * Note: PAM contracts don't have IPCB and PR events.\\n         * Not supported: PRD (Purchase) events\\n         */\\n\\n        if (eventType == EventType.AD) return 0;\\n        if (eventType == EventType.ISS) return 0;\\n        if (eventType == EventType.IPCI) return 0;\\n        if (eventType == EventType.RRF) return 0;\\n        if (eventType == EventType.RR) return 0;\\n        if (eventType == EventType.SC) return 0;\\n        if (eventType == EventType.CE) return 0;\\n        if (eventType == EventType.FP) return POF_PAM_FP(terms, state, scheduleTime, externalData);\\n        if (eventType == EventType.IED) return POF_PAM_IED(terms, state, scheduleTime, externalData);\\n        if (eventType == EventType.IP) return POF_PAM_IP(terms, state, scheduleTime, externalData);\\n        if (eventType == EventType.PP) return POF_PAM_PP(terms, state, scheduleTime, externalData);\\n        if (eventType == EventType.MD) return POF_PAM_MD(terms, state, scheduleTime, externalData);\\n        if (eventType == EventType.TD) return POF_PAM_TD(terms, state, scheduleTime, externalData);\\n\\n        revert(\\\"PAMEngine.payoffFunction: ATTRIBUTE_NOT_FOUND\\\");\\n    }\\n}\\n\",\"keccak256\":\"0x81babe1ee0d0afb0878681e1dbd891761b8a87108795c1fa78fa191f744921cd\",\"license\":\"Apache-2.0\"},\"contracts/ACTUS/Engines/PAM/PAMPOF.sol\":{\"content\":\"// \\\"SPDX-License-Identifier: Apache-2.0\\\"\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/SignedSafeMath.sol\\\";\\n\\nimport \\\"../../Core/Core.sol\\\";\\nimport \\\"../../Core/SignedMath.sol\\\";\\n\\n\\n/**\\n * @title POF\\n * @notice Contains all payoff functions (POFs) currently used by all Engines\\n */\\ncontract PAMPOF is Core {\\n\\n    using SignedSafeMath for int;\\n    using SignedMath for int;\\n\\n\\n    /**\\n     * Calculate the pay-off for PAM Fees. The method how to calculate the fee\\n     * heavily depends on the selected Fee Basis.\\n     * @return the fee amount for PAM contracts\\n     */\\n    function POF_PAM_FP (\\n        PAMTerms memory terms,\\n        PAMState memory state,\\n        uint256 scheduleTime,\\n        bytes calldata /* externalData */\\n    )\\n        internal\\n        pure\\n        returns(int256)\\n    {\\n        if (terms.feeBasis == FeeBasis.A) {\\n            return (\\n                roleSign(terms.contractRole)\\n                * terms.feeRate\\n            );\\n        }\\n\\n        int256 timeFromLastEvent;\\n        {\\n            timeFromLastEvent = yearFraction(\\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\\n                terms.dayCountConvention,\\n                terms.maturityDate\\n            );\\n        }\\n\\n        return (\\n            state.feeAccrued\\n            .add(\\n                timeFromLastEvent\\n                .floatMult(terms.feeRate)\\n                .floatMult(state.notionalPrincipal)\\n            )\\n        );\\n    }\\n\\n    /**\\n     * Calculate the payoff for the initial exchange\\n     * @return the payoff at iniitial exchange for PAM contracts\\n     */\\n    function POF_PAM_IED (\\n        PAMTerms memory terms,\\n        PAMState memory /* state */,\\n        uint256 /* scheduleTime */,\\n        bytes calldata /* externalData */\\n    )\\n        internal\\n        pure\\n        returns(int256)\\n    {\\n        return (\\n            roleSign(terms.contractRole)\\n            * (-1)\\n            * terms.notionalPrincipal\\n                .add(terms.premiumDiscountAtIED)\\n        );\\n    }\\n\\n    /**\\n     * Calculate the interest payment payoff\\n     * @return the interest amount to pay for PAM contracts\\n     */\\n    function POF_PAM_IP (\\n        PAMTerms memory terms,\\n        PAMState memory state,\\n        uint256 scheduleTime,\\n        bytes calldata /* externalData */\\n    )\\n        internal\\n        pure\\n        returns(int256)\\n    {\\n        int256 timeFromLastEvent;\\n        {\\n            timeFromLastEvent = yearFraction(\\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\\n                terms.dayCountConvention,\\n                terms.maturityDate\\n            );\\n        }\\n\\n        return (\\n            state.interestScalingMultiplier\\n            .floatMult(\\n                state.accruedInterest\\n                .add(\\n                    timeFromLastEvent\\n                    .floatMult(state.nominalInterestRate)\\n                    .floatMult(state.notionalPrincipal)\\n                )\\n            )\\n        );\\n    }\\n\\n    /**\\n     * Calculate the principal prepayment payoff\\n     * @return the principal prepayment amount for PAM contracts\\n     */\\n    function POF_PAM_PP (\\n        PAMTerms memory terms,\\n        PAMState memory state,\\n        uint256 /* scheduleTime */,\\n        bytes calldata /* externalData */\\n    )\\n        internal\\n        pure\\n        returns(int256)\\n    {\\n        return (\\n            roleSign(terms.contractRole)\\n            * state.notionalPrincipal\\n        );\\n    }\\n\\n    /**\\n     * Calculate the payoff in case of maturity\\n     * @return the maturity payoff for PAM contracts\\n     */\\n    function POF_PAM_MD (\\n        PAMTerms memory /* terms */,\\n        PAMState memory state,\\n        uint256 /* scheduleTime */,\\n        bytes calldata /* externalData */\\n    )\\n        internal\\n        pure\\n        returns(int256)\\n    {\\n        return (\\n            state.notionalScalingMultiplier\\n                .floatMult(state.notionalPrincipal)\\n        );\\n    }\\n\\n    /**\\n     * Calculate the payoff in case of termination of a contract\\n     * @return the termination payoff amount for PAM contracts\\n     */\\n    function POF_PAM_TD (\\n        PAMTerms memory terms,\\n        PAMState memory state,\\n        uint256 scheduleTime,\\n        bytes calldata /* externalData */\\n    )\\n        internal\\n        pure\\n        returns(int256)\\n    {\\n        int256 timeFromLastEvent;\\n        {\\n            timeFromLastEvent = yearFraction(\\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\\n                terms.dayCountConvention,\\n                terms.maturityDate\\n            );\\n        }\\n\\n        return (\\n            roleSign(terms.contractRole)\\n            * terms.priceAtTerminationDate\\n            .add(state.accruedInterest)\\n            .add(\\n                timeFromLastEvent\\n                .floatMult(state.nominalInterestRate)\\n                .floatMult(state.notionalPrincipal)\\n            )\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x4db0d26d4f28f0b19f30251514d8735ae8a0f58c102439e8cabfad0730188fdd\",\"license\":\"Apache-2.0\"},\"contracts/ACTUS/Engines/PAM/PAMSTF.sol\":{\"content\":\"// \\\"SPDX-License-Identifier: Apache-2.0\\\"\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/SignedSafeMath.sol\\\";\\n\\nimport \\\"../../Core/Core.sol\\\";\\nimport \\\"../../Core/SignedMath.sol\\\";\\n\\n\\n/**\\n * @title STF\\n * @notice Contains all state transition functions (STFs) currently used by all Engines\\n */\\ncontract PAMSTF is Core {\\n\\n    using SignedSafeMath for int;\\n    using SignedMath for int;\\n\\n\\n    /**\\n     * State transition for PAM analysis events\\n     * @param state the old state\\n     * @return the new state\\n     */\\n    function STF_PAM_NE (\\n        PAMTerms memory /* terms */,\\n        PAMState memory state,\\n        uint256 /* scheduleTime */,\\n        bytes calldata /* externalData */\\n    )\\n        internal\\n        pure\\n        returns (PAMState memory)\\n    {\\n        return state;\\n    }\\n\\n    /**\\n     * State transition for PAM analysis events\\n     * @param state the old state\\n     * @return the new state\\n     */\\n    function STF_PAM_AD (\\n        PAMTerms memory terms,\\n        PAMState memory state,\\n        uint256 scheduleTime,\\n        bytes calldata /* externalData */\\n    )\\n        internal\\n        pure\\n        returns (PAMState memory)\\n    {\\n        int256 timeFromLastEvent;\\n        {\\n            timeFromLastEvent = yearFraction(\\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\\n                terms.dayCountConvention,\\n                terms.maturityDate\\n            );\\n        }\\n        state.accruedInterest = state.accruedInterest\\n        .add(\\n            state.nominalInterestRate\\n            .floatMult(state.notionalPrincipal)\\n            .floatMult(timeFromLastEvent)\\n        );\\n        state.feeAccrued = state.feeAccrued\\n        .add(\\n            terms.feeRate\\n            .floatMult(state.notionalPrincipal)\\n            .floatMult(timeFromLastEvent)\\n        );\\n        state.statusDate = scheduleTime;\\n\\n        return state;\\n    }\\n\\n    /**\\n     * State transition for PAM issue events\\n     * @param state the old state\\n     * @return the new state\\n     */\\n    function STF_PAM_ISS (\\n        PAMTerms memory /* terms */,\\n        PAMState memory state,\\n        uint256 scheduleTime,\\n        bytes calldata /* externalData */\\n    )\\n        internal\\n        pure\\n        returns (PAMState memory)\\n    {\\n        state.statusDate = scheduleTime;\\n        return state;\\n    }\\n\\n    /**\\n     * State transition for PAM fee payment events\\n     * @param state the old state\\n     * @return the new state\\n     */\\n    function STF_PAM_FP (\\n        PAMTerms memory terms,\\n        PAMState memory state,\\n        uint256 scheduleTime,\\n        bytes calldata /* externalData */\\n    )\\n        internal\\n        pure\\n        returns (PAMState memory)\\n    {\\n        int256 timeFromLastEvent;\\n        {\\n            timeFromLastEvent = yearFraction(\\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\\n                terms.dayCountConvention,\\n                terms.maturityDate\\n            );\\n        }\\n        state.accruedInterest = state.accruedInterest\\n        .add(\\n            state.nominalInterestRate\\n            .floatMult(state.notionalPrincipal)\\n            .floatMult(timeFromLastEvent)\\n        );\\n        state.feeAccrued = 0;\\n        state.statusDate = scheduleTime;\\n\\n        return state;\\n    }\\n\\n    /**\\n     * State transition for PAM initial exchange\\n     * @param state the old state\\n     * @return the new state\\n     */\\n    function STF_PAM_IED (\\n        PAMTerms memory terms,\\n        PAMState memory state,\\n        uint256 scheduleTime,\\n        bytes calldata /* externalData */\\n    )\\n        internal\\n        pure\\n        returns (PAMState memory)\\n    {\\n        state.notionalPrincipal = roleSign(terms.contractRole) * terms.notionalPrincipal;\\n        state.nominalInterestRate = terms.nominalInterestRate;\\n        state.statusDate = scheduleTime;\\n        state.accruedInterest = terms.accruedInterest;\\n\\n        return state;\\n    }\\n\\n    /**\\n     * State transition for PAM interest capitalization\\n     * @param state the old state\\n     * @return the new state\\n     */\\n    function STF_PAM_IPCI (\\n        PAMTerms memory terms,\\n        PAMState memory state,\\n        uint256 scheduleTime,\\n        bytes calldata /* externalData */\\n    )\\n        internal\\n        pure\\n        returns (PAMState memory)\\n    {\\n        int256 timeFromLastEvent;\\n        {\\n            timeFromLastEvent = yearFraction(\\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\\n                terms.dayCountConvention,\\n                terms.maturityDate\\n            );\\n        }\\n        state.notionalPrincipal = state.notionalPrincipal\\n        .add(\\n            state.accruedInterest\\n            .add(\\n                state.nominalInterestRate\\n                .floatMult(state.notionalPrincipal)\\n                .floatMult(timeFromLastEvent)\\n            )\\n        );\\n        state.accruedInterest = 0;\\n        state.feeAccrued = state.feeAccrued\\n        .add(\\n            terms.feeRate\\n            .floatMult(state.notionalPrincipal)\\n            .floatMult(timeFromLastEvent)\\n        );\\n        state.statusDate = scheduleTime;\\n\\n        return state;\\n    }\\n\\n    /**\\n     * State transition for PAM interest payment\\n     * @param state the old state\\n     * @return the new state\\n     */\\n    function STF_PAM_IP (\\n        PAMTerms memory terms,\\n        PAMState memory state,\\n        uint256 scheduleTime,\\n        bytes calldata /* externalData */\\n    )\\n        internal\\n        pure\\n        returns (PAMState memory)\\n    {\\n        int256 timeFromLastEvent;\\n        {\\n            timeFromLastEvent = yearFraction(\\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\\n                terms.dayCountConvention,\\n                terms.maturityDate\\n            );\\n        }\\n        state.accruedInterest = 0;\\n        state.feeAccrued = state.feeAccrued\\n        .add(\\n            terms.feeRate\\n            .floatMult(state.notionalPrincipal)\\n            .floatMult(timeFromLastEvent)\\n        );\\n        state.statusDate = scheduleTime;\\n\\n        return state;\\n    }\\n\\n    /**\\n     * State transition for PAM principal prepayment\\n     * @param state the old state\\n     * @return the new state\\n     */\\n    function STF_PAM_PP (\\n        PAMTerms memory terms,\\n        PAMState memory state,\\n        uint256 scheduleTime,\\n        bytes calldata /* externalData */\\n    )\\n        internal\\n        pure\\n        returns (PAMState memory)\\n    {\\n        int256 timeFromLastEvent;\\n        {\\n            timeFromLastEvent = yearFraction(\\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\\n                terms.dayCountConvention,\\n                terms.maturityDate\\n            );\\n        }\\n        state.accruedInterest = state.accruedInterest\\n        .add(\\n            state.nominalInterestRate\\n            .floatMult(state.notionalPrincipal)\\n            .floatMult(timeFromLastEvent)\\n        );\\n        state.feeAccrued = state.feeAccrued\\n        .add(\\n            terms.feeRate\\n            .floatMult(state.notionalPrincipal)\\n            .floatMult(timeFromLastEvent)\\n        );\\n        // state.notionalPrincipal -= 0; // riskFactor not supported\\n        state.statusDate = scheduleTime;\\n\\n        return state;\\n    }\\n\\n    /**\\n     * State transition for PAM principal redemption\\n     * @param state the old state\\n     * @return the new state\\n     */\\n    function STF_PAM_PR (\\n        PAMTerms memory terms,\\n        PAMState memory state,\\n        uint256 scheduleTime,\\n        bytes calldata /* externalData */\\n    )\\n        internal\\n        pure\\n        returns (PAMState memory)\\n    {\\n        int256 timeFromLastEvent;\\n        {\\n            timeFromLastEvent = yearFraction(\\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\\n                terms.dayCountConvention,\\n                terms.maturityDate\\n            );\\n        }\\n        state.accruedInterest = state.accruedInterest\\n        .add(\\n            state.nominalInterestRate\\n            .floatMult(state.notionalPrincipal)\\n            .floatMult(timeFromLastEvent)\\n        );\\n        state.feeAccrued = state.feeAccrued\\n        .add(\\n            terms.feeRate\\n            .floatMult(state.notionalPrincipal)\\n            .floatMult(timeFromLastEvent)\\n        );\\n        state.notionalPrincipal = 0;\\n        state.statusDate = scheduleTime;\\n\\n        return state;\\n    }\\n\\n    /**\\n     * State transition for PAM fixed rate resets\\n     * @param state the old state\\n     * @return the new state\\n     */\\n    function STF_PAM_RRF (\\n        PAMTerms memory terms,\\n        PAMState memory state,\\n        uint256 scheduleTime,\\n        bytes calldata /* externalData */\\n    )\\n        internal\\n        pure\\n        returns (PAMState memory)\\n    {\\n        int256 timeFromLastEvent;\\n        {\\n            timeFromLastEvent = yearFraction(\\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\\n                terms.dayCountConvention,\\n                terms.maturityDate\\n            );\\n        }\\n        state.accruedInterest = state.accruedInterest\\n        .add(\\n            state.nominalInterestRate\\n            .floatMult(state.notionalPrincipal)\\n            .floatMult(timeFromLastEvent)\\n        );\\n        state.feeAccrued = state.feeAccrued\\n        .add(\\n            terms.feeRate\\n            .floatMult(state.notionalPrincipal)\\n            .floatMult(timeFromLastEvent)\\n        );\\n        state.nominalInterestRate = terms.nextResetRate;\\n        state.statusDate = scheduleTime;\\n\\n        return state;\\n    }\\n\\n    /**\\n     * State transition for PAM variable rate resets\\n     * @param state the old state\\n     * @return the new state\\n     */\\n    function STF_PAM_RR (\\n        PAMTerms memory terms,\\n        PAMState memory state,\\n        uint256 scheduleTime,\\n        bytes calldata externalData\\n    )\\n        internal\\n        pure\\n        returns (PAMState memory)\\n    {\\n        // apply external rate, multiply with rateMultiplier and add the spread\\n        // riskFactor not supported\\n        int256 rate = abi.decode(externalData, (int256)).floatMult(terms.rateMultiplier).add(terms.rateSpread);\\n\\n        // deltaRate is the difference between the rate that includes external data, spread and multiplier and the currently active rate from the state\\n        int256 deltaRate = rate.sub(state.nominalInterestRate);\\n\\n        // apply period cap/floor\\n        // the deltaRate (the interest rate change) cannot be bigger than the period cap\\n        // and not smaller than the period floor\\n        // math: deltaRate = min(max(deltaRate, periodFloor),lifeCap)\\n        deltaRate = deltaRate.max(terms.periodFloor).min(terms.periodCap);\\n        rate = state.nominalInterestRate.add(deltaRate);\\n\\n        // apply life cap/floor\\n        // the rate cannot be higher than the lifeCap\\n        // and not smaller than the lifeFloor\\n        // math: rate = min(max(rate,lifeFloor),lifeCap)\\n        rate = rate.max(terms.lifeFloor).min(terms.lifeCap);\\n\\n        int256 timeFromLastEvent;\\n        {\\n            timeFromLastEvent = yearFraction(\\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\\n                terms.dayCountConvention,\\n                terms.maturityDate\\n            );\\n        }\\n        state.accruedInterest = state.accruedInterest\\n        .add(\\n            state.nominalInterestRate\\n            .floatMult(state.notionalPrincipal)\\n            .floatMult(timeFromLastEvent)\\n        );\\n        state.nominalInterestRate = rate;\\n        state.statusDate = scheduleTime;\\n\\n        return state;\\n    }\\n\\n    /**\\n     * State transition for PAM scaling index revision events\\n     * @param state the old state\\n     * @return the new state\\n     */\\n    function STF_PAM_SC (\\n        PAMTerms memory terms,\\n        PAMState memory state,\\n        uint256 scheduleTime,\\n        bytes calldata /* externalData */\\n    )\\n        internal\\n        pure\\n        returns (PAMState memory)\\n    {\\n        int256 timeFromLastEvent;\\n        {\\n            timeFromLastEvent = yearFraction(\\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\\n                terms.dayCountConvention,\\n                terms.maturityDate\\n            );\\n        }\\n        state.accruedInterest = state.accruedInterest\\n        .add(\\n            state.nominalInterestRate\\n            .floatMult(state.notionalPrincipal)\\n            .floatMult(timeFromLastEvent)\\n        );\\n        state.feeAccrued = state.feeAccrued\\n        .add(\\n            terms.feeRate\\n            .floatMult(state.notionalPrincipal)\\n            .floatMult(timeFromLastEvent)\\n        );\\n\\n        if ((terms.scalingEffect == ScalingEffect.I00) || (terms.scalingEffect == ScalingEffect.IN0)) {\\n            state.interestScalingMultiplier = 0; // riskFactor not supported\\n        }\\n        if ((terms.scalingEffect == ScalingEffect._0N0) || (terms.scalingEffect == ScalingEffect.IN0)) {\\n            state.notionalScalingMultiplier = 0; // riskFactor not supported\\n        }\\n\\n        state.statusDate = scheduleTime;\\n\\n        return state;\\n    }\\n\\n    /**\\n     * State transition for PAM principal redemption\\n     * @param state the old state\\n     * @return the new state\\n     */\\n    function STF_PAM_MD (\\n        PAMTerms memory terms,\\n        PAMState memory state,\\n        uint256 scheduleTime,\\n        bytes calldata /* externalData */\\n    )\\n        internal\\n        pure\\n        returns (PAMState memory)\\n    {\\n        int256 timeFromLastEvent;\\n        {\\n            timeFromLastEvent = yearFraction(\\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\\n                terms.dayCountConvention,\\n                terms.maturityDate\\n            );\\n        }\\n        state.accruedInterest = state.accruedInterest\\n        .add(\\n            state.nominalInterestRate\\n            .floatMult(state.notionalPrincipal)\\n            .floatMult(timeFromLastEvent)\\n        );\\n        state.feeAccrued = state.feeAccrued\\n        .add(\\n            terms.feeRate\\n            .floatMult(state.notionalPrincipal)\\n            .floatMult(timeFromLastEvent)\\n        );\\n        state.notionalPrincipal = 0;\\n        state.contractPerformance = ContractPerformance.MD;\\n        state.statusDate = scheduleTime;\\n\\n        return state;\\n    }\\n\\n    /**\\n     * State transition for PAM termination events\\n     * @param state the old state\\n     * @return the new state\\n     */\\n    function STF_PAM_TD (\\n        PAMTerms memory /* terms */,\\n        PAMState memory state,\\n        uint256 scheduleTime,\\n        bytes calldata /* externalData */\\n    )\\n        internal\\n        pure\\n        returns (PAMState memory)\\n    {\\n        state.notionalPrincipal = 0;\\n        state.accruedInterest = 0;\\n        state.feeAccrued = 0;\\n        state.contractPerformance = ContractPerformance.TD;\\n        state.statusDate = scheduleTime;\\n\\n        return state;\\n    }\\n\\n    /**\\n     * State transition for PAM credit events\\n     * @param state the old state\\n     * @return the new state\\n     */\\n    function STF_PAM_CE (\\n        PAMTerms memory terms,\\n        PAMState memory state,\\n        uint256 scheduleTime,\\n        bytes calldata externalData\\n    )\\n        internal\\n        pure\\n        returns(PAMState memory)\\n    {\\n        // handle maturity date\\n        uint256 nonPerformingDate = (state.nonPerformingDate == 0)\\n            ? shiftEventTime(\\n                scheduleTime,\\n                terms.businessDayConvention,\\n                terms.calendar,\\n                terms.maturityDate\\n            ) : state.nonPerformingDate;\\n\\n        uint256 currentTimestamp = abi.decode(externalData, (uint256));\\n\\n        bool isInGracePeriod = false;\\n        if (terms.gracePeriod.isSet) {\\n            uint256 graceDate = getTimestampPlusPeriod(terms.gracePeriod, nonPerformingDate);\\n            if (currentTimestamp <= graceDate) {\\n                state.contractPerformance = ContractPerformance.DL;\\n                isInGracePeriod = true;\\n            }\\n        }\\n\\n        if (terms.delinquencyPeriod.isSet && !isInGracePeriod) {\\n            uint256 delinquencyDate = getTimestampPlusPeriod(terms.delinquencyPeriod, nonPerformingDate);\\n            if (currentTimestamp <= delinquencyDate) {\\n                state.contractPerformance = ContractPerformance.DQ;\\n            } else {\\n                state.contractPerformance = ContractPerformance.DF;\\n            }\\n        }\\n\\n        if (state.nonPerformingDate == 0) {\\n            // handle maturity date\\n            state.nonPerformingDate = shiftEventTime(\\n                scheduleTime,\\n                terms.businessDayConvention,\\n                terms.calendar,\\n                terms.maturityDate\\n            );\\n        }\\n\\n        return state;\\n    }\\n}\\n\",\"keccak256\":\"0x92f4ae717fb975bfb2180a7b8170094cb989bd3434e0fce6a2546b6934cce3d5\",\"license\":\"Apache-2.0\"},\"contracts/external/BokkyPooBah/BokkyPooBahsDateTimeLibrary.sol\":{\"content\":\"// \\\"SPDX-License-Identifier: MIT\\\"\\npragma solidity ^0.7.0;\\n\\n// ----------------------------------------------------------------------------\\n// BokkyPooBah's DateTime Library v1.01\\n//\\n// A gas-efficient Solidity date and time library\\n//\\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\\n//\\n// Tested date range 1970/01/01 to 2345/12/31\\n//\\n// Conventions:\\n// Unit      | Range         | Notes\\n// :-------- |:-------------:|:-----\\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\\n// year      | 1970 ... 2345 |\\n// month     | 1 ... 12      |\\n// day       | 1 ... 31      |\\n// hour      | 0 ... 23      |\\n// minute    | 0 ... 59      |\\n// second    | 0 ... 59      |\\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\\n//\\n//\\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\\n// ----------------------------------------------------------------------------\\n\\nlibrary BokkyPooBahsDateTimeLibrary {\\n\\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\\n    uint constant SECONDS_PER_HOUR = 60 * 60;\\n    uint constant SECONDS_PER_MINUTE = 60;\\n    int constant OFFSET19700101 = 2440588;\\n\\n    uint constant DOW_MON = 1;\\n    uint constant DOW_TUE = 2;\\n    uint constant DOW_WED = 3;\\n    uint constant DOW_THU = 4;\\n    uint constant DOW_FRI = 5;\\n    uint constant DOW_SAT = 6;\\n    uint constant DOW_SUN = 7;\\n\\n    // ------------------------------------------------------------------------\\n    // Calculate the number of days from 1970/01/01 to year/month/day using\\n    // the date conversion algorithm from\\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\\n    //\\n    // days = day\\n    //      - 32075\\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\\n    //      - offset\\n    // ------------------------------------------------------------------------\\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\\n        require(year >= 1970);\\n        int _year = int(year);\\n        int _month = int(month);\\n        int _day = int(day);\\n\\n        int __days = _day\\n          - 32075\\n          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\\n          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\\n          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\\n          - OFFSET19700101;\\n\\n        _days = uint(__days);\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Calculate year/month/day from the number of days since 1970/01/01 using\\n    // the date conversion algorithm from\\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\\n    //\\n    // int L = days + 68569 + offset\\n    // int N = 4 * L / 146097\\n    // L = L - (146097 * N + 3) / 4\\n    // year = 4000 * (L + 1) / 1461001\\n    // L = L - 1461 * year / 4 + 31\\n    // month = 80 * L / 2447\\n    // dd = L - 2447 * month / 80\\n    // L = month / 11\\n    // month = month + 2 - 12 * L\\n    // year = 100 * (N - 49) + year + L\\n    // ------------------------------------------------------------------------\\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\\n        int __days = int(_days);\\n\\n        int L = __days + 68569 + OFFSET19700101;\\n        int N = 4 * L / 146097;\\n        L = L - (146097 * N + 3) / 4;\\n        int _year = 4000 * (L + 1) / 1461001;\\n        L = L - 1461 * _year / 4 + 31;\\n        int _month = 80 * L / 2447;\\n        int _day = L - 2447 * _month / 80;\\n        L = _month / 11;\\n        _month = _month + 2 - 12 * L;\\n        _year = 100 * (N - 49) + _year + L;\\n\\n        year = uint(_year);\\n        month = uint(_month);\\n        day = uint(_day);\\n    }\\n\\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\\n    }\\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\\n    }\\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    }\\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n        uint secs = timestamp % SECONDS_PER_DAY;\\n        hour = secs / SECONDS_PER_HOUR;\\n        secs = secs % SECONDS_PER_HOUR;\\n        minute = secs / SECONDS_PER_MINUTE;\\n        second = secs % SECONDS_PER_MINUTE;\\n    }\\n\\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\\n        if (year >= 1970 && month > 0 && month <= 12) {\\n            uint daysInMonth = _getDaysInMonth(year, month);\\n            if (day > 0 && day <= daysInMonth) {\\n                valid = true;\\n            }\\n        }\\n    }\\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\\n        if (isValidDate(year, month, day)) {\\n            if (hour < 24 && minute < 60 && second < 60) {\\n                valid = true;\\n            }\\n        }\\n    }\\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n        leapYear = _isLeapYear(year);\\n    }\\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\\n    }\\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\\n    }\\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\\n    }\\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n        daysInMonth = _getDaysInMonth(year, month);\\n    }\\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\\n            daysInMonth = 31;\\n        } else if (month != 2) {\\n            daysInMonth = 30;\\n        } else {\\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\\n        }\\n    }\\n    // 1 = Monday, 7 = Sunday\\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\\n        uint _days = timestamp / SECONDS_PER_DAY;\\n        dayOfWeek = (_days + 3) % 7 + 1;\\n    }\\n\\n    function getYear(uint timestamp) internal pure returns (uint year) {\\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    }\\n    function getMonth(uint timestamp) internal pure returns (uint month) {\\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    }\\n    function getDay(uint timestamp) internal pure returns (uint day) {\\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    }\\n    function getHour(uint timestamp) internal pure returns (uint hour) {\\n        uint secs = timestamp % SECONDS_PER_DAY;\\n        hour = secs / SECONDS_PER_HOUR;\\n    }\\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\\n        uint secs = timestamp % SECONDS_PER_HOUR;\\n        minute = secs / SECONDS_PER_MINUTE;\\n    }\\n    function getSecond(uint timestamp) internal pure returns (uint second) {\\n        second = timestamp % SECONDS_PER_MINUTE;\\n    }\\n\\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n        year += _years;\\n        uint daysInMonth = _getDaysInMonth(year, month);\\n        if (day > daysInMonth) {\\n            day = daysInMonth;\\n        }\\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\\n        require(newTimestamp >= timestamp);\\n    }\\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n        month += _months;\\n        year += (month - 1) / 12;\\n        month = (month - 1) % 12 + 1;\\n        uint daysInMonth = _getDaysInMonth(year, month);\\n        if (day > daysInMonth) {\\n            day = daysInMonth;\\n        }\\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\\n        require(newTimestamp >= timestamp);\\n    }\\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\\n        require(newTimestamp >= timestamp);\\n    }\\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\\n        require(newTimestamp >= timestamp);\\n    }\\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\\n        require(newTimestamp >= timestamp);\\n    }\\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\\n        newTimestamp = timestamp + _seconds;\\n        require(newTimestamp >= timestamp);\\n    }\\n\\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n        year -= _years;\\n        uint daysInMonth = _getDaysInMonth(year, month);\\n        if (day > daysInMonth) {\\n            day = daysInMonth;\\n        }\\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\\n        require(newTimestamp <= timestamp);\\n    }\\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n        uint yearMonth = year * 12 + (month - 1) - _months;\\n        year = yearMonth / 12;\\n        month = yearMonth % 12 + 1;\\n        uint daysInMonth = _getDaysInMonth(year, month);\\n        if (day > daysInMonth) {\\n            day = daysInMonth;\\n        }\\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\\n        require(newTimestamp <= timestamp);\\n    }\\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\\n        require(newTimestamp <= timestamp);\\n    }\\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\\n        require(newTimestamp <= timestamp);\\n    }\\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\\n        require(newTimestamp <= timestamp);\\n    }\\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\\n        newTimestamp = timestamp - _seconds;\\n        require(newTimestamp <= timestamp);\\n    }\\n\\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\\n        require(fromTimestamp <= toTimestamp);\\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\\n        _years = toYear - fromYear;\\n    }\\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\\n        require(fromTimestamp <= toTimestamp);\\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\\n    }\\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\\n        require(fromTimestamp <= toTimestamp);\\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\\n    }\\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\\n        require(fromTimestamp <= toTimestamp);\\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\\n    }\\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\\n        require(fromTimestamp <= toTimestamp);\\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\\n    }\\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\\n        require(fromTimestamp <= toTimestamp);\\n        _seconds = toTimestamp - fromTimestamp;\\n    }\\n}\",\"keccak256\":\"0x2b0c785d6fe1e5ae7239ac6833b6c014f865e1d12c4628dc9def5e0a901cc3eb\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506146b6806100206000396000f3fe608060405234801561001057600080fd5b506004361061012c5760003560e01c8063bf29250a116100ad578063e450f6f411610071578063e450f6f41461027a578063e5bc0fa71461029a578063e726d680146102ad578063edc0465f14610237578063f5586e05146102c05761012c565b8063bf29250a14610224578063c40c5a9814610237578063cb2ef6f71461023f578063d716291f14610254578063e05a66e0146102675761012c565b80637c0dd8a4116100f45780637c0dd8a4146101c3578063811322fb146101e3578063924076ee146101f6578063aaf5eb6814610209578063bd017ba1146102115761012c565b80630c17308414610131578063179331f31461015a5780631a2e165d1461017a5780636f37e55b1461019a57806372540003146101a2575b600080fd5b61014461013f366004613b2c565b6102d3565b6040516101519190614171565b60405180910390f35b61016d610168366004613bbf565b61034d565b6040516101519190614199565b61018d610188366004613ae7565b61041d565b604051610151919061417c565b61018d610442565b6101b56101b0366004613acf565b61044e565b6040516101519291906141a7565b6101d66101d1366004613d12565b610477565b60405161015191906143ca565b61018d6101f1366004613bfd565b6104ed565b61018d610204366004613d5a565b610501565b61018d6105e0565b6101d661021f366004613d5a565b6105e5565b61018d610232366004613d2e565b610616565b61018d6107e6565b6102476107eb565b6040516101519190614185565b61018d610262366004613df6565b6107f0565b61018d610275366004613c17565b610ae6565b61028d610288366004613e62565b610b04565b604051610151919061412d565b61028d6102a8366004613e2c565b611069565b61018d6102bb36600461410a565b61123b565b61018d6102ce36600461410a565b61138e565b600060036102e46020850185613b87565b60058111156102ef57fe5b1480610312575060046103056020850185613b87565b600581111561031057fe5b145b80610334575060056103276020850185613b87565b600581111561033257fe5b145b1561034157506000610345565b5060015b949350505050565b6000600184600181111561035d57fe5b14156103d95761036c836113f9565b6103758461141b565b1480156103c4575060028260200151600581111561038f57fe5b14806103aa57506003826020015160058111156103a857fe5b145b806103c457506004826020015160058111156103c257fe5b145b156103d157506001610416565b506000610416565b60008460018111156103e757fe5b14156103f557506000610416565b60405162461bcd60e51b815260040161040d9061435f565b60405180910390fd5b9392505050565b6000806104298661044e565b9150506104388186868661123b565b9695505050505050565b670de0b6b3a764000081565b6000808060f884901c602181111561046257fe5b92505067ffffffffffffffff83169050915091565b61047f61385e565b61048761385e565b60008152670de0b6b3a7640000610140820181905261012082015261016083013560208201526101a083013560608201526102a083013560a08201526102c08301356101008201526102e083013560c082015261038083013560e082015290505b919050565b60008160218111156104fb57fe5b92915050565b60008061051661014088016101208901613a9b565b6001600160a01b031614158015610561575061053a61014087016101208801613a9b565b6001600160a01b031661055561012088016101008901613a9b565b6001600160a01b031614155b156105ab576105a461057583850185613acf565b61059e610587368a90038a018a613eac565b610596368a90038a018a613c75565b88888861142a565b906115fd565b90506105d7565b6105d46105bd36889003880188613eac565b6105cc36889003880188613c75565b86868661142a565b90505b95945050505050565b601281565b6105ed61385e565b6105d46105ff36889003880188613eac565b61060e36889003880188613c75565b8686866116f8565b60008060006106248461044e565b91509150600080866101c001356000141580156106465750866101c001358311155b801561065e575080158061065e575080876101c00135105b80156106855750866101c00135831415806106855750600284602181111561068257fe5b14155b156106965750600290506101c08601355b610180870135158015906106af57508661018001358311155b80156106c757508015806106c7575080876101800135105b80156106ee5750866101800135831415806106ee575060038460218111156106eb57fe5b14155b156106ff5750600390506101808601355b6101e0870135158015906107185750866101e001358311155b80156107305750801580610730575080876101e00135105b80156107575750866101e00135831415806107575750600484602181111561075457fe5b14155b156107685750600490506101e08601355b6101a0870135158015906107815750866101a001358311155b80156107995750801580610799575080876101a00135105b80156107c05750866101a00135831415806107c0575060208460218111156107bd57fe5b14155b156107d15750602090506101a08601355b6107db8282610ae6565b979650505050505050565b607881565b600090565b6000600a82602181111561080057fe5b14156108a8576108186105c085016105a08601613ab5565b1515600114801561082d575061022084013515155b156108a857600061086e61084a3687900387016105408801613c5a565b61085a60c0880160a08901613ba3565b8761022001358760018a6101a001356118d6565b90508061087f575060009050610416565b8461020001358111610895575060009050610416565b6108a0600a82610ae6565b915050610416565b600b8260218111156108b657fe5b141561094e57610220840135158015906108d4575061020084013515155b1561094e576108e16138b9565b6108f43686900386016105408701613c5a565b60016040820152905060006109278261091360c0890160a08a01613ba3565b8861022001358860018b6101a001356118d6565b90508061093a5750600091506104169050565b610945600b82610ae6565b92505050610416565b600d82602181111561095c57fe5b14156109c557610240840135156109c55760006109a96109853687900387016105c08801613c5a565b61099560c0880160a08901613ba3565b8761024001358760018a6101a001356118d6565b9050806109ba575060009050610416565b6108a0600d82610ae6565b60058260218111156109d357fe5b1415610a3c5761028084013515610a3c576000610a206109fc3687900387016106c08801613c5a565b610a0c60c0880160a08901613ba3565b8761028001358760018a6101a001356118d6565b905080610a31575060009050610416565b6108a0600582610ae6565b601b826021811115610a4a57fe5b1415610adc576000610a6260e0860160c08701613c40565b6003811115610a6d57fe5b14158015610a7f575061026084013515155b15610adc576000610ac0610a9c3687900387016106408801613c5a565b610aac60c0880160a08901613ba3565b8761026001358760018a6101a001356118d6565b905080610ad1575060009050610416565b6108a0601b82610ae6565b5060009392505050565b60008160f8846021811115610af757fe5b60ff16901b179392505050565b6060610b0e6138e2565b6000600a846021811115610b1e57fe5b1415610c2c5761022087013515610c2c57610b376138e2565b610b726102208901356101a08a0135610b59368c90038c016105408d01613c5a565b610b6960c08d0160a08e01613ba3565b60018c8c611995565b905060005b60788160ff161015610c2957818160ff1660788110610b9257fe5b6020020151610ba057610c29565b886102000135828260ff1660788110610bb557fe5b602002015111610bc457610c21565b610be2828260ff1660788110610bd657fe5b60200201518989611b78565b610beb57610c21565b610c09600a838360ff1660788110610bff57fe5b6020020151610ae6565b848460788110610c1557fe5b60200201526001909201915b600101610b77565b50505b600b846021811115610c3a57fe5b1415610d3f5761022087013515801590610c58575061020087013515155b15610d3f57610c656138b9565b610c783689900389016105408a01613c5a565b600160408201529050610c896138e2565b610cb26102208a01356102008b013584610ca960c08e0160a08f01613ba3565b60018d8d611995565b905060005b60788160ff161015610d3b57818160ff1660788110610cd257fe5b6020020151610ce057610d3b565b610cfe828260ff1660788110610cf257fe5b60200201518a8a611b78565b610d0757610d33565b610d1b600b838360ff1660788110610bff57fe5b858560788110610d2757fe5b60200201526001909301925b600101610cb7565b5050505b600d846021811115610d4d57fe5b1415610e215761024087013515610e2157610d666138e2565b610da16102408901356101a08a0135610d88368c90038c016105c08d01613c5a565b610d9860c08d0160a08e01613ba3565b60008c8c611995565b905060005b60788160ff161015610e1e57818160ff1660788110610dc157fe5b6020020151610dcf57610e1e565b610de1828260ff1660788110610bd657fe5b610dea57610e16565b610dfe600d838360ff1660788110610bff57fe5b848460788110610e0a57fe5b60200201526001909201915b600101610da6565b50505b6005846021811115610e2f57fe5b1415610eea5761028087013515610eea57610e486138e2565b610e6a6102808901356101a08a0135610b59368c90038c016106c08d01613c5a565b905060005b60788160ff161015610ee757818160ff1660788110610e8a57fe5b6020020151610e9857610ee7565b610eaa828260ff1660788110610bd657fe5b610eb357610edf565b610ec76005838360ff1660788110610bff57fe5b848460788110610ed357fe5b60200201526001909201915b600101610e6f565b50505b601b846021811115610ef857fe5b1415610fdc576000610f1060e0890160c08a01613c40565b6003811115610f1b57fe5b14158015610f2d575061026087013515155b15610fdc57610f3a6138e2565b610f5c6102608901356101a08a0135610b59368c90038c016106408d01613c5a565b905060005b60788160ff161015610fd957818160ff1660788110610f7c57fe5b6020020151610f8a57610fd9565b610f9c828260ff1660788110610bd657fe5b610fa557610fd1565b610fb9601b838360ff1660788110610bff57fe5b848460788110610fc557fe5b60200201526001909201915b600101610f61565b50505b60608167ffffffffffffffff81118015610ff557600080fd5b5060405190808252806020026020018201604052801561101f578160200160208202803683370190505b50905060005b8281101561105d5783816078811061103957fe5b602002015182828151811061104a57fe5b6020908102919091010152600101611025565b50979650505050505050565b60606110736138e2565b60006101c0860135156110be57611090866101c001358686611b78565b156110be576110a56002876101c00135610ae6565b828261ffff16607881106110b557fe5b60200201526001015b61018086013515611115576101e08601351580156110e757506110e78661018001358686611b78565b15611115576110fc6003876101800135610ae6565b828261ffff166078811061110c57fe5b60200201526001015b6101e08601351561115e57611130866101e001358686611b78565b1561115e576111456004876101e00135610ae6565b828261ffff166078811061115557fe5b60200201526001015b6101a0860135156111a757611179866101a001358686611b78565b156111a75761118e6020876101a00135610ae6565b828261ffff166078811061119e57fe5b60200201526001015b60608161ffff1667ffffffffffffffff811180156111c457600080fd5b506040519080825280602002602001820160405280156111ee578160200160208202803683370190505b50905060005b8261ffff168110156112305783816078811061120c57fe5b602002015182828151811061121d57fe5b60209081029190910101526001016111f4565b509695505050505050565b60008185141561124c575083610345565b600184600881111561125a57fe5b14806112715750600384600881111561126f57fe5b145b15611287576112808584611ba7565b9050610345565b600284600881111561129557fe5b14806112ac575060048460088111156112aa57fe5b145b156112f05760006112bd8685611ba7565b90506112c886611c03565b6112d182611c03565b14156112de579050610345565b6112e88685611c1a565b915050610345565b60058460088111156112fe57fe5b14806113155750600784600881111561131357fe5b145b15611324576112808584611c1a565b600684600881111561133257fe5b14806113495750600884600881111561134757fe5b145b1561138557600061135a8685611c1a565b905061136586611c03565b61136e82611c03565b141561137b579050610345565b6112e88685611ba7565b50929392505050565b6000600384600881111561139e57fe5b14806113b5575060048460088111156113b357fe5b145b806113cb575060078460088111156113c957fe5b145b806113e1575060088460088111156113df57fe5b145b156113ed575083610345565b6105d78585858561123b565b6000808061140c62015180855b04611c68565b50915091506103458282611cfe565b60006103456201518083611406565b60008060006114388661044e565b9092509050602182602181111561144b57fe5b141561145c576000925050506105d7565b600282602181111561146a57fe5b141561147b576000925050506105d7565b600b82602181111561148957fe5b141561149a576000925050506105d7565b600c8260218111156114a857fe5b14156114b9576000925050506105d7565b600d8260218111156114c757fe5b14156114d8576000925050506105d7565b601b8260218111156114e657fe5b14156114f7576000925050506105d7565b600182602181111561150557fe5b1415611516576000925050506105d7565b600582602181111561152457fe5b1415611540576115378888838888611d84565b925050506105d7565b600382602181111561154e57fe5b1415611561576115378888838888611e36565b600a82602181111561156f57fe5b1415611582576115378888838888611e75565b600982602181111561159057fe5b14156115a3576115378888838888611ed7565b60208260218111156115b157fe5b14156115c4576115378888838888611ef9565b601f8260218111156115d257fe5b14156115e5576115378888838888611f17565b60405162461bcd60e51b815260040161040d906141bf565b600082158061160a575081155b15611617575060006104fb565b8260001914801561162b5750600160ff1b82145b156116675760405162461bcd60e51b815260040180806020018281038252602781526020018061454c6027913960400191505060405180910390fd5b8282028284828161167457fe5b05146116b15760405162461bcd60e51b815260040180806020018281038252602781526020018061454c6027913960400191505060405180910390fd5b670de0b6b3a76400008105806103455760405162461bcd60e51b81526004018080602001828103825260328152602001806144c56032913960400191505060405180910390fd5b61170061385e565b60008061170c8661044e565b9092509050602182602181111561171f57fe5b1415611732576115378888838888611f95565b600282602181111561174057fe5b1415611753576115378888838888612026565b600382602181111561176157fe5b141561177457611537888883888861203b565b600b82602181111561178257fe5b1415611795576115378888838888612082565b600a8260218111156117a357fe5b14156117b6576115378888838888612107565b60058260218111156117c457fe5b14156117d7576115378888838888612159565b60098260218111156117e557fe5b14156117f8576115378888838888611f95565b602082602181111561180657fe5b14156118195761153788888388886121c2565b600c82602181111561182757fe5b141561183a576115378888838888612253565b600d82602181111561184857fe5b141561185b5761153788888388886122e8565b601b82602181111561186957fe5b141561187c576115378888838888612425565b601f82602181111561188a57fe5b141561189d576115378888838888612521565b60018260218111156118ab57fe5b14156118be57611537888883888861254f565b60405162461bcd60e51b815260040161040d9061420c565b606086015160009015806118e8575083155b156118f4575083610438565b6000600161190388888b61034d565b600181111561190e57fe5b146119245761191f88866001612647565b611938565b61193861193389876001612647565b612781565b905083801561194657508215155b1561196e578285141561195d576000915050610438565b8281111561196e5782915050610438565b8315801561197b57508215155b801561198657508281145b156107db576000915050610438565b61199d6138e2565b6119a56138e2565b6060870151600090611a0d576119bc8a8686611b78565b156119d757898282607881106119ce57fe5b60200201526001015b6119e2898686611b78565b15611a055760018615151415611a0557888282607881106119ff57fe5b60200201525b5090506107db565b89600080611a1c8a848d61034d565b90505b8b831015611aac57611a32838989611b78565b15611a705760768410611a575760405162461bcd60e51b815260040161040d9061430f565b82858560788110611a6457fe5b60200201526001909301925b600191820191816001811115611a8257fe5b14611a9757611a928b8e84612647565b611aa5565b611aa56119338c8f85612647565b9250611a1f565b60018915151415611ada57611ac28c8989611b78565b15611ada578b858560788110611ad457fe5b60200201525b600084118015611af75750611af7856001860360788110610bd657fe5b15611b675760008b604001516001811115611b0e57fe5b148015611b1b5750600184115b8015611b275750828c14155b15611b6757848460788110611b3857fe5b6020020151856001860360788110611b4c57fe5b6020020152848460788110611b5d57fe5b6020020160008152505b50929b9a5050505050505050505050565b600081831115611b8a57506000610416565b838311158015611b9a5750818411155b15610adc57506001610416565b60006001826001811115611bb757fe5b1415611bfc57611bc6836127b0565b60061415611be057611bd98360026127c3565b90506104fb565b611be9836127b0565b60071415611bfc57611bd98360016127c3565b5090919050565b6000611c126201518083611406565b509392505050565b60006001826001811115611c2a57fe5b1415611bfc57611c39836127b0565b60061415611c4c57611bd98360016127d8565b611c55836127b0565b60071415611bfc57611bd98360026127d8565b60008080836226496581018262023ab1600483020590506004600362023ab18302010590910390600062164b09610fa0600185010205905060046105b58202058303601f019250600061098f8460500281611cbf57fe5b0590506000605061098f83020585039050600b820560301994909401606402929092018301996002600c90940290910392909201975095509350505050565b60008160011480611d0f5750816003145b80611d1a5750816005145b80611d255750816007145b80611d305750816008145b80611d3b575081600a145b80611d46575081600c145b15611d535750601f6104fb565b81600214611d635750601e6104fb565b611d6c836127ed565b611d7757601c611d7a565b601d5b60ff169392505050565b6000808660e001516001811115611d9757fe5b1415611dbb57856103600151611db08760400151612812565b60000b0290506105d7565b6000611e06611ddd876020015189608001518a602001518b6101a0015161138e565b611df6878a608001518b602001518c6101a0015161138e565b89606001518a6101a001516128f5565b90506107db611e2b8760a0015161059e8a6103600151856115fd90919063ffffffff16565b60e088015190612ab9565b6000611e55866103a00151876102a00151612ab990919063ffffffff16565b611e628760400151612812565b6000190260000b02905095945050505050565b600080611e98611ddd876020015189608001518a602001518b6101a0015161138e565b90506107db611ecb611ec08860a0015161059e8a6101000151866115fd90919063ffffffff16565b60c089015190612ab9565b610120880151906115fd565b60008460a00151611eeb8760400151612812565b60000b029695505050505050565b60006105d48560a001518661014001516115fd90919063ffffffff16565b600080611f3a611ddd876020015189608001518a602001518b6101a0015161138e565b9050611f79611f5f8760a0015161059e896101000151856115fd90919063ffffffff16565b60c08801516103e08a0151611f7391612ab9565b90612ab9565b611f868860400151612812565b60000b02979650505050505050565b611f9d61385e565b6000611fbf611ddd876020015189608001518a602001518b6101a0015161138e565b9050611fef611fe48261059e8960a001518a61010001516115fd90919063ffffffff16565b60c088015190612ab9565b60c087015260a086015161036088015161201391611e2b91849161059e91906115fd565b60e0870152505050506020820152919050565b61202e61385e565b5050506020820152919050565b61204361385e565b856102a001516120568760400151612812565b60000b0260a08601525050506102c083015161010083015260208201526102e09091015160c082015290565b61208a61385e565b60006120ac611ddd876020015189608001518a602001518b6101a0015161138e565b90506120df6120d4611ec08361059e8a60a001518b61010001516115fd90919063ffffffff16565b60a088015190612ab9565b60a08701819052600060c088015261036088015161201391611e2b91849161059e91906115fd565b61210f61385e565b6000612131611ddd876020015189608001518a602001518b6101a0015161138e565b600060c088015260a087015161036089015191925061201391611e2b91849161059e916115fd565b61216161385e565b6000612183611ddd876020015189608001518a602001518b6101a0015161138e565b90506121a8611fe48261059e8960a001518a61010001516115fd90919063ffffffff16565b60c08701525050600060e085015250506020820152919050565b6121ca61385e565b60006121ec611ddd876020015189608001518a602001518b6101a0015161138e565b9050612211611fe48261059e8960a001518a61010001516115fd90919063ffffffff16565b60c087015260a086015161036088015161223591611e2b91849161059e91906115fd565b60e08701525050600060a08501525050600482526020820152919050565b61225b61385e565b600061227d611ddd876020015189608001518a602001518b6101a0015161138e565b90506122a2611fe48261059e8960a001518a61010001516115fd90919063ffffffff16565b60c087015260a08601516103608801516122c691611e2b91849161059e91906115fd565b60e0870152505050506103409290920151610100820152602081019190915290565b6122f061385e565b6000612313876103200151611f73896103000151878781019061059e9190613acf565b9050600061232f87610100015183612b1e90919063ffffffff16565b90506123588861044001516123528a610460015184612b8390919063ffffffff16565b90612b93565b61010088015190915061236b9082612ab9565b915061238e8861040001516123528a610420015185612b8390919063ffffffff16565b915060006123db6123b289602001518b608001518c602001518d6101a0015161138e565b6123cb898c608001518d602001518e6101a0015161138e565b8b606001518c6101a001516128f5565b905061240b6124008261059e8b60a001518c61010001516115fd90919063ffffffff16565b60c08a015190612ab9565b60c089015250506101008601525050506020820152919050565b61242d61385e565b600061244f611ddd876020015189608001518a602001518b6101a0015161138e565b9050612474611fe48261059e8960a001518a61010001516115fd90919063ffffffff16565b60c087015260a086015161036088015161249891611e2b91849161059e91906115fd565b60e087015260018760c0015160038111156124af57fe5b14806124ca575060038760c0015160038111156124c857fe5b145b156124d85760006101208701525b60028760c0015160038111156124ea57fe5b1480612505575060038760c00151600381111561250357fe5b145b156125135760006101408701525b505050506020820152919050565b61252961385e565b5050600060a0840181905260c0840181905260e084015250600582526020820152919050565b61255761385e565b6000856040015160001461256f578560400151612588565b61258885886080015189602001518a6101a0015161123b565b9050600061259884860186613acf565b9050600088610480015160400151156125cf5760006125bc8a610480015185612ba3565b90508083116125cd576001808a5291505b505b886104a001516040015180156125e3575080155b156126125760006125f98a6104a0015185612ba3565b905080831161260b5760028952612610565b600389525b505b604088015161263a57612634878a608001518b602001518c6101a0015161123b565b60408901525b5095979650505050505050565b600080808560200151600581111561265b57fe5b1415612678578451611280906126719085612cbc565b85906127c3565b60018560200151600581111561268a57fe5b14156126ad578451611280906126719085906126a7906007612cbc565b90612cbc565b6002856020015160058111156126bf57fe5b14156126dc578451611280906126d59085612cbc565b8590612d15565b6003856020015160058111156126ee57fe5b141561270b578451611280906126d59085906126a7906003612cbc565b60048560200151600581111561271d57fe5b141561273a578451611280906126d59085906126a7906006612cbc565b60058560200151600581111561274c57fe5b1415612769578451611280906127629085612cbc565b8590612d8f565b60405162461bcd60e51b815260040161040d90614262565b60008060008061279085612db6565b9194509250905060006127a38484611cfe565b9050610438848483612dd4565b6007620151809091046003010660010190565b6201518081028201828110156104fb57600080fd5b6201518081028203828111156104fb57600080fd5b60006004820615801561280257506064820615155b806104fb57505061019090061590565b60008082600c81111561282157fe5b141561282f575060016104e8565b600182600c81111561283d57fe5b141561284c57506000196104e8565b600682600c81111561285a57fe5b1415612868575060016104e8565b600782600c81111561287657fe5b141561288557506000196104e8565b600282600c81111561289357fe5b14156128a1575060016104e8565b600382600c8111156128af57fe5b14156128be57506000196104e8565b60405162461bcd60e51b81526004018080602001828103825260348152602001806145186034913960400191505060405180910390fd5b6000848410156129365760405162461bcd60e51b81526004018080602001828103825260278152602001806145a46027913960400191505060405180910390fd5b600083600a81111561294457fe5b1415612954576112808585612dee565b600183600a81111561296257fe5b1415612972576112808585612ee4565b600283600a81111561298057fe5b1415612990576112808585612f03565b600483600a81111561299e57fe5b14156129ae576112808585612f1c565b600383600a8111156129bc57fe5b14156129cd57611280858584612fbf565b600583600a8111156129db57fe5b14156129ec5761128085858461307d565b600683600a8111156129fa57fe5b1415612a0a57611280858561313f565b600783600a811115612a1857fe5b1415612a2857611280858561314e565b600883600a811115612a3657fe5b1415612a4657611280858561316a565b600983600a811115612a5457fe5b1415612a64576112808585613217565b600a83600a811115612a7257fe5b1415612a825761128085856132ca565b60405162461bcd60e51b81526004018080602001828103825260358152602001806144906035913960400191505060405180910390fd5b6000828201818312801590612ace5750838112155b80612ae35750600083128015612ae357508381125b6104165760405162461bcd60e51b81526004018080602001828103825260218152602001806144f76021913960400191505060405180910390fd5b6000818303818312801590612b335750838113155b80612b485750600083128015612b4857508381135b6104165760405162461bcd60e51b81526004018080602001828103825260248152602001806146396024913960400191505060405180910390fd5b600081831215611bfc5750919050565b600081831315611bfc5781610416565b6000808084602001516005811115612bb757fe5b1415612bd1578351612bca9084906127c3565b9050610416565b600184602001516005811115612be357fe5b1415612c01578351612bca90612bfa906007612cbc565b84906127c3565b600284602001516005811115612c1357fe5b1415612c26578351612bca908490612d15565b600384602001516005811115612c3857fe5b1415612c56578351612bca90612c4f906003612cbc565b8490612d15565b600484602001516005811115612c6857fe5b1415612c7f578351612bca90612c4f906006612cbc565b600584602001516005811115612c9157fe5b1415612ca4578351612bca908490612d8f565b60405162461bcd60e51b815260040161040d906142b2565b600082612ccb575060006104fb565b82820282848281612cd857fe5b04146104165760405162461bcd60e51b81526004018080602001828103825260218152602001806145cb6021913960400191505060405180910390fd5b6000808080612d276201518087611406565b600c918801600019810183810494909401965094509250900660010191506000612d518484611cfe565b905080821115612d5f578091505b62015180870662015180612d7486868661338c565b0201945086851015612d8557600080fd5b5050505092915050565b6000808080612da16201518087611406565b9187019450925090506000612d518484611cfe565b60008080612dc76201518085611406565b9196909550909350915050565b600062015180612de585858561338c565b02949350505050565b600080612dfa84613408565b90506000612e0784613408565b90506000612e1486613420565b612e205761016d612e24565b61016e5b61ffff16905081831415612e5057612e4681612e40888861343d565b9061345c565b93505050506104fb565b6000612e5b86613420565b612e675761016d612e6b565b61016e5b61ffff1690506000612e9683612e408a612e91612e898a6001613594565b600180612dd4565b61343d565b90506000612eb383612e40612ead88600180612dd4565b8b61343d565b9050612ed7612ecd6001612ec7888a6135ee565b906135ee565b611f738484612ab9565b9998505050505050505050565b6000610416610168612e4062015180612efd86886135ee565b90613630565b600061041661016d612e4062015180612efd86886135ee565b6000806000806000806000612f3089612db6565b975095509350612f3f88612db6565b945092509050601f861415612f5357601e95505b82601f1415612f6157601e92505b6000612f6d8488612b1e565b90506000612f7b8488612b1e565b90506000612f898488612b1e565b9050612faf610168612e4085611f73612fa387601e613672565b611f7387610168613672565b9c9b505050505050505050505050565b6000806000806000806000612fd38a612db6565b975095509350612fe289612db6565b945092509050612ff18a6113f9565b861415612ffd57601e95505b878914801561300c5750816002145b158015613020575061301d896113f9565b83145b1561302a57601e92505b60006130368488612b1e565b905060006130448488612b1e565b905060006130528488612b1e565b905061306c610168612e4085611f73612fa387601e613672565b9d9c50505050505050505050505050565b60008060008061308c87612db6565b92509250925060008060006130a089612db6565b9250925092506130af8a6113f9565b8414156130bb57601c93505b87891480156130ca5750816002145b1580156130e857506130db8a6113f9565b8114806130e85750601c81115b156130f15750601c5b60006130fd8286612b1e565b9050600061310b8488612b1e565b90506000613119868a612b1e565b905061306c610150612e4085611f7361313387601c613672565b611f7387610150613672565b670de0b6b3a764000092915050565b6000610416670de0b6b3a764000067a688906bd8b0000061345c565b60008061317684613408565b9050600061318384613408565b9050600061319086613420565b61319c576122386131a0565b6122505b61ffff169050818314156131bc57612e4681612e40888861371b565b60006131c786613420565b6131d3576122386131d7565b6122505b61ffff16905060006131fa83612e408a6131f5612e898a6001613594565b61371b565b90506000612eb383612e4061321188600180612dd4565b8b61371b565b60008061322384613408565b9050600061323084613408565b9050600061323d86613420565b61324a576208052061324f565b62080ac05b62ffffff1690508183141561326c57612e4681612e408888613735565b600061327786613420565b6132845762080520613289565b62080ac05b62ffffff16905060006132ad83612e408a6132a8612e898a6001613594565b613735565b90506000612eb383612e406132c488600180612dd4565b8b613735565b6000806132d684613408565b905060006132e384613408565b905060006132f086613420565b6132fe576301e13380613304565b6301e285005b63ffffffff1690508183141561332257612e4681612e40888861374e565b600061332d86613420565b61333b576301e13380613341565b6301e285005b63ffffffff169050600061336f83612e408a61336a612e8960018b61359490919063ffffffff16565b61374e565b90506000612eb383612e4061338688600180612dd4565b8b61374e565b60006107b284101561339d57600080fd5b838383600062253d8c600460036064611324600c600d19890105890101050205600c80600d19870105600c02600287030361016f02816133d957fe5b0560046105b5600c600d1989010589016112c0010205617d4b8603010103039050809450505050509392505050565b60006134176201518083611406565b50909392505050565b6000806134306201518084611406565b50509050610416816127ed565b60008183111561344c57600080fd5b620151808383035b049392505050565b60008161349a5760405162461bcd60e51b815260040180806020018281038252602481526020018061465d6024913960400191505060405180910390fd5b826134a7575060006104fb565b670de0b6b3a7640000838102908482816134bd57fe5b05146134fa5760405162461bcd60e51b81526004018080602001828103825260268152602001806146136026913960400191505060405180910390fd5b8260001914801561350e5750600160ff1b84145b1561354a5760405162461bcd60e51b81526004018080602001828103825260268152602001806146136026913960400191505060405180910390fd5b600083828161355557fe5b059050806103455760405162461bcd60e51b81526004018080602001828103825260318152602001806145736031913960400191505060405180910390fd5b600082820183811015610416576040805162461bcd60e51b815260206004820152601b60248201527f536166654d6174683a206164646974696f6e206f766572666c6f770000000000604482015290519081900360640190fd5b600061041683836040518060400160405280601e81526020017f536166654d6174683a207375627472616374696f6e206f766572666c6f770000815250613762565b600061041683836040518060400160405280601a81526020017f536166654d6174683a206469766973696f6e206279207a65726f0000000000008152506137f9565b600082613681575060006104fb565b826000191480156136955750600160ff1b82145b156136d15760405162461bcd60e51b81526004018080602001828103825260278152602001806145ec6027913960400191505060405180910390fd5b828202828482816136de57fe5b05146104165760405162461bcd60e51b81526004018080602001828103825260278152602001806145ec6027913960400191505060405180910390fd5b60008183111561372a57600080fd5b610e10838303613454565b60008183111561374457600080fd5b603c838303613454565b60008183111561375d57600080fd5b500390565b600081848411156137f15760405162461bcd60e51b81526004018080602001828103825283818151815260200191508051906020019080838360005b838110156137b657818101518382015260200161379e565b50505050905090810190601f1680156137e35780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b505050900390565b600081836138485760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156137b657818101518382015260200161379e565b50600083858161385457fe5b0495945050505050565b6040805161016081019091528060008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b604080516080810190915260008082526020820190815260200160008152600060209091015290565b60405180610f0001604052806078906020820280368337509192915050565b80356001600160a01b03811681146104e857600080fd5b803580151581146104e857600080fd5b8035600981106104e857600080fd5b80356104e881614472565b80356104e881614482565b8035600d81106104e857600080fd5b8035601481106104e857600080fd5b8035600b81106104e857600080fd5b8035602281106104e857600080fd5b8035600481106104e857600080fd5b6000608082840312156139a9578081fd5b6040516080810181811067ffffffffffffffff821117156139c657fe5b6040528235815290508060208301356139de81614482565b602082015260408301356139f181614472565b6040820152613a0260608401613918565b60608201525092915050565b600060608284031215613a1f578081fd5b6040516060810181811067ffffffffffffffff82111715613a3c57fe5b604052823581529050806020830135613a5481614482565b6020820152613a6560408401613918565b60408201525092915050565b60006101608284031215613a83578081fd5b50919050565b60006107408284031215613a83578081fd5b600060208284031215613aac578081fd5b61041682613901565b600060208284031215613ac6578081fd5b61041682613918565b600060208284031215613ae0578081fd5b5035919050565b60008060008060808587031215613afc578283fd5b84359350613b0c60208601613928565b92506040850135613b1c81614472565b9396929550929360600135925050565b600080600080848603610900811215613b43578283fd5b85359450613b548760208801613a89565b9350613b64876107608801613a71565b925060406108bf1982011215613b78578182fd5b509295919450926108c0019150565b600060208284031215613b98578081fd5b813561041681614482565b600060208284031215613bb4578081fd5b813561041681614472565b600080600060c08486031215613bd3578081fd5b8335613bde81614472565b925060208401359150613bf48560408601613998565b90509250925092565b600060208284031215613c0e578081fd5b6104168261397a565b60008060408385031215613c29578182fd5b613c328361397a565b946020939093013593505050565b600060208284031215613c51578081fd5b61041682613989565b600060808284031215613c6b578081fd5b6104168383613998565b6000610160808385031215613c88578182fd5b613c918161444e565b9050613c9c83613942565b81526020830135602082015260408301356040820152606083013560608201526080830135608082015260a083013560a082015260c083013560c082015260e083013560e08201526101008084013581830152506101208084013581830152506101408084013581830152508091505092915050565b60006107408284031215613d24578081fd5b6104168383613a89565b6000806107608385031215613d41578182fd5b613d4b8484613a89565b94610740939093013593505050565b60008060008060006108e08688031215613d72578283fd5b613d7c8787613a89565b9450613d8c876107408801613a71565b93506108a086013592506108c086013567ffffffffffffffff80821115613db1578283fd5b818801915088601f830112613dc4578283fd5b813581811115613dd2578384fd5b896020828501011115613de3578384fd5b9699959850939650602001949392505050565b60008060006107808486031215613e0b578081fd5b613e158585613a89565b92506107408401359150613bf4610760850161397a565b60008060006107808486031215613e41578081fd5b613e4b8585613a89565b956107408501359550610760909401359392505050565b6000806000806107a08587031215613e78578182fd5b613e828686613a89565b935061074085013592506107608501359150613ea1610780860161397a565b905092959194509250565b60006107408284031215613ebe578081fd5b610540613eca8161444e565b613ed38461395c565b8152613ee160208501613937565b6020820152613ef26040850161394d565b6040820152613f036060850161396b565b6060820152613f1460808501613928565b6080820152613f2560a08501613937565b60a0820152613f3660c08501613989565b60c0820152613f4760e08501613937565b60e0820152610100613f5a818601613901565b90820152610120613f6c858201613901565b908201526101408481013590820152610160808501359082015261018080850135908201526101a080850135908201526101c080850135908201526101e08085013590820152610200808501359082015261022080850135908201526102408085013590820152610260808501359082015261028080850135908201526102a080850135908201526102c080850135908201526102e08085013590820152610300808501359082015261032080850135908201526103408085013590820152610360808501359082015261038080850135908201526103a080850135908201526103c080850135908201526103e08085013590820152610400808501359082015261042080850135908201526104408085013590820152610460808501359082015261048061409d86828701613a0e565b908201526104e06140b086868301613a0e565b6104a08301526140c286848701613998565b6104c08301526140d6866105c08701613998565b908201526140e8856106408601613998565b6105008201526140fc856106c08601613998565b610520820152949350505050565b60008060008060808587031215613afc578182fd5b6006811061412957fe5b9052565b6020808252825182820181905260009190848201906040850190845b8181101561416557835183529284019291840191600101614149565b50909695505050505050565b901515815260200190565b90815260200190565b602081016014831061419357fe5b91905290565b602081016002831061419357fe5b60408101602284106141b557fe5b9281526020015290565b6020808252602d908201527f50414d456e67696e652e7061796f666646756e6374696f6e3a2041545452494260408201526c15551157d393d517d193d55391609a1b606082015260800190565b60208082526036908201527f50414d456e67696e652e73746174655472616e736974696f6e46756e6374696f6040820152751b8e8810551514925095551157d393d517d193d5539160521b606082015260800190565b60208082526030908201527f4379636c655574696c732e6765744e6578744379636c65446174653a2041545460408201526f14925095551157d393d517d193d5539160821b606082015260800190565b60208082526037908201527f506572696f645574696c732e67657454696d657374616d70506c75735065726960408201527f6f643a204154545249425554455f4e4f545f464f554e44000000000000000000606082015260800190565b60208082526030908201527f4379636c655574696c732e636f6d70757465446174657346726f6d4379636c6560408201526f3a204d41585f4359434c455f53495a4560801b606082015260800190565b60208082526045908201527f456e644f664d6f6e7468436f6e76656e74696f6e2e61646a757374456e644f6660408201527f4d6f6e7468436f6e76656e74696f6e3a204154545249425554455f4e4f545f4660608201526427aaa7221760d91b608082015260a00190565b6000610160820190506143de82845161411f565b6020830151602083015260408301516040830152606083015160608301526080830151608083015260a083015160a083015260c083015160c083015260e083015160e083015261010080840151818401525061012080840151818401525061014080840151818401525092915050565b60405181810167ffffffffffffffff8111828210171561446a57fe5b604052919050565b6002811061447f57600080fd5b50565b6006811061447f57600080fdfe446179436f756e74436f6e76656e74696f6e2e796561724672616374696f6e3a204154545249425554455f4e4f545f464f554e442e5369676e65644d6174682e666c6f61744d756c743a2043414e4e4f545f524550524553454e545f4752414e554c41524954595369676e6564536166654d6174683a206164646974696f6e206f766572666c6f77436f6e7472616374526f6c65436f6e76656e74696f6e2e726f6c655369676e3a204154545249425554455f4e4f545f464f554e445369676e65644d6174682e666c6f61744d756c743a204f564552464c4f575f44455445435445445369676e65644d6174682e666c6f61744469763a2043414e4e4f545f524550524553454e545f4752414e554c4152495459436f72652e796561724672616374696f6e3a2053544152545f4e4f545f4245464f52455f454e44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f775369676e6564536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f775369676e65644d6174682e666c6f61744469763a204f564552464c4f575f44455445435445445369676e6564536166654d6174683a207375627472616374696f6e206f766572666c6f775369676e65644d6174682e666c6f61744469763a20444956494445445f42595f5a45524fa2646970667358221220b3389b432a7676b2fa566980c76803002a0be6bfbce525532fe36b71cb50bb6864736f6c63430007040033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061012c5760003560e01c8063bf29250a116100ad578063e450f6f411610071578063e450f6f41461027a578063e5bc0fa71461029a578063e726d680146102ad578063edc0465f14610237578063f5586e05146102c05761012c565b8063bf29250a14610224578063c40c5a9814610237578063cb2ef6f71461023f578063d716291f14610254578063e05a66e0146102675761012c565b80637c0dd8a4116100f45780637c0dd8a4146101c3578063811322fb146101e3578063924076ee146101f6578063aaf5eb6814610209578063bd017ba1146102115761012c565b80630c17308414610131578063179331f31461015a5780631a2e165d1461017a5780636f37e55b1461019a57806372540003146101a2575b600080fd5b61014461013f366004613b2c565b6102d3565b6040516101519190614171565b60405180910390f35b61016d610168366004613bbf565b61034d565b6040516101519190614199565b61018d610188366004613ae7565b61041d565b604051610151919061417c565b61018d610442565b6101b56101b0366004613acf565b61044e565b6040516101519291906141a7565b6101d66101d1366004613d12565b610477565b60405161015191906143ca565b61018d6101f1366004613bfd565b6104ed565b61018d610204366004613d5a565b610501565b61018d6105e0565b6101d661021f366004613d5a565b6105e5565b61018d610232366004613d2e565b610616565b61018d6107e6565b6102476107eb565b6040516101519190614185565b61018d610262366004613df6565b6107f0565b61018d610275366004613c17565b610ae6565b61028d610288366004613e62565b610b04565b604051610151919061412d565b61028d6102a8366004613e2c565b611069565b61018d6102bb36600461410a565b61123b565b61018d6102ce36600461410a565b61138e565b600060036102e46020850185613b87565b60058111156102ef57fe5b1480610312575060046103056020850185613b87565b600581111561031057fe5b145b80610334575060056103276020850185613b87565b600581111561033257fe5b145b1561034157506000610345565b5060015b949350505050565b6000600184600181111561035d57fe5b14156103d95761036c836113f9565b6103758461141b565b1480156103c4575060028260200151600581111561038f57fe5b14806103aa57506003826020015160058111156103a857fe5b145b806103c457506004826020015160058111156103c257fe5b145b156103d157506001610416565b506000610416565b60008460018111156103e757fe5b14156103f557506000610416565b60405162461bcd60e51b815260040161040d9061435f565b60405180910390fd5b9392505050565b6000806104298661044e565b9150506104388186868661123b565b9695505050505050565b670de0b6b3a764000081565b6000808060f884901c602181111561046257fe5b92505067ffffffffffffffff83169050915091565b61047f61385e565b61048761385e565b60008152670de0b6b3a7640000610140820181905261012082015261016083013560208201526101a083013560608201526102a083013560a08201526102c08301356101008201526102e083013560c082015261038083013560e082015290505b919050565b60008160218111156104fb57fe5b92915050565b60008061051661014088016101208901613a9b565b6001600160a01b031614158015610561575061053a61014087016101208801613a9b565b6001600160a01b031661055561012088016101008901613a9b565b6001600160a01b031614155b156105ab576105a461057583850185613acf565b61059e610587368a90038a018a613eac565b610596368a90038a018a613c75565b88888861142a565b906115fd565b90506105d7565b6105d46105bd36889003880188613eac565b6105cc36889003880188613c75565b86868661142a565b90505b95945050505050565b601281565b6105ed61385e565b6105d46105ff36889003880188613eac565b61060e36889003880188613c75565b8686866116f8565b60008060006106248461044e565b91509150600080866101c001356000141580156106465750866101c001358311155b801561065e575080158061065e575080876101c00135105b80156106855750866101c00135831415806106855750600284602181111561068257fe5b14155b156106965750600290506101c08601355b610180870135158015906106af57508661018001358311155b80156106c757508015806106c7575080876101800135105b80156106ee5750866101800135831415806106ee575060038460218111156106eb57fe5b14155b156106ff5750600390506101808601355b6101e0870135158015906107185750866101e001358311155b80156107305750801580610730575080876101e00135105b80156107575750866101e00135831415806107575750600484602181111561075457fe5b14155b156107685750600490506101e08601355b6101a0870135158015906107815750866101a001358311155b80156107995750801580610799575080876101a00135105b80156107c05750866101a00135831415806107c0575060208460218111156107bd57fe5b14155b156107d15750602090506101a08601355b6107db8282610ae6565b979650505050505050565b607881565b600090565b6000600a82602181111561080057fe5b14156108a8576108186105c085016105a08601613ab5565b1515600114801561082d575061022084013515155b156108a857600061086e61084a3687900387016105408801613c5a565b61085a60c0880160a08901613ba3565b8761022001358760018a6101a001356118d6565b90508061087f575060009050610416565b8461020001358111610895575060009050610416565b6108a0600a82610ae6565b915050610416565b600b8260218111156108b657fe5b141561094e57610220840135158015906108d4575061020084013515155b1561094e576108e16138b9565b6108f43686900386016105408701613c5a565b60016040820152905060006109278261091360c0890160a08a01613ba3565b8861022001358860018b6101a001356118d6565b90508061093a5750600091506104169050565b610945600b82610ae6565b92505050610416565b600d82602181111561095c57fe5b14156109c557610240840135156109c55760006109a96109853687900387016105c08801613c5a565b61099560c0880160a08901613ba3565b8761024001358760018a6101a001356118d6565b9050806109ba575060009050610416565b6108a0600d82610ae6565b60058260218111156109d357fe5b1415610a3c5761028084013515610a3c576000610a206109fc3687900387016106c08801613c5a565b610a0c60c0880160a08901613ba3565b8761028001358760018a6101a001356118d6565b905080610a31575060009050610416565b6108a0600582610ae6565b601b826021811115610a4a57fe5b1415610adc576000610a6260e0860160c08701613c40565b6003811115610a6d57fe5b14158015610a7f575061026084013515155b15610adc576000610ac0610a9c3687900387016106408801613c5a565b610aac60c0880160a08901613ba3565b8761026001358760018a6101a001356118d6565b905080610ad1575060009050610416565b6108a0601b82610ae6565b5060009392505050565b60008160f8846021811115610af757fe5b60ff16901b179392505050565b6060610b0e6138e2565b6000600a846021811115610b1e57fe5b1415610c2c5761022087013515610c2c57610b376138e2565b610b726102208901356101a08a0135610b59368c90038c016105408d01613c5a565b610b6960c08d0160a08e01613ba3565b60018c8c611995565b905060005b60788160ff161015610c2957818160ff1660788110610b9257fe5b6020020151610ba057610c29565b886102000135828260ff1660788110610bb557fe5b602002015111610bc457610c21565b610be2828260ff1660788110610bd657fe5b60200201518989611b78565b610beb57610c21565b610c09600a838360ff1660788110610bff57fe5b6020020151610ae6565b848460788110610c1557fe5b60200201526001909201915b600101610b77565b50505b600b846021811115610c3a57fe5b1415610d3f5761022087013515801590610c58575061020087013515155b15610d3f57610c656138b9565b610c783689900389016105408a01613c5a565b600160408201529050610c896138e2565b610cb26102208a01356102008b013584610ca960c08e0160a08f01613ba3565b60018d8d611995565b905060005b60788160ff161015610d3b57818160ff1660788110610cd257fe5b6020020151610ce057610d3b565b610cfe828260ff1660788110610cf257fe5b60200201518a8a611b78565b610d0757610d33565b610d1b600b838360ff1660788110610bff57fe5b858560788110610d2757fe5b60200201526001909301925b600101610cb7565b5050505b600d846021811115610d4d57fe5b1415610e215761024087013515610e2157610d666138e2565b610da16102408901356101a08a0135610d88368c90038c016105c08d01613c5a565b610d9860c08d0160a08e01613ba3565b60008c8c611995565b905060005b60788160ff161015610e1e57818160ff1660788110610dc157fe5b6020020151610dcf57610e1e565b610de1828260ff1660788110610bd657fe5b610dea57610e16565b610dfe600d838360ff1660788110610bff57fe5b848460788110610e0a57fe5b60200201526001909201915b600101610da6565b50505b6005846021811115610e2f57fe5b1415610eea5761028087013515610eea57610e486138e2565b610e6a6102808901356101a08a0135610b59368c90038c016106c08d01613c5a565b905060005b60788160ff161015610ee757818160ff1660788110610e8a57fe5b6020020151610e9857610ee7565b610eaa828260ff1660788110610bd657fe5b610eb357610edf565b610ec76005838360ff1660788110610bff57fe5b848460788110610ed357fe5b60200201526001909201915b600101610e6f565b50505b601b846021811115610ef857fe5b1415610fdc576000610f1060e0890160c08a01613c40565b6003811115610f1b57fe5b14158015610f2d575061026087013515155b15610fdc57610f3a6138e2565b610f5c6102608901356101a08a0135610b59368c90038c016106408d01613c5a565b905060005b60788160ff161015610fd957818160ff1660788110610f7c57fe5b6020020151610f8a57610fd9565b610f9c828260ff1660788110610bd657fe5b610fa557610fd1565b610fb9601b838360ff1660788110610bff57fe5b848460788110610fc557fe5b60200201526001909201915b600101610f61565b50505b60608167ffffffffffffffff81118015610ff557600080fd5b5060405190808252806020026020018201604052801561101f578160200160208202803683370190505b50905060005b8281101561105d5783816078811061103957fe5b602002015182828151811061104a57fe5b6020908102919091010152600101611025565b50979650505050505050565b60606110736138e2565b60006101c0860135156110be57611090866101c001358686611b78565b156110be576110a56002876101c00135610ae6565b828261ffff16607881106110b557fe5b60200201526001015b61018086013515611115576101e08601351580156110e757506110e78661018001358686611b78565b15611115576110fc6003876101800135610ae6565b828261ffff166078811061110c57fe5b60200201526001015b6101e08601351561115e57611130866101e001358686611b78565b1561115e576111456004876101e00135610ae6565b828261ffff166078811061115557fe5b60200201526001015b6101a0860135156111a757611179866101a001358686611b78565b156111a75761118e6020876101a00135610ae6565b828261ffff166078811061119e57fe5b60200201526001015b60608161ffff1667ffffffffffffffff811180156111c457600080fd5b506040519080825280602002602001820160405280156111ee578160200160208202803683370190505b50905060005b8261ffff168110156112305783816078811061120c57fe5b602002015182828151811061121d57fe5b60209081029190910101526001016111f4565b509695505050505050565b60008185141561124c575083610345565b600184600881111561125a57fe5b14806112715750600384600881111561126f57fe5b145b15611287576112808584611ba7565b9050610345565b600284600881111561129557fe5b14806112ac575060048460088111156112aa57fe5b145b156112f05760006112bd8685611ba7565b90506112c886611c03565b6112d182611c03565b14156112de579050610345565b6112e88685611c1a565b915050610345565b60058460088111156112fe57fe5b14806113155750600784600881111561131357fe5b145b15611324576112808584611c1a565b600684600881111561133257fe5b14806113495750600884600881111561134757fe5b145b1561138557600061135a8685611c1a565b905061136586611c03565b61136e82611c03565b141561137b579050610345565b6112e88685611ba7565b50929392505050565b6000600384600881111561139e57fe5b14806113b5575060048460088111156113b357fe5b145b806113cb575060078460088111156113c957fe5b145b806113e1575060088460088111156113df57fe5b145b156113ed575083610345565b6105d78585858561123b565b6000808061140c62015180855b04611c68565b50915091506103458282611cfe565b60006103456201518083611406565b60008060006114388661044e565b9092509050602182602181111561144b57fe5b141561145c576000925050506105d7565b600282602181111561146a57fe5b141561147b576000925050506105d7565b600b82602181111561148957fe5b141561149a576000925050506105d7565b600c8260218111156114a857fe5b14156114b9576000925050506105d7565b600d8260218111156114c757fe5b14156114d8576000925050506105d7565b601b8260218111156114e657fe5b14156114f7576000925050506105d7565b600182602181111561150557fe5b1415611516576000925050506105d7565b600582602181111561152457fe5b1415611540576115378888838888611d84565b925050506105d7565b600382602181111561154e57fe5b1415611561576115378888838888611e36565b600a82602181111561156f57fe5b1415611582576115378888838888611e75565b600982602181111561159057fe5b14156115a3576115378888838888611ed7565b60208260218111156115b157fe5b14156115c4576115378888838888611ef9565b601f8260218111156115d257fe5b14156115e5576115378888838888611f17565b60405162461bcd60e51b815260040161040d906141bf565b600082158061160a575081155b15611617575060006104fb565b8260001914801561162b5750600160ff1b82145b156116675760405162461bcd60e51b815260040180806020018281038252602781526020018061454c6027913960400191505060405180910390fd5b8282028284828161167457fe5b05146116b15760405162461bcd60e51b815260040180806020018281038252602781526020018061454c6027913960400191505060405180910390fd5b670de0b6b3a76400008105806103455760405162461bcd60e51b81526004018080602001828103825260328152602001806144c56032913960400191505060405180910390fd5b61170061385e565b60008061170c8661044e565b9092509050602182602181111561171f57fe5b1415611732576115378888838888611f95565b600282602181111561174057fe5b1415611753576115378888838888612026565b600382602181111561176157fe5b141561177457611537888883888861203b565b600b82602181111561178257fe5b1415611795576115378888838888612082565b600a8260218111156117a357fe5b14156117b6576115378888838888612107565b60058260218111156117c457fe5b14156117d7576115378888838888612159565b60098260218111156117e557fe5b14156117f8576115378888838888611f95565b602082602181111561180657fe5b14156118195761153788888388886121c2565b600c82602181111561182757fe5b141561183a576115378888838888612253565b600d82602181111561184857fe5b141561185b5761153788888388886122e8565b601b82602181111561186957fe5b141561187c576115378888838888612425565b601f82602181111561188a57fe5b141561189d576115378888838888612521565b60018260218111156118ab57fe5b14156118be57611537888883888861254f565b60405162461bcd60e51b815260040161040d9061420c565b606086015160009015806118e8575083155b156118f4575083610438565b6000600161190388888b61034d565b600181111561190e57fe5b146119245761191f88866001612647565b611938565b61193861193389876001612647565b612781565b905083801561194657508215155b1561196e578285141561195d576000915050610438565b8281111561196e5782915050610438565b8315801561197b57508215155b801561198657508281145b156107db576000915050610438565b61199d6138e2565b6119a56138e2565b6060870151600090611a0d576119bc8a8686611b78565b156119d757898282607881106119ce57fe5b60200201526001015b6119e2898686611b78565b15611a055760018615151415611a0557888282607881106119ff57fe5b60200201525b5090506107db565b89600080611a1c8a848d61034d565b90505b8b831015611aac57611a32838989611b78565b15611a705760768410611a575760405162461bcd60e51b815260040161040d9061430f565b82858560788110611a6457fe5b60200201526001909301925b600191820191816001811115611a8257fe5b14611a9757611a928b8e84612647565b611aa5565b611aa56119338c8f85612647565b9250611a1f565b60018915151415611ada57611ac28c8989611b78565b15611ada578b858560788110611ad457fe5b60200201525b600084118015611af75750611af7856001860360788110610bd657fe5b15611b675760008b604001516001811115611b0e57fe5b148015611b1b5750600184115b8015611b275750828c14155b15611b6757848460788110611b3857fe5b6020020151856001860360788110611b4c57fe5b6020020152848460788110611b5d57fe5b6020020160008152505b50929b9a5050505050505050505050565b600081831115611b8a57506000610416565b838311158015611b9a5750818411155b15610adc57506001610416565b60006001826001811115611bb757fe5b1415611bfc57611bc6836127b0565b60061415611be057611bd98360026127c3565b90506104fb565b611be9836127b0565b60071415611bfc57611bd98360016127c3565b5090919050565b6000611c126201518083611406565b509392505050565b60006001826001811115611c2a57fe5b1415611bfc57611c39836127b0565b60061415611c4c57611bd98360016127d8565b611c55836127b0565b60071415611bfc57611bd98360026127d8565b60008080836226496581018262023ab1600483020590506004600362023ab18302010590910390600062164b09610fa0600185010205905060046105b58202058303601f019250600061098f8460500281611cbf57fe5b0590506000605061098f83020585039050600b820560301994909401606402929092018301996002600c90940290910392909201975095509350505050565b60008160011480611d0f5750816003145b80611d1a5750816005145b80611d255750816007145b80611d305750816008145b80611d3b575081600a145b80611d46575081600c145b15611d535750601f6104fb565b81600214611d635750601e6104fb565b611d6c836127ed565b611d7757601c611d7a565b601d5b60ff169392505050565b6000808660e001516001811115611d9757fe5b1415611dbb57856103600151611db08760400151612812565b60000b0290506105d7565b6000611e06611ddd876020015189608001518a602001518b6101a0015161138e565b611df6878a608001518b602001518c6101a0015161138e565b89606001518a6101a001516128f5565b90506107db611e2b8760a0015161059e8a6103600151856115fd90919063ffffffff16565b60e088015190612ab9565b6000611e55866103a00151876102a00151612ab990919063ffffffff16565b611e628760400151612812565b6000190260000b02905095945050505050565b600080611e98611ddd876020015189608001518a602001518b6101a0015161138e565b90506107db611ecb611ec08860a0015161059e8a6101000151866115fd90919063ffffffff16565b60c089015190612ab9565b610120880151906115fd565b60008460a00151611eeb8760400151612812565b60000b029695505050505050565b60006105d48560a001518661014001516115fd90919063ffffffff16565b600080611f3a611ddd876020015189608001518a602001518b6101a0015161138e565b9050611f79611f5f8760a0015161059e896101000151856115fd90919063ffffffff16565b60c08801516103e08a0151611f7391612ab9565b90612ab9565b611f868860400151612812565b60000b02979650505050505050565b611f9d61385e565b6000611fbf611ddd876020015189608001518a602001518b6101a0015161138e565b9050611fef611fe48261059e8960a001518a61010001516115fd90919063ffffffff16565b60c088015190612ab9565b60c087015260a086015161036088015161201391611e2b91849161059e91906115fd565b60e0870152505050506020820152919050565b61202e61385e565b5050506020820152919050565b61204361385e565b856102a001516120568760400151612812565b60000b0260a08601525050506102c083015161010083015260208201526102e09091015160c082015290565b61208a61385e565b60006120ac611ddd876020015189608001518a602001518b6101a0015161138e565b90506120df6120d4611ec08361059e8a60a001518b61010001516115fd90919063ffffffff16565b60a088015190612ab9565b60a08701819052600060c088015261036088015161201391611e2b91849161059e91906115fd565b61210f61385e565b6000612131611ddd876020015189608001518a602001518b6101a0015161138e565b600060c088015260a087015161036089015191925061201391611e2b91849161059e916115fd565b61216161385e565b6000612183611ddd876020015189608001518a602001518b6101a0015161138e565b90506121a8611fe48261059e8960a001518a61010001516115fd90919063ffffffff16565b60c08701525050600060e085015250506020820152919050565b6121ca61385e565b60006121ec611ddd876020015189608001518a602001518b6101a0015161138e565b9050612211611fe48261059e8960a001518a61010001516115fd90919063ffffffff16565b60c087015260a086015161036088015161223591611e2b91849161059e91906115fd565b60e08701525050600060a08501525050600482526020820152919050565b61225b61385e565b600061227d611ddd876020015189608001518a602001518b6101a0015161138e565b90506122a2611fe48261059e8960a001518a61010001516115fd90919063ffffffff16565b60c087015260a08601516103608801516122c691611e2b91849161059e91906115fd565b60e0870152505050506103409290920151610100820152602081019190915290565b6122f061385e565b6000612313876103200151611f73896103000151878781019061059e9190613acf565b9050600061232f87610100015183612b1e90919063ffffffff16565b90506123588861044001516123528a610460015184612b8390919063ffffffff16565b90612b93565b61010088015190915061236b9082612ab9565b915061238e8861040001516123528a610420015185612b8390919063ffffffff16565b915060006123db6123b289602001518b608001518c602001518d6101a0015161138e565b6123cb898c608001518d602001518e6101a0015161138e565b8b606001518c6101a001516128f5565b905061240b6124008261059e8b60a001518c61010001516115fd90919063ffffffff16565b60c08a015190612ab9565b60c089015250506101008601525050506020820152919050565b61242d61385e565b600061244f611ddd876020015189608001518a602001518b6101a0015161138e565b9050612474611fe48261059e8960a001518a61010001516115fd90919063ffffffff16565b60c087015260a086015161036088015161249891611e2b91849161059e91906115fd565b60e087015260018760c0015160038111156124af57fe5b14806124ca575060038760c0015160038111156124c857fe5b145b156124d85760006101208701525b60028760c0015160038111156124ea57fe5b1480612505575060038760c00151600381111561250357fe5b145b156125135760006101408701525b505050506020820152919050565b61252961385e565b5050600060a0840181905260c0840181905260e084015250600582526020820152919050565b61255761385e565b6000856040015160001461256f578560400151612588565b61258885886080015189602001518a6101a0015161123b565b9050600061259884860186613acf565b9050600088610480015160400151156125cf5760006125bc8a610480015185612ba3565b90508083116125cd576001808a5291505b505b886104a001516040015180156125e3575080155b156126125760006125f98a6104a0015185612ba3565b905080831161260b5760028952612610565b600389525b505b604088015161263a57612634878a608001518b602001518c6101a0015161123b565b60408901525b5095979650505050505050565b600080808560200151600581111561265b57fe5b1415612678578451611280906126719085612cbc565b85906127c3565b60018560200151600581111561268a57fe5b14156126ad578451611280906126719085906126a7906007612cbc565b90612cbc565b6002856020015160058111156126bf57fe5b14156126dc578451611280906126d59085612cbc565b8590612d15565b6003856020015160058111156126ee57fe5b141561270b578451611280906126d59085906126a7906003612cbc565b60048560200151600581111561271d57fe5b141561273a578451611280906126d59085906126a7906006612cbc565b60058560200151600581111561274c57fe5b1415612769578451611280906127629085612cbc565b8590612d8f565b60405162461bcd60e51b815260040161040d90614262565b60008060008061279085612db6565b9194509250905060006127a38484611cfe565b9050610438848483612dd4565b6007620151809091046003010660010190565b6201518081028201828110156104fb57600080fd5b6201518081028203828111156104fb57600080fd5b60006004820615801561280257506064820615155b806104fb57505061019090061590565b60008082600c81111561282157fe5b141561282f575060016104e8565b600182600c81111561283d57fe5b141561284c57506000196104e8565b600682600c81111561285a57fe5b1415612868575060016104e8565b600782600c81111561287657fe5b141561288557506000196104e8565b600282600c81111561289357fe5b14156128a1575060016104e8565b600382600c8111156128af57fe5b14156128be57506000196104e8565b60405162461bcd60e51b81526004018080602001828103825260348152602001806145186034913960400191505060405180910390fd5b6000848410156129365760405162461bcd60e51b81526004018080602001828103825260278152602001806145a46027913960400191505060405180910390fd5b600083600a81111561294457fe5b1415612954576112808585612dee565b600183600a81111561296257fe5b1415612972576112808585612ee4565b600283600a81111561298057fe5b1415612990576112808585612f03565b600483600a81111561299e57fe5b14156129ae576112808585612f1c565b600383600a8111156129bc57fe5b14156129cd57611280858584612fbf565b600583600a8111156129db57fe5b14156129ec5761128085858461307d565b600683600a8111156129fa57fe5b1415612a0a57611280858561313f565b600783600a811115612a1857fe5b1415612a2857611280858561314e565b600883600a811115612a3657fe5b1415612a4657611280858561316a565b600983600a811115612a5457fe5b1415612a64576112808585613217565b600a83600a811115612a7257fe5b1415612a825761128085856132ca565b60405162461bcd60e51b81526004018080602001828103825260358152602001806144906035913960400191505060405180910390fd5b6000828201818312801590612ace5750838112155b80612ae35750600083128015612ae357508381125b6104165760405162461bcd60e51b81526004018080602001828103825260218152602001806144f76021913960400191505060405180910390fd5b6000818303818312801590612b335750838113155b80612b485750600083128015612b4857508381135b6104165760405162461bcd60e51b81526004018080602001828103825260248152602001806146396024913960400191505060405180910390fd5b600081831215611bfc5750919050565b600081831315611bfc5781610416565b6000808084602001516005811115612bb757fe5b1415612bd1578351612bca9084906127c3565b9050610416565b600184602001516005811115612be357fe5b1415612c01578351612bca90612bfa906007612cbc565b84906127c3565b600284602001516005811115612c1357fe5b1415612c26578351612bca908490612d15565b600384602001516005811115612c3857fe5b1415612c56578351612bca90612c4f906003612cbc565b8490612d15565b600484602001516005811115612c6857fe5b1415612c7f578351612bca90612c4f906006612cbc565b600584602001516005811115612c9157fe5b1415612ca4578351612bca908490612d8f565b60405162461bcd60e51b815260040161040d906142b2565b600082612ccb575060006104fb565b82820282848281612cd857fe5b04146104165760405162461bcd60e51b81526004018080602001828103825260218152602001806145cb6021913960400191505060405180910390fd5b6000808080612d276201518087611406565b600c918801600019810183810494909401965094509250900660010191506000612d518484611cfe565b905080821115612d5f578091505b62015180870662015180612d7486868661338c565b0201945086851015612d8557600080fd5b5050505092915050565b6000808080612da16201518087611406565b9187019450925090506000612d518484611cfe565b60008080612dc76201518085611406565b9196909550909350915050565b600062015180612de585858561338c565b02949350505050565b600080612dfa84613408565b90506000612e0784613408565b90506000612e1486613420565b612e205761016d612e24565b61016e5b61ffff16905081831415612e5057612e4681612e40888861343d565b9061345c565b93505050506104fb565b6000612e5b86613420565b612e675761016d612e6b565b61016e5b61ffff1690506000612e9683612e408a612e91612e898a6001613594565b600180612dd4565b61343d565b90506000612eb383612e40612ead88600180612dd4565b8b61343d565b9050612ed7612ecd6001612ec7888a6135ee565b906135ee565b611f738484612ab9565b9998505050505050505050565b6000610416610168612e4062015180612efd86886135ee565b90613630565b600061041661016d612e4062015180612efd86886135ee565b6000806000806000806000612f3089612db6565b975095509350612f3f88612db6565b945092509050601f861415612f5357601e95505b82601f1415612f6157601e92505b6000612f6d8488612b1e565b90506000612f7b8488612b1e565b90506000612f898488612b1e565b9050612faf610168612e4085611f73612fa387601e613672565b611f7387610168613672565b9c9b505050505050505050505050565b6000806000806000806000612fd38a612db6565b975095509350612fe289612db6565b945092509050612ff18a6113f9565b861415612ffd57601e95505b878914801561300c5750816002145b158015613020575061301d896113f9565b83145b1561302a57601e92505b60006130368488612b1e565b905060006130448488612b1e565b905060006130528488612b1e565b905061306c610168612e4085611f73612fa387601e613672565b9d9c50505050505050505050505050565b60008060008061308c87612db6565b92509250925060008060006130a089612db6565b9250925092506130af8a6113f9565b8414156130bb57601c93505b87891480156130ca5750816002145b1580156130e857506130db8a6113f9565b8114806130e85750601c81115b156130f15750601c5b60006130fd8286612b1e565b9050600061310b8488612b1e565b90506000613119868a612b1e565b905061306c610150612e4085611f7361313387601c613672565b611f7387610150613672565b670de0b6b3a764000092915050565b6000610416670de0b6b3a764000067a688906bd8b0000061345c565b60008061317684613408565b9050600061318384613408565b9050600061319086613420565b61319c576122386131a0565b6122505b61ffff169050818314156131bc57612e4681612e40888861371b565b60006131c786613420565b6131d3576122386131d7565b6122505b61ffff16905060006131fa83612e408a6131f5612e898a6001613594565b61371b565b90506000612eb383612e4061321188600180612dd4565b8b61371b565b60008061322384613408565b9050600061323084613408565b9050600061323d86613420565b61324a576208052061324f565b62080ac05b62ffffff1690508183141561326c57612e4681612e408888613735565b600061327786613420565b6132845762080520613289565b62080ac05b62ffffff16905060006132ad83612e408a6132a8612e898a6001613594565b613735565b90506000612eb383612e406132c488600180612dd4565b8b613735565b6000806132d684613408565b905060006132e384613408565b905060006132f086613420565b6132fe576301e13380613304565b6301e285005b63ffffffff1690508183141561332257612e4681612e40888861374e565b600061332d86613420565b61333b576301e13380613341565b6301e285005b63ffffffff169050600061336f83612e408a61336a612e8960018b61359490919063ffffffff16565b61374e565b90506000612eb383612e4061338688600180612dd4565b8b61374e565b60006107b284101561339d57600080fd5b838383600062253d8c600460036064611324600c600d19890105890101050205600c80600d19870105600c02600287030361016f02816133d957fe5b0560046105b5600c600d1989010589016112c0010205617d4b8603010103039050809450505050509392505050565b60006134176201518083611406565b50909392505050565b6000806134306201518084611406565b50509050610416816127ed565b60008183111561344c57600080fd5b620151808383035b049392505050565b60008161349a5760405162461bcd60e51b815260040180806020018281038252602481526020018061465d6024913960400191505060405180910390fd5b826134a7575060006104fb565b670de0b6b3a7640000838102908482816134bd57fe5b05146134fa5760405162461bcd60e51b81526004018080602001828103825260268152602001806146136026913960400191505060405180910390fd5b8260001914801561350e5750600160ff1b84145b1561354a5760405162461bcd60e51b81526004018080602001828103825260268152602001806146136026913960400191505060405180910390fd5b600083828161355557fe5b059050806103455760405162461bcd60e51b81526004018080602001828103825260318152602001806145736031913960400191505060405180910390fd5b600082820183811015610416576040805162461bcd60e51b815260206004820152601b60248201527f536166654d6174683a206164646974696f6e206f766572666c6f770000000000604482015290519081900360640190fd5b600061041683836040518060400160405280601e81526020017f536166654d6174683a207375627472616374696f6e206f766572666c6f770000815250613762565b600061041683836040518060400160405280601a81526020017f536166654d6174683a206469766973696f6e206279207a65726f0000000000008152506137f9565b600082613681575060006104fb565b826000191480156136955750600160ff1b82145b156136d15760405162461bcd60e51b81526004018080602001828103825260278152602001806145ec6027913960400191505060405180910390fd5b828202828482816136de57fe5b05146104165760405162461bcd60e51b81526004018080602001828103825260278152602001806145ec6027913960400191505060405180910390fd5b60008183111561372a57600080fd5b610e10838303613454565b60008183111561374457600080fd5b603c838303613454565b60008183111561375d57600080fd5b500390565b600081848411156137f15760405162461bcd60e51b81526004018080602001828103825283818151815260200191508051906020019080838360005b838110156137b657818101518382015260200161379e565b50505050905090810190601f1680156137e35780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b505050900390565b600081836138485760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156137b657818101518382015260200161379e565b50600083858161385457fe5b0495945050505050565b6040805161016081019091528060008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b604080516080810190915260008082526020820190815260200160008152600060209091015290565b60405180610f0001604052806078906020820280368337509192915050565b80356001600160a01b03811681146104e857600080fd5b803580151581146104e857600080fd5b8035600981106104e857600080fd5b80356104e881614472565b80356104e881614482565b8035600d81106104e857600080fd5b8035601481106104e857600080fd5b8035600b81106104e857600080fd5b8035602281106104e857600080fd5b8035600481106104e857600080fd5b6000608082840312156139a9578081fd5b6040516080810181811067ffffffffffffffff821117156139c657fe5b6040528235815290508060208301356139de81614482565b602082015260408301356139f181614472565b6040820152613a0260608401613918565b60608201525092915050565b600060608284031215613a1f578081fd5b6040516060810181811067ffffffffffffffff82111715613a3c57fe5b604052823581529050806020830135613a5481614482565b6020820152613a6560408401613918565b60408201525092915050565b60006101608284031215613a83578081fd5b50919050565b60006107408284031215613a83578081fd5b600060208284031215613aac578081fd5b61041682613901565b600060208284031215613ac6578081fd5b61041682613918565b600060208284031215613ae0578081fd5b5035919050565b60008060008060808587031215613afc578283fd5b84359350613b0c60208601613928565b92506040850135613b1c81614472565b9396929550929360600135925050565b600080600080848603610900811215613b43578283fd5b85359450613b548760208801613a89565b9350613b64876107608801613a71565b925060406108bf1982011215613b78578182fd5b509295919450926108c0019150565b600060208284031215613b98578081fd5b813561041681614482565b600060208284031215613bb4578081fd5b813561041681614472565b600080600060c08486031215613bd3578081fd5b8335613bde81614472565b925060208401359150613bf48560408601613998565b90509250925092565b600060208284031215613c0e578081fd5b6104168261397a565b60008060408385031215613c29578182fd5b613c328361397a565b946020939093013593505050565b600060208284031215613c51578081fd5b61041682613989565b600060808284031215613c6b578081fd5b6104168383613998565b6000610160808385031215613c88578182fd5b613c918161444e565b9050613c9c83613942565b81526020830135602082015260408301356040820152606083013560608201526080830135608082015260a083013560a082015260c083013560c082015260e083013560e08201526101008084013581830152506101208084013581830152506101408084013581830152508091505092915050565b60006107408284031215613d24578081fd5b6104168383613a89565b6000806107608385031215613d41578182fd5b613d4b8484613a89565b94610740939093013593505050565b60008060008060006108e08688031215613d72578283fd5b613d7c8787613a89565b9450613d8c876107408801613a71565b93506108a086013592506108c086013567ffffffffffffffff80821115613db1578283fd5b818801915088601f830112613dc4578283fd5b813581811115613dd2578384fd5b896020828501011115613de3578384fd5b9699959850939650602001949392505050565b60008060006107808486031215613e0b578081fd5b613e158585613a89565b92506107408401359150613bf4610760850161397a565b60008060006107808486031215613e41578081fd5b613e4b8585613a89565b956107408501359550610760909401359392505050565b6000806000806107a08587031215613e78578182fd5b613e828686613a89565b935061074085013592506107608501359150613ea1610780860161397a565b905092959194509250565b60006107408284031215613ebe578081fd5b610540613eca8161444e565b613ed38461395c565b8152613ee160208501613937565b6020820152613ef26040850161394d565b6040820152613f036060850161396b565b6060820152613f1460808501613928565b6080820152613f2560a08501613937565b60a0820152613f3660c08501613989565b60c0820152613f4760e08501613937565b60e0820152610100613f5a818601613901565b90820152610120613f6c858201613901565b908201526101408481013590820152610160808501359082015261018080850135908201526101a080850135908201526101c080850135908201526101e08085013590820152610200808501359082015261022080850135908201526102408085013590820152610260808501359082015261028080850135908201526102a080850135908201526102c080850135908201526102e08085013590820152610300808501359082015261032080850135908201526103408085013590820152610360808501359082015261038080850135908201526103a080850135908201526103c080850135908201526103e08085013590820152610400808501359082015261042080850135908201526104408085013590820152610460808501359082015261048061409d86828701613a0e565b908201526104e06140b086868301613a0e565b6104a08301526140c286848701613998565b6104c08301526140d6866105c08701613998565b908201526140e8856106408601613998565b6105008201526140fc856106c08601613998565b610520820152949350505050565b60008060008060808587031215613afc578182fd5b6006811061412957fe5b9052565b6020808252825182820181905260009190848201906040850190845b8181101561416557835183529284019291840191600101614149565b50909695505050505050565b901515815260200190565b90815260200190565b602081016014831061419357fe5b91905290565b602081016002831061419357fe5b60408101602284106141b557fe5b9281526020015290565b6020808252602d908201527f50414d456e67696e652e7061796f666646756e6374696f6e3a2041545452494260408201526c15551157d393d517d193d55391609a1b606082015260800190565b60208082526036908201527f50414d456e67696e652e73746174655472616e736974696f6e46756e6374696f6040820152751b8e8810551514925095551157d393d517d193d5539160521b606082015260800190565b60208082526030908201527f4379636c655574696c732e6765744e6578744379636c65446174653a2041545460408201526f14925095551157d393d517d193d5539160821b606082015260800190565b60208082526037908201527f506572696f645574696c732e67657454696d657374616d70506c75735065726960408201527f6f643a204154545249425554455f4e4f545f464f554e44000000000000000000606082015260800190565b60208082526030908201527f4379636c655574696c732e636f6d70757465446174657346726f6d4379636c6560408201526f3a204d41585f4359434c455f53495a4560801b606082015260800190565b60208082526045908201527f456e644f664d6f6e7468436f6e76656e74696f6e2e61646a757374456e644f6660408201527f4d6f6e7468436f6e76656e74696f6e3a204154545249425554455f4e4f545f4660608201526427aaa7221760d91b608082015260a00190565b6000610160820190506143de82845161411f565b6020830151602083015260408301516040830152606083015160608301526080830151608083015260a083015160a083015260c083015160c083015260e083015160e083015261010080840151818401525061012080840151818401525061014080840151818401525092915050565b60405181810167ffffffffffffffff8111828210171561446a57fe5b604052919050565b6002811061447f57600080fd5b50565b6006811061447f57600080fdfe446179436f756e74436f6e76656e74696f6e2e796561724672616374696f6e3a204154545249425554455f4e4f545f464f554e442e5369676e65644d6174682e666c6f61744d756c743a2043414e4e4f545f524550524553454e545f4752414e554c41524954595369676e6564536166654d6174683a206164646974696f6e206f766572666c6f77436f6e7472616374526f6c65436f6e76656e74696f6e2e726f6c655369676e3a204154545249425554455f4e4f545f464f554e445369676e65644d6174682e666c6f61744d756c743a204f564552464c4f575f44455445435445445369676e65644d6174682e666c6f61744469763a2043414e4e4f545f524550524553454e545f4752414e554c4152495459436f72652e796561724672616374696f6e3a2053544152545f4e4f545f4245464f52455f454e44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f775369676e6564536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f775369676e65644d6174682e666c6f61744469763a204f564552464c4f575f44455445435445445369676e6564536166654d6174683a207375627472616374696f6e206f766572666c6f775369676e65644d6174682e666c6f61744469763a20444956494445445f42595f5a45524fa2646970667358221220b3389b432a7676b2fa566980c76803002a0be6bfbce525532fe36b71cb50bb6864736f6c63430007040033",
  "devdoc": {
    "details": "All numbers except unix timestamp are represented as multiple of 10 ** 18",
    "kind": "dev",
    "methods": {
      "adjustEndOfMonthConvention(uint8,uint256,(uint256,uint8,uint8,bool))": {
        "details": "The following is considered to dertermine if schedule dates are shifted to the end of month: - The convention SD (same day) means not adjusting, EM (end of month) means adjusting - Dates are only shifted if the schedule start date is an end-of-month date - Dates are only shifted if the schedule cycle is based on an \"M\" period unit or multiple thereof",
        "params": {
          "cycle": "the cycle struct",
          "eomc": "the end of month convention to adjust",
          "startTime": "timestamp of the cycle start"
        },
        "returns": {
          "_0": "the adjusted end of month convention"
        }
      },
      "computeCyclicScheduleSegment((uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,address,address,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,(uint256,uint8,bool),(uint256,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool)),uint256,uint256,uint8)": {
        "params": {
          "eventType": "eventType of the cyclic schedule",
          "segmentEnd": "end timestamp of the segement",
          "segmentStart": "start timestamp of the segment",
          "terms": "terms of the contract"
        },
        "returns": {
          "_0": "event schedule segment"
        }
      },
      "computeEventTimeForEvent(bytes32,uint8,uint8,uint256)": {
        "details": "For optimization reasons not located in EventUtil by applying the BDC specified in the terms"
      },
      "computeInitialState((uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,address,address,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,(uint256,uint8,bool),(uint256,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool)))": {
        "params": {
          "terms": "terms of the contract"
        },
        "returns": {
          "_0": "the initial state of the contract"
        }
      },
      "computeNextCyclicEvent((uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,address,address,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,(uint256,uint8,bool),(uint256,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool)),uint256,uint8)": {
        "params": {
          "eventType": "eventType of the cyclic schedule",
          "lastScheduleTime": "last occurrence of cyclic event",
          "terms": "terms of the contract"
        },
        "returns": {
          "_0": "event schedule segment"
        }
      },
      "computeNextNonCyclicEvent((uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,address,address,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,(uint256,uint8,bool),(uint256,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool)),bytes32)": {
        "details": "Assumes that non-cyclic events of the same event type have a unique schedule time",
        "params": {
          "lastNonCyclicEvent": "last non-cyclic event",
          "terms": "terms of the contract"
        },
        "returns": {
          "_0": "next non-cyclic event"
        }
      },
      "computeNonCyclicScheduleSegment((uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,address,address,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,(uint256,uint8,bool),(uint256,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool)),uint256,uint256)": {
        "params": {
          "segmentEnd": "end timestamp of the segement",
          "segmentStart": "start timestamp of the segment",
          "terms": "terms of the contract"
        },
        "returns": {
          "_0": "segment of the non-cyclic schedule"
        }
      },
      "computePayoffForEvent((uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,address,address,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,(uint256,uint8,bool),(uint256,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool)),(uint8,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256),bytes32,bytes)": {
        "params": {
          "_event": "event for which the payoff should be evaluated",
          "externalData": "external data needed for POF evaluation (e.g. fxRate)",
          "state": "current state of the contract",
          "terms": "terms of the contract"
        },
        "returns": {
          "_0": "the payoff of the event"
        }
      },
      "computeStateForEvent((uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,address,address,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,(uint256,uint8,bool),(uint256,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool)),(uint8,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256),bytes32,bytes)": {
        "params": {
          "_event": "event to be applied to the contract state",
          "externalData": "external data needed for STF evaluation (e.g. rate for RR events)",
          "state": "current state of the contract",
          "terms": "terms of the contract"
        },
        "returns": {
          "_0": "the resulting contract state"
        }
      },
      "isEventScheduled(bytes32,(uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,address,address,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,(uint256,uint8,bool),(uint256,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool)),(uint8,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256),(int256,bool))": {
        "params": {
          "state": "current state of the contract param underlyingState state of the underlying (empty state object if non-existing)"
        },
        "returns": {
          "_0": "boolean indicating whether event is still scheduled"
        }
      }
    },
    "title": "PAMEngine",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "adjustEndOfMonthConvention(uint8,uint256,(uint256,uint8,uint8,bool))": {
        "notice": "This function makes an adjustment on the end of month convention."
      },
      "computeCyclicScheduleSegment((uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,address,address,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,(uint256,uint8,bool),(uint256,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool)),uint256,uint256,uint8)": {
        "notice": "Computes a schedule segment of cyclic contract events based on the contract terms and the specified timestamps."
      },
      "computeEventTimeForEvent(bytes32,uint8,uint8,uint256)": {
        "notice": "Returns the event time for a given schedule time"
      },
      "computeInitialState((uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,address,address,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,(uint256,uint8,bool),(uint256,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool)))": {
        "notice": "Initialize contract state space based on the contract terms."
      },
      "computeNextCyclicEvent((uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,address,address,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,(uint256,uint8,bool),(uint256,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool)),uint256,uint8)": {
        "notice": "Computes a schedule segment of cyclic contract events based on the contract terms and the specified timestamps."
      },
      "computeNextNonCyclicEvent((uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,address,address,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,(uint256,uint8,bool),(uint256,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool)),bytes32)": {
        "notice": "Computes the next non-cyclic contract events based on the contract terms and the timestamp on which the prev. event occured."
      },
      "computeNonCyclicScheduleSegment((uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,address,address,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,(uint256,uint8,bool),(uint256,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool)),uint256,uint256)": {
        "notice": "Computes a schedule segment of non-cyclic contract events based on the contract terms and the specified timestamps."
      },
      "computePayoffForEvent((uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,address,address,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,(uint256,uint8,bool),(uint256,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool)),(uint8,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256),bytes32,bytes)": {
        "notice": "Evaluates the payoff for an event under the current state of the contract."
      },
      "computeStateForEvent((uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,address,address,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,(uint256,uint8,bool),(uint256,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool)),(uint8,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256),bytes32,bytes)": {
        "notice": "Applys an event to the current state of a contract and returns the resulting contract state."
      },
      "getEpochOffset(uint8)": {
        "notice": "Returns the epoch offset for a given event type to determine the correct order of events if multiple events have the same timestamp"
      },
      "isEventScheduled(bytes32,(uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,address,address,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,(uint256,uint8,bool),(uint256,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool),(uint256,uint8,uint8,bool)),(uint8,uint256,uint256,uint256,uint256,int256,int256,int256,int256,int256,int256),(int256,bool))": {
        "notice": "Verifies that the provided event is still scheduled under the terms, the current state of the contract and the current state of the underlying. param _event event for which to check if its still scheduled param terms terms of the contract"
      },
      "shiftCalcTime(uint256,uint8,uint8,uint256)": {
        "notice": "Used in POFs and STFs for DCFs. No shifting is applied if a Calc/Shift instead of Shift/Calc BDC is provided."
      }
    },
    "notice": "Inherits from BaseEngine by implementing STFs, POFs according to the ACTUS standard for a PAM contract",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}