{
  "language": "Solidity",
  "sources": {
    "contracts/ACTUS/Core/ACTUSConstants.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\n\n\n/**\n * @title ACTUSConstants\n * @notice Contains all type definitions for ACTUS. See ACTUS-Dictionary for definitions\n */\ncontract ACTUSConstants {\n\n    // constants used throughout\n    uint256 constant public PRECISION = 18;\n    int256 constant public ONE_POINT_ZERO = 1 * 10 ** 18;\n    uint256 constant public MAX_CYCLE_SIZE = 120;\n    uint256 constant public MAX_EVENT_SCHEDULE_SIZE = 120;\n}\n"
    },
    "contracts/Core/Base/SharedTypes.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\n\nimport \"../../ACTUS/Core/ACTUSTypes.sol\";\nimport \"../../ACTUS/Core/ACTUSConstants.sol\";\n\n\nstruct AssetOwnership {\n    // account which has to fulfill all obligations for the creator side\n    address creatorObligor;\n    // account to which all cashflows to which the creator is the beneficiary are forwarded\n    address creatorBeneficiary;\n    // account which has to fulfill all obligations for the counterparty\n    address counterpartyObligor;\n    // account to which all cashflows to which the counterparty is the beneficiary are forwarded\n    address counterpartyBeneficiary;\n}\n\n// scheduleTime and EventType are tightly packed and encoded as bytes32\nstruct Schedule {\n    // schedule times of cyclic events (used if no schedule is set)\n    mapping(EventType => uint256) lastScheduleTimeOfCyclicEvent;\n    // index of event => bytes32 encoded event\n    mapping(uint256 => bytes32) events;\n    // the length of the schedule, used to determine the end of the schedule\n    uint256 length;\n    // pointer to index of the next event in the schedule\n    uint256 nextScheduleIndex;\n    // last event which could not be settled\n    bytes32 pendingEvent;\n    // last non-cyclic event which was processed (used if no schedule is set)\n    bytes32 lastNonCyclicEvent;\n}\n"
    },
    "contracts/ACTUS/Core/ACTUSTypes.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\n\n/**\n * Commit: https://github.com/atpar/actus-dictionary/commit/b85b9b378967de6bfc4d8b6687b520c48bce9890\n * Date: 2020-10-06\n */\n\n\n// IPS\nenum P {D, W, M, Q, H, Y} // P=[D=Days, W=Weeks, M=Months, Q=Quarters, H=Halfyear, Y=Year]\nenum S {LONG, SHORT} // S=[+=long stub,- short stub, {} if S empty then - for short stub]\nstruct IPS {\n    uint256 i; // I=Integer\n    P p;\n    S s;\n    bool isSet;\n}\n\nstruct IP {\n    uint256 i;\n    P p;\n    bool isSet;\n}\n\n// Number of enum options should be limited to 256 (8 bits) such that 255 enums can be packed fit into 256 bits (bytes32)\nenum BusinessDayConvention {NOS, SCF, SCMF, CSF, CSMF, SCP, SCMP, CSP, CSMP}\nenum Calendar {NC, MF}\nenum ContractPerformance {PF, DL, DQ, DF, MD, TD}\nenum ContractReferenceType {CNT, CID, MOC, EID, CST}\nenum ContractReferenceRole {UDL, FIL, SEL, COVE, COVI}\nenum ContractRole {RPA, RPL, RFL, PFL, RF, PF, BUY, SEL, COL, CNO, UDL, UDLP, UDLM}\nenum ContractType {PAM, ANN, NAM, LAM, LAX, CLM, UMP, CSH, STK, COM, SWAPS, SWPPV, FXOUT, CAPFL, FUTUR, OPTNS, CEG, CEC, CERTF}\nenum CouponType {NOC, FIX, FCN, PRF}\nenum CyclePointOfInterestPayment {B, E}\nenum CyclePointOfRateReset {B, E}\nenum DayCountConvention {AA, A360, A365, _30E360ISDA, _30E360, _28E336}\nenum EndOfMonthConvention {SD, EOM}\n//               0   1    2    3    4   5   6   7   8   9  10    11  12   13   14   15   16   17   18   19   20   21   22   23   24   25  26  27    28   29  30  31  32  33\nenum EventType {NE, CE, ISS, IED, PRD, FP, PR, PD, PY, PP, IP, IPCI, RRF, RR, DIF, DIX, DIP, COF, COP, REF, REX, REP, SPF, SPS, EXO, EXE, ST, SC, IPCB, PRF, MC, TD, MD, AD}\nenum FeeBasis {A, N}\n// enum GuaranteedExposure {NO, NI, MV} // not implemented\n// enum InterestCalculationBase {NT, NTIED, NTL} // not implemented\n// enum PenaltyType {O, A, N, I}\n// enum PrepaymentEffect {N, A, M} // not implemented\nenum RedeemableByIssuer {Y, N}\nenum ScalingEffect {_000, I00, _0N0, IN0}\n// enum Seniority {S, J} // not implemented\n\nstruct ContractReference {\n    bytes32 object;\n    bytes32 object2; // workaround for solc bug (replace object and object2 with single bytes attribute)\n    ContractReferenceType _type;\n    ContractReferenceRole role;\n}\n\nstruct State {\n    ContractPerformance contractPerformance;\n\n    uint256 statusDate;\n    uint256 nonPerformingDate;\n    uint256 maturityDate;\n    uint256 exerciseDate;\n    uint256 terminationDate;\n    uint256 lastCouponFixingDate;\n    uint256 lastDividendFixingDate;\n    // uint256 dividendFixingDate; // not implemented\n    // uint256 dividendExDate; // not implemented\n    // uint256 dividendPaymentDate; // not implemented\n    // uint256 splitSettlementDate; // not implemented\n    // uint256 redemptionExDate; // not implemented\n    // uint256 redemptionPaymentDate; // not implemented\n\n    int256 notionalPrincipal;\n    // int256 notionalPrincipal2;\n    int256 accruedInterest;\n    // int256 accruedInterest2;\n    int256 feeAccrued;\n    int256 nominalInterestRate;\n    // int256 nominalInterestRate2;\n    // int256 interestCalculationBaseAmount;\n    int256 interestScalingMultiplier;\n    int256 notionalScalingMultiplier;\n    int256 nextPrincipalRedemptionPayment;\n    int256 exerciseAmount;\n    int256 exerciseQuantity;\n\n    int256 quantity;\n    int256 couponAmountFixed;\n    // int256 exerciseQuantityOrdered;\n    int256 marginFactor;\n    int256 adjustmentFactor;\n    int256 dividendPaymentAmount;\n    int256 splitRatio;\n}\n\nstruct ANNTerms {\n    ContractType contractType;\n    Calendar calendar;\n    ContractRole contractRole;\n    DayCountConvention dayCountConvention;\n    BusinessDayConvention businessDayConvention;\n    EndOfMonthConvention endOfMonthConvention;\n    ScalingEffect scalingEffect;\n    // PenaltyType penaltyType; not implemented\n    FeeBasis feeBasis;\n    // ContractPerformance contractPerformance; // state only\n    // Seniority seniority; // not implemented\n    // PrepaymentEffect prepaymentEffect; // not implemented\n    // InterestCalculationBase interestCalculationBase; // not implemented\n\n    address currency;\n    address settlementCurrency;\n\n    // bytes32 marketObjectCode; // not implemented\n    bytes32 marketObjectCodeRateReset;\n    // bytes32 marketObjectCodeOfScalingIndex; // not implemented\n\n    uint256 statusDate;\n    uint256 initialExchangeDate;\n    uint256 maturityDate;\n    uint256 issueDate;\n    // uint256 terminationDate; // state only\n    uint256 purchaseDate;\n    uint256 capitalizationEndDate;\n    // uint256 ammortizationDate; // not implemented\n    // uint256 optionExerciseEndDate; // not implemented\n    // uint256 nonPerformingDate; // state only\n    uint256 cycleAnchorDateOfInterestPayment;\n    // uint256 cycleAnchorDateOfInterestCalculationBase; // not implemented\n    uint256 cycleAnchorDateOfRateReset;\n    uint256 cycleAnchorDateOfScalingIndex;\n    uint256 cycleAnchorDateOfFee;\n    uint256 cycleAnchorDateOfPrincipalRedemption;\n    // uint256 cycleAnchorDateOfOptionality; // not implemented\n\n    int256 notionalPrincipal;\n    int256 nominalInterestRate;\n    int256 accruedInterest;\n    int256 rateMultiplier;\n    int256 rateSpread;\n    int256 nextResetRate;\n    int256 feeRate;\n    int256 feeAccrued;\n    // int256 penaltyRate; not implemented\n    // int256 delinquencyRate; not implemented\n    int256 premiumDiscountAtIED;\n    int256 priceAtPurchaseDate;\n    int256 priceAtTerminationDate;\n    // int256 creditLineAmount; // not implemented\n    // int256 scalingIndexAtStatusDate; // not implemented\n    // int256 marketValueObserved; // not implemented\n    int256 nextPrincipalRedemptionPayment;\n    // int256 coverageOfCreditEnhancement;\n    // int256 interestCalculationBaseAmount; // not implemented\n    int256 lifeCap;\n    int256 lifeFloor;\n    int256 periodCap;\n    int256 periodFloor;\n\n    IP gracePeriod;\n    IP delinquencyPeriod;\n    // IP prepaymentPeriod; // not implemented\n    // IP fixingPeriod; // not implemented\n\n    IPS cycleOfInterestPayment;\n    IPS cycleOfRateReset;\n    IPS cycleOfScalingIndex;\n    IPS cycleOfFee;\n    IPS cycleOfPrincipalRedemption;\n    // IPS cycleOfOptionality; // not implemented\n    // IPS cycleOfInterestCalculationBase; // not implemented\n}\n\nstruct CECTerms {\n    ContractType contractType;\n    Calendar calendar;\n    ContractRole contractRole;\n    DayCountConvention dayCountConvention;\n    BusinessDayConvention businessDayConvention;\n    EndOfMonthConvention endOfMonthConvention;\n    ContractPerformance creditEventTypeCovered;\n    FeeBasis feeBasis;\n    // GuaranteedExposure guaranteedExposure; // not implemented\n\n    uint256 statusDate;\n    uint256 maturityDate;\n    // uint256 exerciseDate; // state only\n\n    int256 notionalPrincipal;\n    int256 feeRate;\n    // int256 exerciseAmount; // state only\n    int256 coverageOfCreditEnhancement;\n\n    // IP settlementPeriod; // not implemented\n\n    // for simplification since terms are limited only two contract references\n    // - make ContractReference top level and skip ContractStructure\n    ContractReference contractReference_1;\n    ContractReference contractReference_2;\n}\n\nstruct CEGTerms {\n    ContractType contractType;\n    Calendar calendar;\n    ContractRole contractRole;\n    DayCountConvention dayCountConvention;\n    BusinessDayConvention businessDayConvention;\n    EndOfMonthConvention endOfMonthConvention;\n    FeeBasis feeBasis;\n    // ContractPerformance contractPerformance; // state only\n    ContractPerformance creditEventTypeCovered;\n    // GuaranteedExposure guaranteedExposure; // not implemented\n\n    address currency;\n    address settlementCurrency;\n\n    uint256 statusDate;\n    uint256 maturityDate;\n    uint256 purchaseDate;\n    uint256 cycleAnchorDateOfFee;\n    // uint256 exerciseDate; // state only\n    // uint256 nonPerformingDate; // state only\n\n    int256 notionalPrincipal;\n    // int256 delinquencyRate; not implemented\n    int256 feeAccrued;\n    int256 feeRate;\n    int256 priceAtPurchaseDate;\n    int256 priceAtTerminationDate;\n    int256 coverageOfCreditEnhancement;\n    // int256 exerciseAmount; // state only\n\n    IP gracePeriod;\n    IP delinquencyPeriod;\n    // IP settlementPeriod; // not implemented\n\n    IPS cycleOfFee;\n\n    // for simplification since terms are limited only two contract references\n    // - make ContractReference top level and skip ContractStructure\n    ContractReference contractReference_1;\n    ContractReference contractReference_2;\n}\n\nstruct CERTFTerms {\n    ContractType contractType;\n    Calendar calendar;\n    ContractRole contractRole;\n    DayCountConvention dayCountConvention;\n    BusinessDayConvention businessDayConvention;\n    EndOfMonthConvention endOfMonthConvention;\n    CouponType couponType;\n    // ContractPerformance contractPerformance; state only\n\n    address currency;\n    address settlementCurrency;\n\n    // bytes32 marketObjectCode; // not implemented\n\n    uint256 statusDate;\n    uint256 initialExchangeDate;\n    uint256 maturityDate;\n    // uint256 nonPerformingDate; // state only\n    uint256 issueDate;\n    // uint256 lastCouponFixingDate; // state only\n    uint256 cycleAnchorDateOfRedemption;\n    uint256 cycleAnchorDateOfTermination;\n    uint256 cycleAnchorDateOfCoupon;\n\n    int256 nominalPrice;\n    int256 issuePrice;\n    // int256 delinquencyRate; // not implemented\n    int256 quantity;\n    // int256 exerciseQuantity; // state only\n    // int256 exerciseQuantityOrdered; // state only\n    // int256 marginFactor;  // state only\n    // int256 adjustmentFactor; // state only\n    int256 denominationRatio;\n    int256 couponRate;\n    // int256 exerciseAmount; // state only\n    // int256 couponAmountFixed; // state only\n\n    IP gracePeriod;\n    IP delinquencyPeriod;\n    IP settlementPeriod;\n    IP fixingPeriod;\n    IP redemptionRecordPeriod;\n\n    IPS cycleOfRedemption;\n    IPS cycleOfTermination;\n    IPS cycleOfCoupon;\n\n    ContractReference contractReference_1;\n    ContractReference contractReference_2;\n}\n\nstruct PAMTerms {\n    ContractType contractType;\n    Calendar calendar;\n    ContractRole contractRole;\n    DayCountConvention dayCountConvention;\n    BusinessDayConvention businessDayConvention;\n    EndOfMonthConvention endOfMonthConvention;\n    ScalingEffect scalingEffect;\n    // PenaltyType penaltyType; not implemented\n    FeeBasis feeBasis;\n    // ContractPerformance contractPerformance; // state only\n    // Seniority seniority; // not implemented\n    // PrepaymentEffect prepaymentEffect; // not implemented\n    // CyclePointOfInterestPayment cyclePointOfInterestPayment; // not implemented\n    // CyclePointOfRateReset cyclePointOfRateReset; // not implemented\n\n    address currency;\n    address settlementCurrency;\n\n    // bytes32 marketObjectCode; // not implemented\n    bytes32 marketObjectCodeRateReset;\n    // bytes32 marketObjectCodeOfScalingIndex; // not implemented\n\n    uint256 statusDate;\n    uint256 initialExchangeDate;\n    uint256 maturityDate;\n    uint256 issueDate;\n    // uint256 terminationDate; // state only\n    uint256 purchaseDate;\n    uint256 capitalizationEndDate;\n    // uint256 optionExerciseEndDate; // not implemented\n    // uint256 nonPerformingDate; // state only\n    uint256 cycleAnchorDateOfInterestPayment;\n    uint256 cycleAnchorDateOfRateReset;\n    uint256 cycleAnchorDateOfScalingIndex;\n    uint256 cycleAnchorDateOfFee;\n    // uint256 cycleAnchorDateOfOptionality; // not implemented\n\n    int256 notionalPrincipal;\n    int256 nominalInterestRate;\n    int256 accruedInterest;\n    int256 rateMultiplier;\n    int256 rateSpread;\n    int256 nextResetRate;\n    int256 feeRate;\n    int256 feeAccrued;\n    // int256 penaltyRate; not implemented\n    // int256 delinquencyRate; // not implemented\n    int256 premiumDiscountAtIED;\n    int256 priceAtPurchaseDate;\n    int256 priceAtTerminationDate;\n    // int256 creditLineAmount; // not implemented\n    // int256 scalingIndexAtStatusDate; // not implemented\n    // int256 marketValueObserved; // not implemented\n    int256 lifeCap;\n    int256 lifeFloor;\n    int256 periodCap;\n    int256 periodFloor;\n\n    IP gracePeriod;\n    IP delinquencyPeriod;\n    // IP prepaymentPeriod; // not implemented\n    // IP fixingPeriod; // not implemented\n\n    IPS cycleOfInterestPayment;\n    IPS cycleOfRateReset;\n    IPS cycleOfScalingIndex;\n    IPS cycleOfFee;\n    // IPS cycleOfOptionality; // not implemented\n}\n\nstruct STKTerms {\n    ContractType contractType;\n    Calendar calendar;\n    ContractRole contractRole;\n    DayCountConvention dayCountConvention;\n    BusinessDayConvention businessDayConvention;\n    EndOfMonthConvention endOfMonthConvention;\n    RedeemableByIssuer redeemableByIssuer;\n    // Seniority seniority; // not implemented\n\n    address currency;\n    address settlementCurrency;\n\n    // bytes32 marketObjectCode; // not implemented\n\n    uint256 statusDate;\n    uint256 issueDate;\n    uint256 purchaseDate;\n    uint256 cycleAnchorDateOfDividend;\n\n    int256 nominalPrice;\n    int256 notionalPrincipal;\n    int256 issuePrice;\n    int256 quantity;\n    int256 priceAtPurchaseDate;\n    int256 redemptionPrice;\n    int256 priceAtTerminationDate;\n\n    IP dividendRecordPeriod;\n    IP dividendPaymentPeriod;\n    IP splitSettlementPeriod;\n    IP redemptionRecordPeriod;\n    IP redemptionPaymentPeriod;\n\n    IPS cycleOfDividend;\n}\n"
    },
    "contracts/Core/STK/STKRegistry.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../ACTUS/Engines/STK/ISTKEngine.sol\";\n\nimport \"../Base/SharedTypes.sol\";\nimport \"../Base/AssetRegistry/BaseRegistry.sol\";\nimport \"./STKEncoder.sol\";\nimport \"./ISTKRegistry.sol\";\n\n\n/**\n * @title STKRegistry\n * @notice Registry for ACTUS Protocol assets\n */\ncontract STKRegistry is BaseRegistry, ISTKRegistry {\n\n    using STKEncoder for Asset;\n\n\n    constructor() BaseRegistry() {}\n\n    /**\n     * @notice\n     * @param assetId id of the asset\n     * @param terms asset specific terms (STKTerms)\n     * @param state initial state of the asset\n     * @param schedule schedule of the asset\n     * @param ownership ownership of the asset\n     * @param engine ACTUS Engine of the asset\n     * @param actor account which is allowed to update the asset state\n     * @param admin account which as admin rights (optional)\n     */\n    function registerAsset(\n        bytes32 assetId,\n        STKTerms calldata terms,\n        State calldata state,\n        bytes32[] calldata schedule,\n        AssetOwnership calldata ownership,\n        address engine,\n        address actor,\n        address admin\n    )\n        external\n        override\n        onlyApprovedActors\n    {\n        setAsset(assetId, state, schedule, ownership, engine, actor, admin);\n        assets[assetId].encodeAndSetSTKTerms(terms);\n    }\n\n    /**\n     * @notice Returns the terms of an asset.\n     * @param assetId id of the asset\n     * @return terms of the asset\n     */\n    function getTerms(bytes32 assetId)\n        external\n        view\n        override\n        returns (STKTerms memory)\n    {\n        return assets[assetId].decodeAndGetSTKTerms();\n    }\n\n    /**\n     * @notice Set the terms of the asset\n     * @dev Can only be set by authorized account.\n     * @param assetId id of the asset\n     * @param terms new terms\n     */\n    function setTerms(bytes32 assetId, STKTerms calldata terms)\n        external\n        override\n        isAuthorized (assetId)\n    {\n        assets[assetId].encodeAndSetSTKTerms(terms);\n        emit UpdatedTerms(assetId);\n    }\n\n    function getEnumValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (uint8)\n    {\n        return assets[assetId].decodeAndGetEnumValueForSTKAttribute(attribute);\n    }\n\n    function getAddressValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (address)\n    {\n        return assets[assetId].decodeAndGetAddressValueForForSTKAttribute(attribute);\n    }\n\n    function getBytes32ValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (bytes32)\n    {\n        return assets[assetId].decodeAndGetBytes32ValueForForSTKAttribute(attribute);\n    }\n\n    function getUIntValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (uint256)\n    {\n        return assets[assetId].decodeAndGetUIntValueForForSTKAttribute(attribute);\n    }\n\n    function getIntValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (int256)\n    {\n        return assets[assetId].decodeAndGetIntValueForForSTKAttribute(attribute);\n    }\n\n    function getPeriodValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (IP memory)\n    {\n        return assets[assetId].decodeAndGetPeriodValueForForSTKAttribute(attribute);\n    }\n\n    function getCycleValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (IPS memory)\n    {\n        return assets[assetId].decodeAndGetCycleValueForForSTKAttribute(attribute);\n    }\n\n    function getContractReferenceValueForTermsAttribute(bytes32 /* assetId */, bytes32 /* attribute */)\n        public\n        pure\n        override(ITermsRegistry, TermsRegistry)\n        returns (ContractReference memory)\n    {\n        return ContractReference(0, 0, ContractReferenceType(0), ContractReferenceRole(0));\n    }\n\n    function getNextComputedEvent(bytes32 assetId)\n        internal\n        view\n        override(TermsRegistry)\n        returns (bytes32, bool)\n    {\n        Asset storage asset = assets[assetId];\n        STKTerms memory terms = asset.decodeAndGetSTKTerms();\n\n        EventType nextEventType;\n        uint256 nextScheduleTime;\n        bool isCyclicEvent = true;\n\n        // DIF\n        {\n            (EventType eventType, uint256 scheduleTime) = decodeEvent(ISTKEngine(asset.engine).computeNextCyclicEvent(\n                terms,\n                asset.schedule.lastScheduleTimeOfCyclicEvent[EventType.DIF],\n                EventType.DIF\n            ));\n\n            if (\n                (nextScheduleTime == 0)\n                || (scheduleTime < nextScheduleTime)\n                || (nextScheduleTime == scheduleTime && getEpochOffset(eventType) < getEpochOffset(nextEventType))\n            ) {\n                nextScheduleTime = scheduleTime;\n                nextEventType = eventType;\n            }\n        }\n\n        // Non-Cyclic\n        {\n            (EventType eventType, uint256 scheduleTime) = decodeEvent(ISTKEngine(asset.engine).computeNextNonCyclicEvent(\n                terms,\n                asset.schedule.lastNonCyclicEvent\n            ));\n\n            if (\n                (nextScheduleTime == 0)\n                || (scheduleTime != 0 && scheduleTime < nextScheduleTime)\n                || (scheduleTime != 0 && nextScheduleTime == scheduleTime && getEpochOffset(eventType) < getEpochOffset(nextEventType))\n            ) {\n                nextScheduleTime = scheduleTime;\n                nextEventType = eventType;\n                isCyclicEvent = false;\n            }        \n        }\n\n        return (encodeEvent(nextEventType, nextScheduleTime), isCyclicEvent);\n    }\n}\n"
    },
    "contracts/ACTUS/Engines/STK/ISTKEngine.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../Core/ACTUSTypes.sol\";\nimport \"../IEngine.sol\";\n\n\n/**\n * @title IEngine\n * @notice Interface which all Engines have to implement\n */\ninterface ISTKEngine is IEngine {\n\n    /**\n     * @notice Initialize contract state space based on the contract terms.\n     * @param terms terms of the contract\n     * @return initial state of the contract\n     */\n    function computeInitialState(STKTerms calldata terms)\n        external\n        pure\n        returns (State memory);\n\n    /**\n     * Apply an event to the current state of a contract and returns the resulting contract state.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event to be applied to the contract state\n     * @param externalData external data needed for STF evaluation (e.g. rate for RR events)\n     * @return the resulting contract state\n     */\n    function computeStateForEvent(\n        STKTerms calldata terms,\n        State calldata state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        external\n        pure\n        returns (State memory);\n\n    /**\n     * Evaluates the payoff for an event under the current state of the contract.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which the payoff should be evaluated\n     * @param externalData external data needed for POF evaluation (e.g. fxRate)\n     * @return the payoff of the event\n     */\n    function computePayoffForEvent(\n        STKTerms calldata terms,\n        State calldata state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        external\n        pure\n        returns (int256);\n\n    /**\n     * @notice Computes a schedule segment of non-cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @return segment of the non-cyclic schedule\n     */\n    function computeNonCyclicScheduleSegment(\n        STKTerms calldata terms,\n        uint256 segmentStart,\n        uint256 segmentEnd\n    )\n        external\n        pure\n        returns (bytes32[] memory);\n\n    /**\n     * @notice Computes a schedule segment of cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segment\n     * @param eventType eventType of the cyclic schedule\n     * @return event schedule segment\n     */\n    function computeCyclicScheduleSegment(\n        STKTerms calldata terms,\n        uint256 segmentStart,\n        uint256 segmentEnd,\n        EventType eventType\n    )\n        external\n        pure\n        returns (bytes32[] memory);\n\n    /**\n     * @notice Computes the next non-cyclic contract events based on the contract terms\n     * and the timestamp on which the prev. event occured.\n     * @dev Assumes that non-cyclic events of the same event type have a unique schedule time\n     * @param terms terms of the contract\n     * @param lastNonCyclicEvent last non-cyclic event\n     * @return next non-cyclic event\n     */\n    function computeNextNonCyclicEvent(\n        STKTerms calldata terms,\n        bytes32 lastNonCyclicEvent\n    )\n        external\n        pure\n        returns (bytes32);\n\n    /**\n     * @notice Computes a schedule segment of cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param lastScheduleTime last occurrence of cyclic event\n     * @param eventType eventType of the cyclic schedule\n     * @return event schedule segment\n     */\n    function computeNextCyclicEvent(\n        STKTerms calldata terms,\n        uint256 lastScheduleTime,\n        EventType eventType\n    )\n        external\n        pure\n        returns(bytes32);\n\n    /**\n     * @notice Verifies that the provided event is still scheduled under the terms, the current state of the\n     * contract and the current state of the underlying.\n     * @param _event event for which to check if its still scheduled\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param hasUnderlying boolean indicating whether the contract has an underlying contract\n     * @param underlyingState state of the underlying (empty state object if non-existing)\n     * @return boolean indicating whether event is still scheduled\n     */\n    function isEventScheduled(\n        bytes32 _event,\n        STKTerms calldata terms,\n        State calldata state,\n        bool hasUnderlying,\n        State calldata underlyingState\n    )\n        external\n        pure\n        returns (bool);\n}\n"
    },
    "contracts/Core/Base/AssetRegistry/BaseRegistry.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../SharedTypes.sol\";\n\nimport \"./BaseRegistryStorage.sol\";\nimport \"./IBaseRegistry.sol\";\nimport \"./Ownership/OwnershipRegistry.sol\";\nimport \"./Terms/TermsRegistry.sol\";\nimport \"./State/StateRegistry.sol\";\nimport \"./State/StateEncoder.sol\";\nimport \"./Schedule/ScheduleRegistry.sol\";\nimport \"./Schedule/ScheduleEncoder.sol\";\n\n\n/**\n * @title BaseRegistry\n * @notice Registry for ACTUS Protocol assets\n */\nabstract contract BaseRegistry is\n    Ownable,\n    BaseRegistryStorage,\n    TermsRegistry,\n    StateRegistry,\n    ScheduleRegistry,\n    OwnershipRegistry,\n    IBaseRegistry\n{\n    using StateEncoder for Asset;\n    using ScheduleEncoder for Asset;\n\n    event RegisteredAsset(bytes32 assetId);\n    event UpdatedEngine(bytes32 indexed assetId, address prevEngine, address newEngine);\n    event UpdatedActor(bytes32 indexed assetId, address prevActor, address newActor);\n\n    mapping(address => bool) public approvedActors;\n\n\n    modifier onlyApprovedActors {\n        require(\n            approvedActors[msg.sender],\n            \"BaseRegistry.onlyApprovedActors: UNAUTHORIZED_SENDER\"\n        );\n        _;\n    }\n\n    constructor() BaseRegistryStorage() {}\n\n    /**\n     * @notice Approves the address of an actor contract e.g. for registering assets.\n     * @dev Can only be called by the owner of the contract.\n     * @param actor address of the actor\n     */\n    function approveActor(address actor) external onlyOwner {\n        approvedActors[actor] = true;\n    }\n\n    /**\n     * @notice Returns if there is an asset registerd for a given assetId\n     * @param assetId id of the asset\n     * @return true if asset exist\n     */\n    function isRegistered(bytes32 assetId)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return assets[assetId].isSet;\n    }\n\n    /**\n     * @notice Stores the addresses of the owners (owner of creator-side payment obligations,\n     * owner of creator-side payment claims), the initial state of an asset, the schedule of the asset\n     * and sets the address of the actor (address of account which is allowed to update the state).\n     * @dev The state of the asset can only be updates by a whitelisted actor.\n     * @param assetId id of the asset\n     * @param state initial state of the asset\n     * @param schedule schedule of the asset\n     * @param ownership ownership of the asset\n     * @param engine ACTUS Engine of the asset\n     * @param actor account which is allowed to update the asset state\n     * @param admin account which as admin rights (optional)\n     */\n    function setAsset(\n        bytes32 assetId,\n        State memory state,\n        bytes32[] memory schedule,\n        AssetOwnership memory ownership,\n        address engine,\n        address actor,\n        address admin\n    )\n        internal\n    {\n        Asset storage asset = assets[assetId];\n\n        // revert if an asset with the specified assetId already exists\n        require(\n            asset.isSet == false,\n            \"BaseRegistry.setAsset: ASSET_ALREADY_EXISTS\"\n        );\n        // revert if specified address of the actor is not approved\n        require(\n            approvedActors[actor] == true,\n            \"BaseRegistry.setAsset: ACTOR_NOT_APPROVED\"\n        );\n\n        asset.isSet = true;\n        asset.ownership = ownership;\n        asset.engine = engine;\n        asset.actor = actor;\n\n        asset.encodeAndSetState(state);\n        asset.encodeAndSetFinalizedState(state);\n        asset.encodeAndSetSchedule(schedule);\n\n        // set external admin if specified\n        if (admin != address(0)) setDefaultRoot(assetId, admin);\n\n        emit RegisteredAsset(assetId);\n    }\n\n    /**\n     * @notice Returns the address of a the ACTUS engine corresponding to the ContractType of an asset.\n     * @param assetId id of the asset\n     * @return address of the engine of the asset\n     */\n    function getEngine(bytes32 assetId)\n        external\n        view\n        override\n        returns (address)\n    {\n        return assets[assetId].engine;\n    }\n\n    /**\n     * @notice Returns the address of the actor which is allowed to update the state of the asset.\n     * @param assetId id of the asset\n     * @return address of the asset actor\n     */\n    function getActor(bytes32 assetId)\n        external\n        view\n        override\n        returns (address)\n    {\n        return assets[assetId].actor;\n    }\n\n    /**\n     * @notice Set the engine address which should be used for the asset going forward.\n     * @dev Can only be set by authorized account.\n     * @param assetId id of the asset\n     * @param engine new engine address\n     */\n    function setEngine(bytes32 assetId, address engine)\n        external\n        override\n        isAuthorized (assetId)\n    {\n        address prevEngine = assets[assetId].engine;\n        assets[assetId].engine = engine;\n\n        emit UpdatedEngine(assetId, prevEngine, engine);\n    }\n\n    /**\n     * @notice Set the address of the Actor contract which should be going forward.\n     * @param assetId id of the asset\n     * @param actor address of the Actor contract\n     */\n    function setActor(bytes32 assetId, address actor)\n        external\n        override\n        isAuthorized (assetId)\n    {\n        address prevActor = assets[assetId].actor;\n        assets[assetId].actor = actor;\n\n        emit UpdatedActor(assetId, prevActor, actor);\n    }\n}\n"
    },
    "contracts/Core/STK/STKEncoder.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../Base/SharedTypes.sol\";\nimport \"../Base/AssetRegistry/BaseRegistryStorage.sol\";\n\n\nlibrary STKEncoder {\n\n    function storeInPackedTerms(Asset storage asset, bytes32 attributeKey, bytes32 value) private {\n        // skip if value did not change\n        if (asset.packedTerms[attributeKey] == value) return;\n        asset.packedTerms[attributeKey] = value;\n    }\n\n    /**\n     * @dev Tightly pack and store only non-zero overwritten terms (LifecycleTerms)\n     * @notice All non zero values of the overwrittenTerms object are stored.\n     * It does not check if overwrittenAttributesMap actually marks attribute as overwritten.\n     */\n    function encodeAndSetSTKTerms(Asset storage asset, STKTerms memory terms) external {\n        storeInPackedTerms(\n            asset,\n            \"enums\",\n            bytes32(uint256(uint8(terms.contractType))) << 248 |\n            bytes32(uint256(uint8(terms.calendar))) << 240 |\n            bytes32(uint256(uint8(terms.contractRole))) << 232 |\n            bytes32(uint256(uint8(terms.dayCountConvention))) << 224 |\n            bytes32(uint256(uint8(terms.businessDayConvention))) << 216 |\n            bytes32(uint256(uint8(terms.endOfMonthConvention))) << 208 |\n            bytes32(uint256(uint8(terms.redeemableByIssuer))) << 200\n        );\n\n        storeInPackedTerms(asset, \"currency\", bytes32(uint256(terms.currency) << 96));\n        storeInPackedTerms(asset, \"settlementCurrency\", bytes32(uint256(terms.settlementCurrency) << 96));\n\n        storeInPackedTerms(asset, \"statusDate\", bytes32(terms.statusDate));\n        storeInPackedTerms(asset, \"issueDate\", bytes32(terms.issueDate));\n        storeInPackedTerms(asset, \"purchaseDate\", bytes32(terms.purchaseDate));\n        storeInPackedTerms(asset, \"cycleAnchorDateOfDividend\", bytes32(terms.cycleAnchorDateOfDividend));\n\n        storeInPackedTerms(asset, \"nominalPrice\", bytes32(terms.nominalPrice));\n        storeInPackedTerms(asset, \"notionalPrincipal\", bytes32(terms.notionalPrincipal));\n        storeInPackedTerms(asset, \"issuePrice\", bytes32(terms.issuePrice));\n        storeInPackedTerms(asset, \"quantity\", bytes32(terms.quantity));\n        storeInPackedTerms(asset, \"priceAtPurchaseDate\", bytes32(terms.priceAtPurchaseDate));\n        storeInPackedTerms(asset, \"priceAtTerminationDate\", bytes32(terms.priceAtTerminationDate));\n        storeInPackedTerms(asset, \"redemptionPrice\", bytes32(terms.redemptionPrice));\n\n        storeInPackedTerms(\n            asset,\n            \"dividendRecordPeriod\",\n            bytes32(uint256(terms.dividendRecordPeriod.i)) << 24 |\n            bytes32(uint256(terms.dividendRecordPeriod.p)) << 16 |\n            bytes32(uint256((terms.dividendRecordPeriod.isSet) ? 1 : 0)) << 8\n        );\n        storeInPackedTerms(\n            asset,\n            \"dividendPaymentPeriod\",\n            bytes32(uint256(terms.dividendPaymentPeriod.i)) << 24 |\n            bytes32(uint256(terms.dividendPaymentPeriod.p)) << 16 |\n            bytes32(uint256((terms.dividendPaymentPeriod.isSet) ? 1 : 0)) << 8\n        );\n        storeInPackedTerms(\n            asset,\n            \"splitSettlementPeriod\",\n            bytes32(uint256(terms.splitSettlementPeriod.i)) << 24 |\n            bytes32(uint256(terms.splitSettlementPeriod.p)) << 16 |\n            bytes32(uint256((terms.splitSettlementPeriod.isSet) ? 1 : 0)) << 8\n        );\n        storeInPackedTerms(\n            asset,\n            \"redemptionRecordPeriod\",\n            bytes32(uint256(terms.redemptionRecordPeriod.i)) << 24 |\n            bytes32(uint256(terms.redemptionRecordPeriod.p)) << 16 |\n            bytes32(uint256((terms.redemptionRecordPeriod.isSet) ? 1 : 0)) << 8\n        );\n        storeInPackedTerms(\n            asset,\n            \"redemptionPaymentPeriod\",\n            bytes32(uint256(terms.redemptionPaymentPeriod.i)) << 24 |\n            bytes32(uint256(terms.redemptionPaymentPeriod.p)) << 16 |\n            bytes32(uint256((terms.redemptionPaymentPeriod.isSet) ? 1 : 0)) << 8\n        );\n        storeInPackedTerms(\n            asset,\n            \"cycleOfDividend\",\n            bytes32(uint256(terms.cycleOfDividend.i)) << 24 |\n            bytes32(uint256(terms.cycleOfDividend.p)) << 16 |\n            bytes32(uint256(terms.cycleOfDividend.s)) << 8 |\n            bytes32(uint256((terms.cycleOfDividend.isSet) ? 1 : 0))\n        );\n    }\n\n    /**\n     * @dev Decode and loads STKTerms\n     */\n    function decodeAndGetSTKTerms(Asset storage asset) external view returns (STKTerms memory) {\n        return STKTerms(\n            ContractType(uint8(uint256(asset.packedTerms[\"enums\"] >> 248))),\n            Calendar(uint8(uint256(asset.packedTerms[\"enums\"] >> 240))),\n            ContractRole(uint8(uint256(asset.packedTerms[\"enums\"] >> 232))),\n            DayCountConvention(uint8(uint256(asset.packedTerms[\"enums\"] >> 224))),\n            BusinessDayConvention(uint8(uint256(asset.packedTerms[\"enums\"] >> 216))),\n            EndOfMonthConvention(uint8(uint256(asset.packedTerms[\"enums\"] >> 208))),\n            RedeemableByIssuer(uint8(uint256(asset.packedTerms[\"enums\"] >> 200))),\n\n            address(uint160(uint256(asset.packedTerms[\"currency\"]) >> 96)),\n            address(uint160(uint256(asset.packedTerms[\"settlementCurrency\"]) >> 96)),\n\n            uint256(asset.packedTerms[\"statusDate\"]),\n            uint256(asset.packedTerms[\"issueDate\"]),\n            uint256(asset.packedTerms[\"purchaseDate\"]),\n            uint256(asset.packedTerms[\"cycleAnchorDateOfDividend\"]),\n\n            int256(asset.packedTerms[\"nominalPrice\"]),\n            int256(asset.packedTerms[\"notionalPrincipal\"]),\n            int256(asset.packedTerms[\"issuePrice\"]),\n            int256(asset.packedTerms[\"quantity\"]),\n            int256(asset.packedTerms[\"priceAtPurchaseDate\"]),\n            int256(asset.packedTerms[\"priceAtTerminationDate\"]),\n            int256(asset.packedTerms[\"redemptionPrice\"]),\n\n            IP(\n                uint256(asset.packedTerms[\"dividendRecordPeriod\"] >> 24),\n                P(uint8(uint256(asset.packedTerms[\"dividendRecordPeriod\"] >> 16))),\n                (asset.packedTerms[\"dividendRecordPeriod\"] >> 8 & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            ),\n            IP(\n                uint256(asset.packedTerms[\"dividendPaymentPeriod\"] >> 24),\n                P(uint8(uint256(asset.packedTerms[\"dividendPaymentPeriod\"] >> 16))),\n                (asset.packedTerms[\"dividendPaymentPeriod\"] >> 8 & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            ),\n            IP(\n                uint256(asset.packedTerms[\"splitSettlementPeriod\"] >> 24),\n                P(uint8(uint256(asset.packedTerms[\"splitSettlementPeriod\"] >> 16))),\n                (asset.packedTerms[\"splitSettlementPeriod\"] >> 8 & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            ),\n            IP(\n                uint256(asset.packedTerms[\"redemptionRecordPeriod\"] >> 24),\n                P(uint8(uint256(asset.packedTerms[\"redemptionRecordPeriod\"] >> 16))),\n                (asset.packedTerms[\"redemptionRecordPeriod\"] >> 8 & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            ),\n            IP(\n                uint256(asset.packedTerms[\"redemptionPaymentPeriod\"] >> 24),\n                P(uint8(uint256(asset.packedTerms[\"redemptionPaymentPeriod\"] >> 16))),\n                (asset.packedTerms[\"redemptionPaymentPeriod\"] >> 8 & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            ),\n            IPS(\n                uint256(asset.packedTerms[\"cycleOfDividend\"] >> 24),\n                P(uint8(uint256(asset.packedTerms[\"cycleOfDividend\"] >> 16))),\n                S(uint8(uint256(asset.packedTerms[\"cycleOfDividend\"] >> 8))),\n                (asset.packedTerms[\"cycleOfDividend\"] & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            )\n        );\n    }\n\n    function decodeAndGetEnumValueForSTKAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (uint8)\n    {\n        if (attributeKey == bytes32(\"contractType\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 248));\n        } else if (attributeKey == bytes32(\"calendar\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 240));\n        } else if (attributeKey == bytes32(\"contractRole\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 232));\n        } else if (attributeKey == bytes32(\"dayCountConvention\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 224));\n        } else if (attributeKey == bytes32(\"businessDayConvention\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 216));\n        } else if (attributeKey == bytes32(\"endOfMonthConvention\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 208));\n        } else if (attributeKey == bytes32(\"redeemableByIssuer\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 200));\n        } else {\n            return uint8(0);\n        }\n    }\n\n    function decodeAndGetAddressValueForForSTKAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (address)\n    {\n        if (attributeKey == bytes32(\"currency\")) {\n            return address(uint160(uint256(asset.packedTerms[\"currency\"]) >> 96));\n        } else if (attributeKey == bytes32(\"settlementCurrency\")) {\n            return address(uint160(uint256(asset.packedTerms[\"settlementCurrency\"]) >> 96));\n        } else {\n            return address(0);\n        }\n    }\n\n    function decodeAndGetBytes32ValueForForSTKAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (bytes32)\n    {\n        return asset.packedTerms[attributeKey];\n    }\n\n    function decodeAndGetUIntValueForForSTKAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (uint256)\n    {\n        return uint256(asset.packedTerms[attributeKey]);\n    }\n\n    function decodeAndGetIntValueForForSTKAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (int256)\n    {\n        return int256(asset.packedTerms[attributeKey]);\n    }\n\n    function decodeAndGetPeriodValueForForSTKAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (IP memory)\n    {\n        if (\n            attributeKey == bytes32(\"dividendRecordPeriod\")\n            || attributeKey == bytes32(\"dividendPaymentPeriod\")\n            || attributeKey == bytes32(\"splitSettlementPeriod\")\n            || attributeKey == bytes32(\"redemptionRecordPeriod\")\n            || attributeKey == bytes32(\"redemptionPaymentPeriod\")\n        ) {\n            return IP(\n                uint256(asset.packedTerms[attributeKey] >> 24),\n                P(uint8(uint256(asset.packedTerms[attributeKey] >> 16))),\n                (asset.packedTerms[attributeKey] >> 8 & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            );\n        } else {\n            return IP(0, P(0), false);\n        }\n    }\n\n    function decodeAndGetCycleValueForForSTKAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (IPS memory)\n    {\n        if ( attributeKey == bytes32(\"cycleOfDividend\") ) {\n            return IPS(\n                uint256(asset.packedTerms[attributeKey] >> 24),\n                P(uint8(uint256(asset.packedTerms[attributeKey] >> 16))),\n                S(uint8(uint256(asset.packedTerms[attributeKey] >> 8))),\n                (asset.packedTerms[attributeKey] & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            );\n        } else {\n            return IPS(0, P(0), S(0), false);\n        }\n    }\n}\n"
    },
    "contracts/Core/STK/ISTKRegistry.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../Base/SharedTypes.sol\";\nimport \"../Base/AssetRegistry/IAssetRegistry.sol\";\n\n\ninterface ISTKRegistry is IAssetRegistry {\n\n    function registerAsset(\n        bytes32 assetId,\n        STKTerms calldata terms,\n        State calldata state,\n        bytes32[] calldata schedule,\n        AssetOwnership calldata ownership,\n        address engine,\n        address actor,\n        address admin\n    )\n        external;\n    \n    function getTerms(bytes32 assetId)\n        external\n        view\n        returns (STKTerms memory);\n\n    function setTerms(bytes32 assetId, STKTerms calldata terms)\n        external;\n}\n"
    },
    "contracts/ACTUS/Engines/IEngine.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\n\nimport \"../Core/ACTUSTypes.sol\";\n\n\ninterface IEngine {\n    function contractType() external pure returns (ContractType);\n}"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/Core/Base/AssetRegistry/BaseRegistryStorage.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../Conversions.sol\";\nimport \"../SharedTypes.sol\";\nimport \"./State/StateEncoder.sol\";\nimport \"./Schedule/ScheduleEncoder.sol\";\n\n\nstruct Settlement {\n    bool isSettled;\n    int256 payoff;\n}\n\nstruct Asset {\n    // boolean indicating that asset exists / is registered\n    bool isSet;\n    // address of the ACTUS Engine used for computing the State and the Payoff of the asset\n    address engine;\n    // address of the Asset Actor which is allowed to update the State of the asset\n    address actor;\n    // schedule of the asset\n    Schedule schedule;\n    // ownership of the asset\n    AssetOwnership ownership;\n    // granular ownership of the event type specific cashflows\n    // per default owners are beneficiaries defined in ownership object\n    // cashflow id (:= (EventType index + 1) * direction) => owner\n    mapping (int8 => address) cashflowBeneficiaries;\n    // method level access control - stores which address can a specific method\n    // method signature => address => has access\n    mapping (bytes4 => mapping (address => bool)) access;\n    // tightly packed, encoded Terms and State values of the asset\n    // bytes32(0) used as default value for each attribute\n    // storage id => bytes32 encoded value\n    mapping (bytes32 => bytes32) packedTerms;\n    // tightly packed, encoded Terms and State values of the asset\n    // bytes32(0) used as default value for each attribute\n    // storage id => bytes32 encoded value\n    mapping (bytes32 => bytes32) packedState;\n    // indicates whether a specific event was settled\n    mapping (bytes32 => Settlement) settlement;\n}\n\n/**\n * @title BaseRegistryStorage\n * @notice Describes the storage of the AssetRegistry\n * Contains getter and setter methods for encoding, decoding data to optimize gas cost.\n * Circumvents storing default values by relying on the characteristic of mappings returning zero for not set values.\n */\nabstract contract BaseRegistryStorage {\n\n    using StateEncoder for Asset;\n    using ScheduleEncoder for Asset;\n\n    // AssetId => Asset\n    mapping (bytes32 => Asset) internal assets;\n}\n"
    },
    "contracts/Core/Base/AssetRegistry/IBaseRegistry.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\n\ninterface IBaseRegistry {\n\n    function isRegistered(bytes32 assetId)\n        external\n        view\n        returns (bool);\n\n    function getEngine(bytes32 assetId)\n        external\n        view\n        returns (address);\n\n    function getActor(bytes32 assetId)\n        external\n        view\n        returns (address);\n\n    function setEngine(bytes32 assetId, address engine)\n        external;\n\n    function setActor(bytes32 assetId, address actor)\n        external;\n}\n"
    },
    "contracts/Core/Base/AssetRegistry/Ownership/OwnershipRegistry.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../BaseRegistryStorage.sol\";\nimport \"../AccessControl/AccessControl.sol\";\nimport \"./IOwnershipRegistry.sol\";\n\n\n/**\n * @title OwnershipRegistry\n */\ncontract OwnershipRegistry is BaseRegistryStorage, AccessControl, IOwnershipRegistry {\n\n    event UpdatedObligor (bytes32 assetId, address prevObligor, address newObligor);\n    event UpdatedBeneficiary(bytes32 assetId, address prevBeneficiary, address newBeneficiary);\n\n\n    /**\n     * @notice Update the address of the default beneficiary of cashflows going to the creator.\n     * @dev Can only be updated by the current creator beneficiary or by an authorized account.\n     * @param assetId id of the asset\n     * @param newCreatorBeneficiary address of the new beneficiary\n     */\n    function setCreatorBeneficiary(\n        bytes32 assetId,\n        address newCreatorBeneficiary\n    )\n        external\n        override\n    {\n        address prevCreatorBeneficiary = assets[assetId].ownership.creatorBeneficiary;\n\n        require(\n            prevCreatorBeneficiary != address(0),\n            \"AssetRegistry.setCreatorBeneficiary: ENTRY_DOES_NOT_EXIST\"\n        );\n        require(\n            msg.sender == prevCreatorBeneficiary || hasAccess(assetId, msg.sig, msg.sender),\n            \"AssetRegistry.setCreatorBeneficiary: UNAUTHORIZED_SENDER\"\n        );\n\n        assets[assetId].ownership.creatorBeneficiary = newCreatorBeneficiary;\n\n        emit UpdatedBeneficiary(assetId, prevCreatorBeneficiary, newCreatorBeneficiary);\n    }\n\n    /**\n     * @notice Updates the address of the default beneficiary of cashflows going to the counterparty.\n     * @dev Can only be updated by the current counterparty beneficiary or by an authorized account.\n     * @param assetId id of the asset\n     * @param newCounterpartyBeneficiary address of the new beneficiary\n     */\n    function setCounterpartyBeneficiary(\n        bytes32 assetId,\n        address newCounterpartyBeneficiary\n    )\n        external\n        override\n    {\n        address prevCounterpartyBeneficiary = assets[assetId].ownership.counterpartyBeneficiary;\n\n        require(\n            prevCounterpartyBeneficiary != address(0),\n            \"AssetRegistry.setCounterpartyBeneficiary: ENTRY_DOES_NOT_EXIST\"\n        );\n        require(\n            msg.sender == prevCounterpartyBeneficiary || hasAccess(assetId, msg.sig, msg.sender),\n            \"AssetRegistry.setCounterpartyBeneficiary: UNAUTHORIZED_SENDER\"\n        );\n\n        assets[assetId].ownership.counterpartyBeneficiary = newCounterpartyBeneficiary;\n\n        emit UpdatedBeneficiary(assetId, prevCounterpartyBeneficiary, newCounterpartyBeneficiary);\n    }\n\n    /**\n     * @notice Update the address of the obligor which has to fulfill obligations\n     * for the creator of the asset.\n     * @dev Can only be updated by an authorized account.\n     * @param assetId id of the asset\n     * @param newCreatorObligor address of the new creator obligor\n     */\n    function setCreatorObligor (bytes32 assetId, address newCreatorObligor)\n        external\n        override\n    {\n        require(\n            hasAccess(assetId, msg.sig, msg.sender),\n            \"AssetRegistry.setCreatorObligor: UNAUTHORIZED_SENDER\"\n        );\n\n        address prevCreatorObligor = assets[assetId].ownership.creatorObligor;\n\n        assets[assetId].ownership.creatorObligor = newCreatorObligor;\n\n        emit UpdatedObligor(assetId, prevCreatorObligor, newCreatorObligor);\n    }\n\n    /**\n     * @notice Update the address of the counterparty which has to fulfill obligations\n     * for the counterparty of the asset.\n     * @dev Can only be updated by an authorized account.\n     * @param assetId id of the asset\n     * @param newCounterpartyObligor address of the new counterparty obligor\n     */\n    function setCounterpartyObligor (bytes32 assetId, address newCounterpartyObligor)\n        external\n        override\n    {\n        require(\n            hasAccess(assetId, msg.sig, msg.sender),\n            \"AssetRegistry.setCounterpartyObligor: UNAUTHORIZED_SENDER\"\n        );\n\n        address prevCounterpartyObligor = assets[assetId].ownership.counterpartyObligor;\n\n        assets[assetId].ownership.counterpartyObligor = newCounterpartyObligor;\n\n        emit UpdatedObligor(assetId, prevCounterpartyObligor, newCounterpartyObligor);\n    }\n\n    /**\n     * @notice Retrieves the registered addresses of owners (creator, counterparty) of an asset.\n     * @param assetId id of the asset\n     * @return addresses of all owners of the asset\n     */\n    function getOwnership(bytes32 assetId)\n        external\n        view\n        override\n        returns (AssetOwnership memory)\n    {\n        return assets[assetId].ownership;\n    }\n}\n"
    },
    "contracts/Core/Base/AssetRegistry/Terms/TermsRegistry.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../SharedTypes.sol\";\n\n\nabstract contract TermsRegistry {\n\n    event UpdatedTerms(bytes32 indexed assetId);\n\n\n    function getEnumValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        virtual\n        returns (uint8);\n\n    function getAddressValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        virtual\n        returns (address);\n\n    function getBytes32ValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        virtual\n        returns (bytes32);\n\n    function getUIntValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        virtual\n        returns (uint256);\n\n    function getIntValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        virtual\n        returns (int256);\n\n    function getPeriodValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        virtual\n        returns (IP memory);\n\n    function getCycleValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        virtual\n        returns (IPS memory);\n\n    function getContractReferenceValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        virtual\n        returns (ContractReference memory);\n\n    function getNextComputedEvent(bytes32 assetId)\n        internal\n        view\n        virtual\n        returns (bytes32, bool);\n}\n"
    },
    "contracts/Core/Base/AssetRegistry/State/StateRegistry.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../BaseRegistryStorage.sol\";\nimport \"../AccessControl/AccessControl.sol\";\nimport \"./IStateRegistry.sol\";\nimport \"./StateEncoder.sol\";\n\n\n/**\n * @title StateRegistry\n */\ncontract StateRegistry is BaseRegistryStorage, AccessControl, IStateRegistry {\n\n    using StateEncoder for Asset;\n\n    event UpdatedState(bytes32 indexed assetId, uint256 statusDate);\n    event UpdatedFinalizedState(bytes32 indexed assetId, uint256 statusDate);\n\n\n    /**\n     * @notice Returns the state of an asset.\n     * @param assetId id of the asset\n     * @return state of the asset\n     */\n    function getState(bytes32 assetId)\n        external\n        view\n        override\n        returns (State memory)\n    {\n        return assets[assetId].decodeAndGetState();\n    }\n\n    /**\n     * @notice Returns the state of an asset.\n     * @param assetId id of the asset\n     * @return state of the asset\n     */\n    function getFinalizedState(bytes32 assetId)\n        external\n        view\n        override\n        returns (State memory)\n    {\n        return assets[assetId].decodeAndGetFinalizedState();\n    }\n\n    function getEnumValueForStateAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override\n        returns (uint8)\n    {\n        return assets[assetId].decodeAndGetEnumValueForStateAttribute(attribute);\n    }\n\n    function getIntValueForStateAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override\n        returns (int256)\n    {\n        return assets[assetId].decodeAndGetIntValueForForStateAttribute(attribute);\n    }\n\n    function getUintValueForStateAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return assets[assetId].decodeAndGetUIntValueForForStateAttribute(attribute);\n    }\n\n    /**\n     * @notice Sets next state of an asset.\n     * @dev Can only be updated by the assets actor or by an authorized account.\n     * @param assetId id of the asset\n     * @param state next state of the asset\n     */\n    function setState(bytes32 assetId, State calldata state)\n        external\n        override\n        isAuthorized (assetId)\n    {\n        assets[assetId].encodeAndSetState(state);\n        emit UpdatedState(assetId, state.statusDate);\n    }\n\n    /**\n     * @notice Sets next finalized state of an asset.\n     * @dev Can only be updated by the assets actor or by an authorized account.\n     * @param assetId id of the asset\n     * @param state next state of the asset\n     */\n    function setFinalizedState(bytes32 assetId, State calldata state)\n        external\n        override\n        isAuthorized (assetId)\n    {\n        assets[assetId].encodeAndSetFinalizedState(state);\n        emit UpdatedFinalizedState(assetId, state.statusDate);\n    }\n}\n"
    },
    "contracts/Core/Base/AssetRegistry/State/StateEncoder.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\n\nimport \"../../SharedTypes.sol\";\nimport \"../BaseRegistryStorage.sol\";\n\n\nlibrary StateEncoder {\n\n    function storeInPackedState(Asset storage asset, bytes32 attributeKey, bytes32 value) private {\n        // skip if value did not change\n        if (asset.packedState[attributeKey] == value) return;\n        asset.packedState[attributeKey] = value;\n    }\n\n    /**\n     * @dev Tightly pack and store State\n     */\n    function encodeAndSetState(Asset storage asset, State memory state) internal {\n        storeInPackedState(asset, \"contractPerformance\", bytes32(uint256(uint8(state.contractPerformance))) << 248);\n        storeInPackedState(asset, \"statusDate\", bytes32(state.statusDate));\n        storeInPackedState(asset, \"nonPerformingDate\", bytes32(state.nonPerformingDate));\n        storeInPackedState(asset, \"maturityDate\", bytes32(state.maturityDate));\n        storeInPackedState(asset, \"exerciseDate\", bytes32(state.exerciseDate));\n        storeInPackedState(asset, \"terminationDate\", bytes32(state.terminationDate));\n        storeInPackedState(asset, \"lastCouponFixingDate\", bytes32(state.lastCouponFixingDate));\n        storeInPackedState(asset, \"lastDividendFixingDate\", bytes32(state.lastDividendFixingDate));\n\n        storeInPackedState(asset, \"notionalPrincipal\", bytes32(state.notionalPrincipal));\n        storeInPackedState(asset, \"accruedInterest\", bytes32(state.accruedInterest));\n        storeInPackedState(asset, \"feeAccrued\", bytes32(state.feeAccrued));\n        storeInPackedState(asset, \"nominalInterestRate\", bytes32(state.nominalInterestRate));\n        storeInPackedState(asset, \"interestScalingMultiplier\", bytes32(state.interestScalingMultiplier));\n        storeInPackedState(asset, \"notionalScalingMultiplier\", bytes32(state.notionalScalingMultiplier));\n        storeInPackedState(asset, \"nextPrincipalRedemptionPayment\", bytes32(state.nextPrincipalRedemptionPayment));\n        storeInPackedState(asset, \"exerciseAmount\", bytes32(state.exerciseAmount));\n        storeInPackedState(asset, \"exerciseQuantity\", bytes32(state.exerciseQuantity));\n\n        storeInPackedState(asset, \"exerciseQuantity\", bytes32(state.exerciseQuantity));\n        storeInPackedState(asset, \"quantity\", bytes32(state.quantity));\n        storeInPackedState(asset, \"couponAmountFixed\", bytes32(state.couponAmountFixed));\n        storeInPackedState(asset, \"marginFactor\", bytes32(state.marginFactor));\n        storeInPackedState(asset, \"adjustmentFactor\", bytes32(state.adjustmentFactor));\n        storeInPackedState(asset, \"dividendPaymentAmount\", bytes32(state.dividendPaymentAmount));\n        storeInPackedState(asset, \"splitRatio\", bytes32(state.splitRatio));\n    }\n\n    /**\n     * @dev Tightly pack and store finalized State\n     */\n    function encodeAndSetFinalizedState(Asset storage asset, State memory state) internal {\n        storeInPackedState(asset, \"F_contractPerformance\", bytes32(uint256(uint8(state.contractPerformance))) << 248);\n        storeInPackedState(asset, \"F_statusDate\", bytes32(state.statusDate));\n        storeInPackedState(asset, \"F_nonPerformingDate\", bytes32(state.nonPerformingDate));\n        storeInPackedState(asset, \"F_maturityDate\", bytes32(state.maturityDate));\n        storeInPackedState(asset, \"F_exerciseDate\", bytes32(state.exerciseDate));\n        storeInPackedState(asset, \"F_terminationDate\", bytes32(state.terminationDate));\n        storeInPackedState(asset, \"F_lastCouponFixingDate\", bytes32(state.lastCouponFixingDate));\n        storeInPackedState(asset, \"F_lastDividendFixingDate\", bytes32(state.lastDividendFixingDate));\n\n        storeInPackedState(asset, \"F_notionalPrincipal\", bytes32(state.notionalPrincipal));\n        storeInPackedState(asset, \"F_accruedInterest\", bytes32(state.accruedInterest));\n        storeInPackedState(asset, \"F_feeAccrued\", bytes32(state.feeAccrued));\n        storeInPackedState(asset, \"F_nominalInterestRate\", bytes32(state.nominalInterestRate));\n        storeInPackedState(asset, \"F_interestScalingMultiplier\", bytes32(state.interestScalingMultiplier));\n        storeInPackedState(asset, \"F_notionalScalingMultiplier\", bytes32(state.notionalScalingMultiplier));\n        storeInPackedState(asset, \"F_nextPrincipalRedemptionPayment\", bytes32(state.nextPrincipalRedemptionPayment));\n        storeInPackedState(asset, \"F_exerciseAmount\", bytes32(state.exerciseAmount));\n        storeInPackedState(asset, \"F_exerciseQuantity\", bytes32(state.exerciseQuantity));\n\n        storeInPackedState(asset, \"F_exerciseQuantity\", bytes32(state.exerciseQuantity));\n        storeInPackedState(asset, \"F_quantity\", bytes32(state.quantity));\n        storeInPackedState(asset, \"F_couponAmountFixed\", bytes32(state.couponAmountFixed));\n        storeInPackedState(asset, \"F_marginFactor\", bytes32(state.marginFactor));\n        storeInPackedState(asset, \"F_adjustmentFactor\", bytes32(state.adjustmentFactor));\n        storeInPackedState(asset, \"F_dividendPaymentAmount\", bytes32(state.dividendPaymentAmount));\n        storeInPackedState(asset, \"F_splitRatio\", bytes32(state.splitRatio));\n    }\n\n    /**\n     * @dev Decode and load the State of the asset\n     */\n    function decodeAndGetState(Asset storage asset) internal view returns (State memory) {\n        return State(\n            ContractPerformance(uint8(uint256(asset.packedState[\"contractPerformance\"] >> 248))),\n            uint256(asset.packedState[\"statusDate\"]),\n            uint256(asset.packedState[\"nonPerformingDate\"]),\n            uint256(asset.packedState[\"maturityDate\"]),\n            uint256(asset.packedState[\"exerciseDate\"]),\n            uint256(asset.packedState[\"terminationDate\"]),\n            uint256(asset.packedState[\"lastCouponFixingDate\"]),\n            uint256(asset.packedState[\"lastDividendFixingDate\"]),\n\n            int256(asset.packedState[\"notionalPrincipal\"]),\n            int256(asset.packedState[\"accruedInterest\"]),\n            int256(asset.packedState[\"feeAccrued\"]),\n            int256(asset.packedState[\"nominalInterestRate\"]),\n            int256(asset.packedState[\"interestScalingMultiplier\"]),\n            int256(asset.packedState[\"notionalScalingMultiplier\"]),\n            int256(asset.packedState[\"nextPrincipalRedemptionPayment\"]),\n            int256(asset.packedState[\"exerciseAmount\"]),\n            int256(asset.packedState[\"exerciseQuantity\"]),\n\n            int256(asset.packedState[\"quantity\"]),\n            int256(asset.packedState[\"couponAmountFixed\"]),\n            int256(asset.packedState[\"marginFactor\"]),\n            int256(asset.packedState[\"adjustmentFactor\"]),\n            int256(asset.packedState[\"dividendPaymentAmount\"]),\n            int256(asset.packedState[\"splitRatio\"])\n        );\n    }\n\n    /**\n     * @dev Decode and load the finalized State of the asset\n     */\n    function decodeAndGetFinalizedState(Asset storage asset) internal view returns (State memory) {\n        return State(\n            ContractPerformance(uint8(uint256(asset.packedState[\"F_contractPerformance\"] >> 248))),\n            uint256(asset.packedState[\"F_statusDate\"]),\n            uint256(asset.packedState[\"F_nonPerformingDate\"]),\n            uint256(asset.packedState[\"F_maturityDate\"]),\n            uint256(asset.packedState[\"F_exerciseDate\"]),\n            uint256(asset.packedState[\"F_terminationDate\"]),\n            uint256(asset.packedState[\"F_lastCouponFixingDate\"]),\n            uint256(asset.packedState[\"F_lastDividendFixingDate\"]),\n\n            int256(asset.packedState[\"F_notionalPrincipal\"]),\n            int256(asset.packedState[\"F_accruedInterest\"]),\n            int256(asset.packedState[\"F_feeAccrued\"]),\n            int256(asset.packedState[\"F_nominalInterestRate\"]),\n            int256(asset.packedState[\"F_interestScalingMultiplier\"]),\n            int256(asset.packedState[\"F_notionalScalingMultiplier\"]),\n            int256(asset.packedState[\"F_nextPrincipalRedemptionPayment\"]),\n            int256(asset.packedState[\"F_exerciseAmount\"]),\n            int256(asset.packedState[\"F_exerciseQuantity\"]),\n\n            int256(asset.packedState[\"F_quantity\"]),\n            int256(asset.packedState[\"F_couponAmountFixed\"]),\n            int256(asset.packedState[\"F_marginFactor\"]),\n            int256(asset.packedState[\"F_adjustmentFactor\"]),\n            int256(asset.packedState[\"F_dividendPaymentAmount\"]),\n            int256(asset.packedState[\"F_splitRatio\"])\n        );\n    }\n\n\n    function decodeAndGetEnumValueForStateAttribute(Asset storage asset, bytes32 attributeKey)\n        internal\n        view\n        returns (uint8)\n    {\n        if (attributeKey == bytes32(\"contractPerformance\")) {\n            return uint8(uint256(asset.packedState[\"contractPerformance\"] >> 248));\n        } else if (attributeKey == bytes32(\"F_contractPerformance\")) {\n            return uint8(uint256(asset.packedState[\"F_contractPerformance\"] >> 248));\n        } else {\n            return uint8(0);\n        }\n    }\n\n    function decodeAndGetUIntValueForForStateAttribute(Asset storage asset, bytes32 attributeKey)\n        internal\n        view\n        returns (uint256)\n    {\n        return uint256(asset.packedState[attributeKey]);\n    }\n\n    function decodeAndGetIntValueForForStateAttribute(Asset storage asset, bytes32 attributeKey)\n        internal\n        view\n        returns (int256)\n    {\n        return int256(asset.packedState[attributeKey]);\n    }\n}\n"
    },
    "contracts/Core/Base/AssetRegistry/Schedule/ScheduleRegistry.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../../../ACTUS/Core/Utils/EventUtils.sol\";\nimport \"../../../../ACTUS/Core/Utils/PeriodUtils.sol\";\n\nimport \"../BaseRegistryStorage.sol\";\nimport \"../IBaseRegistry.sol\";\nimport \"../AccessControl/AccessControl.sol\";\nimport \"../Terms/TermsRegistry.sol\";\nimport \"../Terms/ITermsRegistry.sol\";\nimport \"../State/StateRegistry.sol\";\nimport \"../State/IStateRegistry.sol\";\nimport \"./IScheduleRegistry.sol\";\nimport \"./ScheduleEncoder.sol\";\n\n\n/**\n * @title ScheduleRegistry\n */\nabstract contract ScheduleRegistry is\n    BaseRegistryStorage,\n    AccessControl,\n    TermsRegistry,\n    StateRegistry,\n    IScheduleRegistry,\n    EventUtils,\n    PeriodUtils\n{\n    using ScheduleEncoder for Asset;\n\n\n    /**\n     * @notice Returns an event for a given position (index) in a schedule of a given asset.\n     * @param assetId id of the asset\n     * @param index index of the event to return\n     * @return Event\n     */\n    function getEventAtIndex(bytes32 assetId, uint256 index)\n        external\n        view\n        override\n        returns (bytes32)\n    {\n        return assets[assetId].schedule.events[index];\n    }\n\n\n    /**\n     * @notice Returns the length of a schedule of a given asset.\n     * @param assetId id of the asset\n     * @return Length of the schedule\n     */\n    function getScheduleLength(bytes32 assetId)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return assets[assetId].schedule.length;\n    }\n\n    /**\n     * @notice Convenience method for retrieving the entire schedule\n     * Not recommended to execute method on-chain (if schedule is too long the tx may run out of gas)\n     * @param assetId id of the asset\n     * @return the schedule\n     */\n    function getSchedule(bytes32 assetId)\n        external\n        view\n        override\n        returns (bytes32[] memory)\n    {\n        return assets[assetId].decodeAndGetSchedule();\n    }\n\n    function getPendingEvent(bytes32 assetId)\n        external\n        view\n        override\n        returns (bytes32)\n    {\n        return assets[assetId].schedule.pendingEvent;\n    }\n\n    function pushPendingEvent(bytes32 assetId, bytes32 pendingEvent)\n        external\n        override\n        isAuthorized (assetId)\n    {\n        assets[assetId].schedule.pendingEvent = pendingEvent;\n    }\n\n    function popPendingEvent(bytes32 assetId)\n        external\n        override\n        isAuthorized (assetId)\n        returns (bytes32)\n    {\n        bytes32 pendingEvent = assets[assetId].schedule.pendingEvent;\n        assets[assetId].schedule.pendingEvent = bytes32(0);\n\n        return pendingEvent;\n    }\n\n    /**\n     * @notice Returns the index of the next event to be processed for a schedule of an asset.\n     * @param assetId id of the asset\n     * @return Index\n     */\n    function getNextScheduleIndex(bytes32 assetId)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return assets[assetId].schedule.nextScheduleIndex;\n    }\n\n    /**\n     * @notice If the underlying of the asset changes in performance to a covered performance,\n     * it returns the exerciseDate event.\n     */\n    function getNextUnderlyingEvent(bytes32 assetId)\n        external\n        view\n        override\n        returns (bytes32)\n    {\n        ContractReference memory contractReference_1 = getContractReferenceValueForTermsAttribute(assetId, \"contractReference_1\");\n\n        // check for COVE\n        if (contractReference_1.object != bytes32(0) && contractReference_1.role == ContractReferenceRole.COVE) {\n            bytes32 underlyingAssetId = contractReference_1.object;\n            address underlyingRegistry = address(uint160(uint256(contractReference_1.object2))); // workaround for solc bug (replace with bytes)\n\n            require(\n                IBaseRegistry(underlyingRegistry).isRegistered(underlyingAssetId),\n                \"AssetActor.getNextUnderlyingEvent: UNDERLYING_ASSET_DOES_NOT_EXIST\"\n            );\n\n            uint256 exerciseDate = getUintValueForStateAttribute(assetId, \"exerciseDate\");\n            ContractPerformance creditEventTypeCovered = ContractPerformance(getEnumValueForTermsAttribute(assetId, \"creditEventTypeCovered\"));\n            ContractPerformance underlyingContractPerformance = ContractPerformance(IStateRegistry(underlyingRegistry).getEnumValueForStateAttribute(underlyingAssetId, \"contractPerformance\"));\n            uint256 underlyingNonPerformingDate = IStateRegistry(underlyingRegistry).getUintValueForStateAttribute(underlyingAssetId, \"nonPerformingDate\");\n\n            // check if exerciseDate has been triggered\n            if (exerciseDate > 0) {\n                // insert SettlementDate event\n                return encodeEvent(\n                    EventType.ST,\n                    // solium-disable-next-line\n                    block.timestamp\n                );\n            }\n            // if not check if performance of underlying asset is covered by this asset (PF excluded)\n            if (\n                creditEventTypeCovered != ContractPerformance.PF\n                && underlyingContractPerformance == creditEventTypeCovered\n            ) {\n                // insert exerciseDate event\n                // derive scheduleTimeOffset from performance\n                if (underlyingContractPerformance == ContractPerformance.DL) {\n                    return encodeEvent(\n                        EventType.EXE,\n                        underlyingNonPerformingDate\n                    );\n                } else if (underlyingContractPerformance == ContractPerformance.DQ) {\n                    IP memory underlyingGracePeriod = ITermsRegistry(underlyingRegistry).getPeriodValueForTermsAttribute(underlyingAssetId, \"gracePeriod\");\n                    return encodeEvent(\n                        EventType.EXE,\n                        getTimestampPlusPeriod(underlyingGracePeriod, underlyingNonPerformingDate)\n                    );\n                } else if (underlyingContractPerformance == ContractPerformance.DF) {\n                    IP memory underlyingDelinquencyPeriod = ITermsRegistry(underlyingRegistry).getPeriodValueForTermsAttribute(underlyingAssetId, \"delinquencyPeriod\");\n                    return encodeEvent(\n                        EventType.EXE,\n                        getTimestampPlusPeriod(underlyingDelinquencyPeriod, underlyingNonPerformingDate)\n                    );\n                }\n            }\n        }\n\n        return bytes32(0);\n    }\n\n    /**\n     * @notice Returns the next event to process.\n     * @param assetId id of the asset\n     * @return event\n     */\n    function getNextScheduledEvent(bytes32 assetId)\n        external\n        view\n        override\n        returns (bytes32)\n    {\n        Asset storage asset = assets[assetId];\n\n        if (asset.schedule.length != 0) {\n            if (asset.schedule.nextScheduleIndex == asset.schedule.length) return bytes32(0);\n            return asset.schedule.events[asset.schedule.nextScheduleIndex];\n        }\n\n        // if no schedule is set, return next computed event\n        (bytes32 nextComputedEvent, ) = getNextComputedEvent(assetId);\n        return nextComputedEvent;\n    }\n\n    /**\n     * @notice Increments the index of a schedule of an asset.\n     * (if max index is reached the index will be left unchanged)\n     * @dev Can only be updated by the assets actor or by an authorized account.\n     * @param assetId id of the asset\n     */\n    function popNextScheduledEvent(bytes32 assetId)\n        external\n        override\n        isAuthorized (assetId)\n        returns (bytes32)\n    {\n        Asset storage asset = assets[assetId];\n\n        if (asset.schedule.length != 0) {\n            bytes32 nextScheduledEvent = asset.schedule.events[asset.schedule.nextScheduleIndex];\n            if (asset.schedule.nextScheduleIndex == asset.schedule.length) return bytes32(0);\n            asset.schedule.nextScheduleIndex += 1;\n            return nextScheduledEvent;\n        }\n\n        // if no schedule is set, pop next computed event\n        (bytes32 nextComputedEvent, bool isCyclicEvent) = getNextComputedEvent(assetId);\n        if (nextComputedEvent == bytes32(0)) return bytes32(0);\n        \n        (EventType eventType, uint256 scheduleTime) = decodeEvent(nextComputedEvent);\n\n        // if next computed event is a cyclic event\n        if (isCyclicEvent == true) {\n            asset.schedule.lastScheduleTimeOfCyclicEvent[eventType] = scheduleTime;\n        } else {\n            asset.schedule.lastNonCyclicEvent = nextComputedEvent;\n        }\n\n        return nextComputedEvent;\n    }\n\n    /**\n     * @notice Returns true if an event of an assets schedule was settled\n     * @param assetId id of the asset\n     * @param _event event (encoded)\n     * @return true if event was settled\n     */\n    function isEventSettled(bytes32 assetId, bytes32 _event)\n        external\n        view\n        override\n        returns (bool, int256)\n    {\n        return (\n            assets[assetId].settlement[_event].isSettled,\n            assets[assetId].settlement[_event].payoff\n        );\n    }\n\n    /**\n     * @notice Mark an event as settled\n     * @dev Can only be set by authorized account.\n     * @param assetId id of the asset\n     * @param _event event (encoded) to be marked as settled\n     */\n    function markEventAsSettled(bytes32 assetId, bytes32 _event, int256 _payoff)\n        external\n        override\n        isAuthorized (assetId)\n    {\n        assets[assetId].settlement[_event] = Settlement({ isSettled: true, payoff: _payoff });\n    }\n\n    // function decodeEvent(bytes32 _event)\n    //     internal\n    //     pure\n    //     returns (EventType, uint256)\n    // {\n    //     EventType eventType = EventType(uint8(uint256(_event >> 248)));\n    //     uint256 scheduleTime = uint256(uint64(uint256(_event)));\n\n    //     return (eventType, scheduleTime);\n    // }\n}\n"
    },
    "contracts/Core/Base/AssetRegistry/Schedule/ScheduleEncoder.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\n\nimport \"../BaseRegistryStorage.sol\";\n\n\nlibrary ScheduleEncoder {\n\n    function encodeAndSetSchedule(Asset storage asset, bytes32[] memory schedule) internal {\n        for (uint256 i = 0; i < schedule.length; i++) {\n            if (schedule[i] == bytes32(0)) break;\n            asset.schedule.events[i] = schedule[i];\n            asset.schedule.length = i + 1;\n        }\n    }\n\n    function decodeAndGetSchedule(Asset storage asset) internal view returns (bytes32[] memory) {\n        bytes32[] memory schedule = new bytes32[](asset.schedule.length);\n\n        for (uint256 i = 0; i < asset.schedule.length; i++) {\n            schedule[i] = asset.schedule.events[i];\n        }\n\n        return schedule;\n    }\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/Core/Base/Conversions.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./SharedTypes.sol\";\n\n\ncontract Conversions {\n\n    function encodeCollateralAsObject(address collateralToken, uint256 collateralAmount)\n        public\n        pure\n        returns (bytes32)\n    {\n        return bytes32(uint256(uint160(collateralToken))) << 96 | bytes32(uint256(uint96(collateralAmount)));\n    }\n\n    function decodeCollateralObject(bytes32 object)\n        public\n        pure\n        returns (address, uint256)\n    {\n        return (\n            address(uint160(uint256(object >> 96))),\n            uint256(uint96(uint256(object)))\n        );\n    }\n}\n"
    },
    "contracts/Core/Base/AssetRegistry/AccessControl/AccessControl.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../BaseRegistryStorage.sol\";\nimport \"./IAccessControl.sol\";\n\n\ncontract AccessControl is BaseRegistryStorage, IAccessControl {\n\n    event GrantedAccess(bytes32 indexed assetId, address indexed account, bytes4 methodSignature);\n    event RevokedAccess(bytes32 indexed assetId, address indexed account, bytes4 methodSignature);\n\n\n    // Method signature == bytes4(0) := Access to all methods defined in the Asset Registry contract\n    bytes4 constant ROOT_ACCESS = 0;\n\n\n    modifier isAuthorized(bytes32 assetId) {\n        require(\n            msg.sender == assets[assetId].actor || hasAccess(assetId, msg.sig, msg.sender),\n            \"AccessControl.isAuthorized: UNAUTHORIZED_SENDER\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Grant access to an account to call a specific method on a specific asset.\n     * @dev Can only be called by an authorized account.\n     * @param assetId id of the asset\n     * @param methodSignature function / method signature (4 byte keccak256 hash of the method selector)\n     * @param account address of the account to grant access to\n     */\n    function grantAccess(bytes32 assetId, bytes4 methodSignature, address account)\n        external\n        override\n    {\n        require(\n            hasAccess(assetId, msg.sig, msg.sender),\n            \"AccessControl.revokeAccess: UNAUTHORIZED_SENDER\"\n        );\n\n        assets[assetId].access[methodSignature][account] = true;\n\n        emit GrantedAccess(assetId, account, methodSignature);\n    }\n\n    /**\n     * @notice Revoke access for an account to call a specific method on a specific asset.\n     * @dev Can only be called by an authorized account.\n     * @param assetId id of the asset\n     * @param methodSignature function / method signature (4 byte keccak256 hash of the method selector)\n     * @param account address of the account to revoke access for\n     */\n    function revokeAccess(bytes32 assetId, bytes4 methodSignature, address account)\n        external\n        override\n    {\n        require(\n            hasAccess(assetId, msg.sig, msg.sender),\n            \"AccessControl.revokeAccess: UNAUTHORIZED_SENDER\"\n        );\n\n        assets[assetId].access[methodSignature][account] = false;\n\n        emit RevokedAccess(assetId, account, methodSignature);\n    }\n\n    /**\n     * @notice Check whether an account is allowed to call a specific method on a specific asset.\n     * @param assetId id of the asset\n     * @param methodSignature function / method signature (4 byte keccak256 hash of the method selector)\n     * @param account address of the account for which to check access\n     * @return true if allowed access\n     */\n    function hasAccess(bytes32 assetId, bytes4 methodSignature, address account)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return (\n            assets[assetId].access[methodSignature][account] || assets[assetId].access[ROOT_ACCESS][account]\n        );\n    }\n\n    /**\n     * @notice Check whether an account has root access for a specific asset.\n     * @param assetId id of the asset\n     * @param account address of the account for which to check root acccess\n     * @return  true if has root access\n     */\n    function hasRootAccess(bytes32 assetId, address account)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return (assets[assetId].access[ROOT_ACCESS][account]);\n    }\n\n    /**\n     * @notice Grant access to an account to call all methods on a specific asset\n     * (giving the account root access to an asset).\n     * @param assetId id of the asset\n     * @param account address of the account to set as the root\n     */\n    function setDefaultRoot(bytes32 assetId, address account) internal {\n        assets[assetId].access[ROOT_ACCESS][account] = true;\n        emit GrantedAccess(assetId, account, ROOT_ACCESS);\n    }\n}\n"
    },
    "contracts/Core/Base/AssetRegistry/Ownership/IOwnershipRegistry.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../SharedTypes.sol\";\n\n\ninterface IOwnershipRegistry {\n\n    function setCreatorObligor (bytes32 assetId, address newCreatorObligor)\n        external;\n\n    function setCounterpartyObligor (bytes32 assetId, address newCounterpartyObligor)\n        external;\n\n    function setCreatorBeneficiary(bytes32 assetId, address newCreatorBeneficiary)\n        external;\n\n    function setCounterpartyBeneficiary(bytes32 assetId, address newCounterpartyBeneficiary)\n        external;\n\n    function getOwnership(bytes32 assetId)\n        external\n        view\n        returns (AssetOwnership memory);\n}\n"
    },
    "contracts/Core/Base/AssetRegistry/AccessControl/IAccessControl.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\n\ninterface IAccessControl {\n\n    function grantAccess(bytes32 assetId, bytes4 methodSignature, address account)\n        external;\n\n    function revokeAccess(bytes32 assetId, bytes4 methodSignature, address account)\n        external;\n\n    function hasAccess(bytes32 assetId, bytes4 methodSignature, address account)\n        external\n        returns (bool);\n\n    function hasRootAccess(bytes32 assetId, address account)\n        external\n        returns (bool);\n}\n"
    },
    "contracts/Core/Base/AssetRegistry/State/IStateRegistry.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../SharedTypes.sol\";\n\n\ninterface IStateRegistry {\n\n    function getState(bytes32 assetId)\n        external\n        view\n        returns (State memory);\n\n    function getFinalizedState(bytes32 assetId)\n        external\n        view\n        returns (State memory);\n\n    function getEnumValueForStateAttribute(bytes32 assetId, bytes32 attribute)\n        external\n        view\n        returns (uint8);\n\n    function getIntValueForStateAttribute(bytes32 assetId, bytes32 attribute)\n        external\n        view\n        returns (int256);\n\n    function getUintValueForStateAttribute(bytes32 assetId, bytes32 attribute)\n        external\n        view\n        returns (uint256);\n\n    function setState(bytes32 assetId, State calldata state)\n        external;\n\n    function setFinalizedState(bytes32 assetId, State calldata state)\n        external;\n}\n"
    },
    "contracts/ACTUS/Core/Utils/EventUtils.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../ACTUSTypes.sol\";\n\n/**\n * @title EventUtils\n * @notice Methods for encoding decoding events\n */\ncontract EventUtils {\n\n    function encodeEvent(EventType eventType, uint256 scheduleTime)\n        public\n        pure\n        returns (bytes32)\n    {\n        return (\n            bytes32(uint256(uint8(eventType))) << 248 |\n            bytes32(scheduleTime)\n        );\n    }\n\n    function decodeEvent(bytes32 _event)\n        public\n        pure\n        returns (EventType, uint256)\n    {\n        EventType eventType = EventType(uint8(uint256(_event >> 248)));\n        uint256 scheduleTime = uint256(uint64(uint256(_event)));\n\n        return (eventType, scheduleTime);\n    }\n\n    /**\n     * @notice Returns the epoch offset for a given event type to determine the\n     * correct order of events if multiple events have the same timestamp\n     */\n    function getEpochOffset(EventType eventType)\n        public\n        pure\n        returns (uint256)\n    {\n        return uint256(eventType);\n    }\n}\n"
    },
    "contracts/ACTUS/Core/Utils/PeriodUtils.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath as SafeMul} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../../../external/BokkyPooBah/BokkyPooBahsDateTimeLibrary.sol\";\n\nimport \"../ACTUSTypes.sol\";\n\n/**\n * @title PeriodUtils\n * @notice Utility methods for dealing with Periods\n */\ncontract PeriodUtils {\n\n    using BokkyPooBahsDateTimeLibrary for uint;\n    using SafeMul for uint;\n\n    /**\n     * @notice Applies a period in IP notation to a given timestamp\n     */\n    function getTimestampPlusPeriod(IP memory period, uint256 timestamp)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 newTimestamp;\n\n        if (period.p == P.D) {\n            newTimestamp = timestamp.addDays(period.i);\n        } else if (period.p == P.W) {\n            newTimestamp = timestamp.addDays(period.i.mul(7));\n        } else if (period.p == P.M) {\n            newTimestamp = timestamp.addMonths(period.i);\n        } else if (period.p == P.Q) {\n            newTimestamp = timestamp.addMonths(period.i.mul(3));\n        } else if (period.p == P.H) {\n            newTimestamp = timestamp.addMonths(period.i.mul(6));\n        } else if (period.p == P.Y) {\n            newTimestamp = timestamp.addYears(period.i);\n        } else {\n            revert(\"PeriodUtils.getTimestampPlusPeriod: ATTRIBUTE_NOT_FOUND\");\n        }\n\n        return newTimestamp;\n    }\n}\n"
    },
    "contracts/Core/Base/AssetRegistry/Terms/ITermsRegistry.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../SharedTypes.sol\";\n\n\ninterface ITermsRegistry {\n\n    function getEnumValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        external\n        view\n        returns (uint8);\n\n    function getAddressValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        external\n        view\n        returns (address);\n\n    function getBytes32ValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        external\n        view\n        returns (bytes32);\n\n    function getUIntValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        external\n        view\n        returns (uint256);\n\n    function getIntValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        external\n        view\n        returns (int256);\n\n    function getPeriodValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        external\n        view\n        returns (IP memory);\n\n    function getCycleValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        external\n        view\n        returns (IPS memory);\n\n    function getContractReferenceValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        external\n        view\n        returns (ContractReference memory);\n}\n"
    },
    "contracts/Core/Base/AssetRegistry/Schedule/IScheduleRegistry.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../SharedTypes.sol\";\n\n\ninterface IScheduleRegistry {\n\n    function getPendingEvent (bytes32 assetId)\n        external\n        view\n        returns (bytes32);\n\n    function pushPendingEvent (bytes32 assetId, bytes32 pendingEvent)\n        external;\n\n    function popPendingEvent (bytes32 assetId)\n        external\n        returns (bytes32);\n\n    function getNextUnderlyingEvent (bytes32 assetId)\n        external\n        view\n        returns (bytes32);\n\n    function getEventAtIndex(bytes32 assetId, uint256 index)\n        external\n        view\n        returns (bytes32);\n    \n    function getScheduleLength(bytes32 assetId)\n        external\n        view\n        returns (uint256);\n\n    function getSchedule(bytes32 assetId)\n        external\n        view\n        returns (bytes32[] memory);\n\n    function getNextScheduleIndex(bytes32 assetId)\n        external\n        view\n        returns (uint256);\n\n    function getNextScheduledEvent (bytes32 assetId)\n        external\n        view\n        returns (bytes32);\n\n    function popNextScheduledEvent(bytes32 assetId)\n        external\n        returns (bytes32);\n\n    function isEventSettled(bytes32 assetId, bytes32 _event)\n        external\n        view\n        returns (bool, int256);\n\n    function markEventAsSettled(bytes32 assetId, bytes32 _event, int256 _payoff)\n        external;\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/external/BokkyPooBah/BokkyPooBahsDateTimeLibrary.sol": {
      "content": "// \"SPDX-License-Identifier: MIT\"\npragma solidity ^0.7.0;\n\n// ----------------------------------------------------------------------------\n// BokkyPooBah's DateTime Library v1.01\n//\n// A gas-efficient Solidity date and time library\n//\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\n//\n// Tested date range 1970/01/01 to 2345/12/31\n//\n// Conventions:\n// Unit      | Range         | Notes\n// :-------- |:-------------:|:-----\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\n// year      | 1970 ... 2345 |\n// month     | 1 ... 12      |\n// day       | 1 ... 31      |\n// hour      | 0 ... 23      |\n// minute    | 0 ... 59      |\n// second    | 0 ... 59      |\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\n//\n//\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\n// ----------------------------------------------------------------------------\n\nlibrary BokkyPooBahsDateTimeLibrary {\n\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n\n    // ------------------------------------------------------------------------\n    // Calculate the number of days from 1970/01/01 to year/month/day using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // days = day\n    //      - 32075\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\n    //      - offset\n    // ------------------------------------------------------------------------\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n\n        int __days = _day\n          - 32075\n          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n          - OFFSET19700101;\n\n        _days = uint(__days);\n    }\n\n    // ------------------------------------------------------------------------\n    // Calculate year/month/day from the number of days since 1970/01/01 using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // int L = days + 68569 + offset\n    // int N = 4 * L / 146097\n    // L = L - (146097 * N + 3) / 4\n    // year = 4000 * (L + 1) / 1461001\n    // L = L - 1461 * year / 4 + 31\n    // month = 80 * L / 2447\n    // dd = L - 2447 * month / 80\n    // L = month / 11\n    // month = month + 2 - 12 * L\n    // year = 100 * (N - 49) + year + L\n    // ------------------------------------------------------------------------\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    // 1 = Monday, 7 = Sunday\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}"
    },
    "contracts/Core/Base/AssetRegistry/IAssetRegistry.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./AccessControl/IAccessControl.sol\";\nimport \"./Terms/ITermsRegistry.sol\";\nimport \"./State/IStateRegistry.sol\";\nimport \"./Schedule/IScheduleRegistry.sol\";\nimport \"./Ownership/IOwnershipRegistry.sol\";\nimport \"./IBaseRegistry.sol\";\n\n\ninterface IAssetRegistry is\n    IAccessControl,\n    ITermsRegistry,\n    IStateRegistry,\n    IScheduleRegistry,\n    IOwnershipRegistry,\n    IBaseRegistry\n{}\n"
    },
    "contracts/Core/STK/STKActor.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../ACTUS/Engines/STK/ISTKEngine.sol\";\n\nimport \"../Base/AssetActor/BaseActor.sol\";\nimport \"./ISTKRegistry.sol\";\n\n\n/**\n * @title STKActor\n * @notice TODO\n */\ncontract STKActor is BaseActor {\n\n    using SignedMath for int;\n\n    enum STKExternalDataType {NA, DIP, SRA, REXA}\n\n\n    constructor(IAssetRegistry assetRegistry, IOracleProxy defaultOracleProxy) BaseActor(assetRegistry, defaultOracleProxy) {}\n\n    /**\n     * @notice Derives initial state of the asset terms and stores together with\n     * terms, schedule, ownership, engine, admin of the asset in the contract types specific AssetRegistry.\n     * @param terms asset specific terms\n     * @param schedule schedule of the asset\n     * @param ownership ownership of the asset\n     * @param engine address of the ACTUS engine used for the spec. ContractType\n     * @param admin address of the admin of the asset (optional)\n     */\n    function initialize(\n        STKTerms calldata terms,\n        bytes32[] calldata schedule,\n        AssetOwnership calldata ownership,\n        address engine,\n        address admin\n    )\n        external\n    {\n        require(\n            engine != address(0) && IEngine(engine).contractType() == ContractType.STK,\n            \"STKActor.initialize: CONTRACT_TYPE_OF_ENGINE_UNSUPPORTED\"\n        );\n\n        // solium-disable-next-line\n        bytes32 assetId = keccak256(abi.encode(terms, block.timestamp));\n\n        // compute the initial state of the asset\n        State memory initialState = ISTKEngine(engine).computeInitialState(terms);\n\n        // register the asset in the AssetRegistry\n        ISTKRegistry(address(assetRegistry)).registerAsset(\n            assetId,\n            terms,\n            initialState,\n            schedule,\n            ownership,\n            engine,\n            address(this),\n            admin\n        );\n\n        emit InitializedAsset(assetId, ContractType.STK, ownership.creatorObligor, ownership.counterpartyObligor);\n    }\n\n    function computeStateAndPayoffForEvent(bytes32 assetId, State memory state, bytes32 _event)\n        internal\n        view\n        override\n        returns (State memory, int256)\n    {\n        address engine = assetRegistry.getEngine(assetId);\n        STKTerms memory terms = ISTKRegistry(address(assetRegistry)).getTerms(assetId);\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n\n        int256 payoff = ISTKEngine(engine).computePayoffForEvent(\n            terms,\n            state,\n            _event,\n            getExternalDataForPOF(\n                assetId,\n                eventType,\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, 0)\n            )\n        );\n        state = ISTKEngine(engine).computeStateForEvent(\n            terms,\n            state,\n            _event,\n            getExternalDataForSTF(\n                assetId,\n                eventType,\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, 0)\n            )\n        );\n\n        return (state, payoff);\n    }\n\n    /**\n     * @notice Retrieves external data (such as market object data, block time, underlying asset state)\n     * used for evaluating the STF for a given event.\n     */\n    function getExternalDataForSTF(\n        bytes32 assetId,\n        EventType eventType,\n        uint256 timestamp\n    )\n        internal\n        view\n        override\n        returns (bytes32)\n    {\n        if (eventType == EventType.CE) {\n            // get current timestamp\n            // solium-disable-next-line\n            return bytes32(block.timestamp);\n        } else if (eventType == EventType.EXE) {\n            // get quantity\n            ContractReference memory contractReference_2 = assetRegistry.getContractReferenceValueForTermsAttribute(\n                assetId,\n                \"contractReference_2\"\n            );\n            if (\n                contractReference_2._type == ContractReferenceType.MOC\n                && contractReference_2.role == ContractReferenceRole.UDL\n            ) {\n                (int256 quantity, bool isSet) = defaultOracleProxy.getDataPoint(\n                    contractReference_2.object,\n                    timestamp\n                );\n                if (isSet) return bytes32(quantity);\n            }\n        } else if (eventType == EventType.REF) {\n            //\n            (int256 rexa, bool isSet) = defaultOracleProxy.getDataPoint(\n                bytes32(uint256(assetId) + uint256(STKExternalDataType.REXA)),\n                timestamp\n            );\n            if (isSet) return bytes32(rexa);\n        } else if (eventType == EventType.DIF) {\n            (int256 dipa, bool isSet) = defaultOracleProxy.getDataPoint(\n                bytes32(uint256(assetId) + uint256(STKExternalDataType.DIP)),\n                timestamp\n            );\n            if (isSet) return bytes32(dipa);\n        } else if (eventType == EventType.SPF) {\n            (int256 sra, bool isSet) = defaultOracleProxy.getDataPoint(\n                bytes32(uint256(assetId) + uint256(STKExternalDataType.SRA)),\n                timestamp\n            );\n            if (isSet) return bytes32(sra);\n        } else if (eventType == EventType.REF) {\n            (int256 rexa, bool isSet) = defaultOracleProxy.getDataPoint(\n                bytes32(uint256(assetId) + uint256(STKExternalDataType.REXA)),\n                timestamp\n            );\n            if (isSet) return bytes32(rexa);\n        }\n\n        return bytes32(0);\n    }\n}"
    },
    "contracts/Core/Base/AssetActor/BaseActor.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../../ACTUS/Core/SignedMath.sol\";\nimport \"../../../ACTUS/Core/Conventions/BusinessDayConventions.sol\";\nimport \"../../../ACTUS/Core/Utils/EventUtils.sol\";\n\n\nimport \"../SharedTypes.sol\";\nimport \"../Conversions.sol\";\nimport \"../AssetRegistry/IAssetRegistry.sol\";\nimport \"../OracleProxy/IOracleProxy.sol\";\nimport \"./IAssetActor.sol\";\n\n\n/**\n * @title BaseActor\n * @notice As the centerpiece of the ACTUS Protocol it is responsible for managing the\n * lifecycle of assets registered through the AssetRegistry. It acts as the executive of AP\n * by initializing the state of the asset and by processing the assets schedule as specified\n * in the TemplateRegistry. It derives the next state and the current outstanding payoff of\n * the asset by submitting the last finalized state to the corresponding ACTUS Engine.\n * The AssetActor stores the next state in the AssetRegistry, depending on if it is able\n * to settle the current outstanding payoff on behalf of the obligor.\n */\nabstract contract BaseActor is Conversions, EventUtils, BusinessDayConventions, IAssetActor, Ownable {\n\n    using SignedMath for int;\n\n    event InitializedAsset(bytes32 indexed assetId, ContractType contractType, address creator, address counterparty);\n    event ProgressedAsset(bytes32 indexed assetId, EventType eventType, uint256 scheduleTime, int256 payoff);\n    event Status(bytes32 indexed assetId, bytes32 statusMessage);\n\n    IAssetRegistry public assetRegistry;\n    IOracleProxy public defaultOracleProxy;\n\n\n    constructor(IAssetRegistry _assetRegistry, IOracleProxy _defaultOracleProxy) {\n        assetRegistry = _assetRegistry;\n        defaultOracleProxy = _defaultOracleProxy;\n    }\n\n    /**\n     * @notice Proceeds with the next state of the asset based on the terms, the last state, market object data\n     * and the settlement status of current obligation, derived from either a prev. pending event, an event\n     * generated based on the current state of an underlying asset or the assets schedule.\n     * @dev Emits ProgressedAsset if the state of the asset was updated.\n     * @param assetId id of the asset\n     */\n    function progress(bytes32 assetId) external override {\n        // revert if the asset is not registered in the AssetRegistry\n        require(\n            assetRegistry.isRegistered(assetId),\n            \"BaseActor.progress: ASSET_DOES_NOT_EXIST\"\n        );\n\n        // enforce order:\n        // - 1. pending event has to be processed\n        // - 2. an event which was generated based on the state of the underlying asset\n        // - 3. the next event in the schedule\n        bytes32 _event = assetRegistry.popPendingEvent(assetId);\n        if (_event == bytes32(0)) _event = assetRegistry.getNextUnderlyingEvent(assetId);\n        if (_event == bytes32(0)) _event = assetRegistry.popNextScheduledEvent(assetId);\n\n        // e.g. if all events in the schedule are processed\n        require(\n            _event != bytes32(0),\n            \"BaseActor.progress: NO_NEXT_EVENT\"\n        );\n\n        processEvent(assetId, _event);\n    }\n\n    /**\n     * @notice Proceeds with the next state of the asset based on the terms, the last state, market object data\n     * and the settlement status of current obligation, derived from a provided (unscheduled) event\n     * Reverts if the provided event violates the order of events.\n     * @dev Emits ProgressedAsset if the state of the asset was updated.\n     * @param assetId id of the asset\n     * @param _event the unscheduled event\n     */\n    function progressWith(bytes32 assetId, bytes32 _event) external override {\n        // revert if msg.sender is not authorized to update the asset\n        require(\n            assetRegistry.hasRootAccess(assetId, msg.sender),\n            \"BaseActor.progressWith: UNAUTHORIZED_SENDER\"\n        );\n\n        // enforce order:\n        // - 1. pending event has to be processed\n        // - 2. an event which was generated based on the state of the underlying asset\n        require(\n            assetRegistry.getPendingEvent(assetId) == bytes32(0),\n            \"BaseActor.progressWith: FOUND_PENDING_EVENT\"\n        );\n        require(\n            assetRegistry.getNextUnderlyingEvent(assetId) == bytes32(0),\n            \"BaseActor.progressWith: FOUND_UNDERLYING_EVENT\"\n        );\n\n        // - 3. the scheduled event takes priority if its schedule time is early or equal to the provided event\n        (, uint256 scheduledEventScheduleTime) = decodeEvent(assetRegistry.getNextScheduledEvent(assetId));\n        (, uint256 providedEventScheduleTime) = decodeEvent(_event);\n        require(\n            scheduledEventScheduleTime == 0 || (providedEventScheduleTime < scheduledEventScheduleTime),\n            \"BaseActor.progressWith: FOUND_EARLIER_EVENT\"\n        );\n\n        processEvent(assetId, _event);\n    }\n\n    /**\n     * @notice Return true if event was settled\n     */\n    function processEvent(bytes32 assetId, bytes32 _event) internal {\n        State memory state = assetRegistry.getState(assetId);\n\n        // block progression if asset has defaulted, terminated or reached maturity\n        require(\n            state.contractPerformance == ContractPerformance.PF\n            || state.contractPerformance == ContractPerformance.DL\n            || state.contractPerformance == ContractPerformance.DQ,\n            \"BaseActor.processEvent: ASSET_REACHED_FINAL_STATE\"\n        );\n\n        // get finalized state if asset is not performant\n        if (state.contractPerformance != ContractPerformance.PF) {\n            state = assetRegistry.getFinalizedState(assetId);\n        }\n\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n\n        // revert if the event time of the next event is in the future\n        // compute event time by applying BDC to schedule time\n        require(\n            // solium-disable-next-line\n            shiftEventTime(\n                scheduleTime,\n                BusinessDayConvention(assetRegistry.getEnumValueForTermsAttribute(assetId, \"businessDayConvention\")),\n                Calendar(assetRegistry.getEnumValueForTermsAttribute(assetId, \"calendar\")),\n                assetRegistry.getUIntValueForTermsAttribute(assetId, \"maturityDate\")\n            ) <= block.timestamp,\n            \"BaseActor.processEvent: NEXT_EVENT_NOT_YET_SCHEDULED\"\n        );\n\n        // get external data for the next event\n        // compute payoff and the next state by applying the event to the current state\n        (State memory nextState, int256 payoff) = computeStateAndPayoffForEvent(assetId, state, _event);\n\n        // try to settle payoff of event\n        bool settledPayoff = settlePayoffForEvent(assetId, _event, payoff);\n\n        if (settledPayoff == false) {\n            // if the obligation can't be fulfilled and the performance changed from performant to DL, DQ or DF,\n            // store the last performant state of the asset\n            // (if the obligation is later fulfilled before the asset reaches default,\n            // the last performant state is used to derive subsequent states of the asset)\n            if (state.contractPerformance == ContractPerformance.PF) {\n                assetRegistry.setFinalizedState(assetId, state);\n            }\n\n            // store event as pending event for future settlement\n            assetRegistry.pushPendingEvent(assetId, _event);\n\n            // create CreditEvent\n            bytes32 ceEvent = encodeEvent(EventType.CE, scheduleTime);\n\n            // derive the actual state of the asset by applying the CreditEvent (updates performance of asset)\n            (nextState, ) = computeStateAndPayoffForEvent(assetId, nextState, ceEvent);\n        }\n\n        // store the resulting state\n        assetRegistry.setState(assetId, nextState);\n\n        // mark event as settled\n        if (settledPayoff == true) {\n            assetRegistry.markEventAsSettled(assetId, _event, payoff);\n        }\n\n        emit ProgressedAsset(\n            assetId,\n            // if settlement failed a CreditEvent got processed instead\n            (settledPayoff == true) ? eventType : EventType.CE,\n            scheduleTime,\n            payoff\n        );\n    }\n\n    /**\n     * @notice Routes a payment to the designated beneficiary of the event obligation.\n     * @dev Checks if an owner of the specified cashflowId is set, if not it sends\n     * funds to the default beneficiary.\n     * @param assetId id of the asset which the payment relates to\n     * @param _event _event to settle the payoff for\n     * @param payoff payoff of the event\n     */\n    function settlePayoffForEvent(\n        bytes32 assetId,\n        bytes32 _event,\n        int256 payoff\n    )\n        internal\n        returns (bool)\n    {\n        require(\n            assetId != bytes32(0) && _event != bytes32(0),\n            \"BaseActor.settlePayoffForEvent: INVALID_FUNCTION_PARAMETERS\"\n        );\n\n        // return if there is no amount due\n        if (payoff == 0) return true;\n\n        // get the token address either from currency attribute or from the second contract reference\n        address token = assetRegistry.getAddressValueForTermsAttribute(assetId, \"currency\");\n        ContractReference memory contractReference_2 = assetRegistry.getContractReferenceValueForTermsAttribute(\n            assetId,\n            \"contractReference_2\"\n        );\n        if (contractReference_2.role == ContractReferenceRole.COVI) {\n            (token, ) = decodeCollateralObject(contractReference_2.object);\n        }\n\n        AssetOwnership memory ownership = assetRegistry.getOwnership(assetId);\n\n        // determine the payee and payer of the payment by checking the sign of the payoff\n        address payee;\n        address payer;\n        if (payoff > 0) {\n            // only allow for the obligor to settle the payment\n            payer = ownership.counterpartyObligor;\n            // use the default beneficiary if the there is no specific owner of the cashflow\n            if (payee == address(0)) {\n                payee = ownership.creatorBeneficiary;\n            }\n        } else {\n            // only allow for the obligor to settle the payment\n            payer = ownership.creatorObligor;\n            // use the default beneficiary if the there is no specific owner of the cashflow\n            if (payee == address(0)) {\n                payee = ownership.counterpartyBeneficiary;\n            }\n        }\n\n        // calculate the magnitude of the payoff\n        uint256 amount = (payoff > 0) ? uint256(payoff) : uint256(payoff * -1);\n\n        // check if allowance is set by the payer for the Asset Actor and that payer is able to cover payment\n        if (IERC20(token).allowance(payer, address(this)) < amount || IERC20(token).balanceOf(payer) < amount) {\n            emit Status(assetId, \"INSUFFICIENT_FUNDS\");\n            return false;\n        }\n\n        // try to transfer amount due from obligor to payee\n        return IERC20(token).transferFrom(payer, payee, amount);\n    }\n\n    function computeStateAndPayoffForEvent(bytes32 assetId, State memory state, bytes32 _event)\n        internal\n        view\n        virtual\n        returns (State memory, int256);\n\n    /**\n     * @notice Retrieves external data (such as market object data, block time, underlying asset state)\n     * used for evaluating the STF for a given event.\n     */\n    function getExternalDataForSTF(\n        bytes32 assetId,\n        EventType eventType,\n        uint256 timestamp\n    )\n        internal\n        view\n        virtual\n        returns (bytes32);\n\n    /**\n     * @notice Retrieves external data (such as market object data)\n     * used for evaluating the POF for a given event.\n     */\n    function getExternalDataForPOF(\n        bytes32 assetId,\n        EventType /* eventType */,\n        uint256 timestamp\n    )\n        internal\n        view\n        returns (bytes32)\n    {\n        address currency = assetRegistry.getAddressValueForTermsAttribute(assetId, \"currency\");\n        address settlementCurrency = assetRegistry.getAddressValueForTermsAttribute(assetId, \"settlementCurrency\");\n\n        if (currency != settlementCurrency) {\n            // get FX rate\n            (int256 fxRate, bool isSet) = defaultOracleProxy.getDataPoint(\n                keccak256(abi.encode(currency, settlementCurrency)),\n                timestamp\n            );\n            if (isSet) return bytes32(fxRate);\n        }\n\n        return bytes32(0);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/ACTUS/Core/SignedMath.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\n\n\n/**\n * Advanced math library for signed integers\n * (including floats which are represented as multiples of 10 ** 18)\n */\nlibrary SignedMath {\n\n    int256 constant private INT256_MIN = -2 ** 255;\n\n    uint256 constant public PRECISION = 18;\n    uint256 constant public MULTIPLICATOR = 10 ** PRECISION;\n\n\n    /**\n     * @dev The product of a and b has to be less than INT256_MAX (~10 ** 76),\n     * as devision (normalization) is performed after multiplication\n     * Upper boundary would be (10 ** 58) * (MULTIPLICATOR) == ~10 ** 76\n     */\n    function floatMult(int256 a, int256 b)\n        internal\n        pure\n        returns (int256)\n    {\n        if (a == 0 || b == 0) return 0;\n\n        require(!(a == -1 && b == INT256_MIN), \"SignedMath.floatMult: OVERFLOW_DETECTED\");\n        int256 c = a * b;\n        require(c / a == b, \"SignedMath.floatMult: OVERFLOW_DETECTED\");\n\n        // normalize (divide by MULTIPLICATOR)\n        int256 d = c / int256(MULTIPLICATOR);\n        require(d != 0, \"SignedMath.floatMult: CANNOT_REPRESENT_GRANULARITY\");\n\n        return d;\n    }\n\n    function floatDiv(int256 a, int256 b)\n        internal\n        pure\n        returns (int256)\n    {\n        require(b != 0, \"SignedMath.floatDiv: DIVIDED_BY_ZERO\");\n\n        // normalize (multiply by MULTIPLICATOR)\n        if (a == 0) return 0;\n        int256 c = a * int256(MULTIPLICATOR);\n        require(c / a == int256(MULTIPLICATOR), \"SignedMath.floatDiv: OVERFLOW_DETECTED\");\n\n        require(!(b == -1 && a == INT256_MIN), \"SignedMath.floatDiv: OVERFLOW_DETECTED\");\n        int256 d = c / b;\n        require(d != 0, \"SignedMath.floatDiv: CANNOT_REPRESENT_GRANULARITY\");\n\n        return d;\n    }\n\n    /**\n        * @dev Returns the smallest of two signed numbers.\n        */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n            return a <= b ? a : b;\n    }\n\n    /**\n        * @dev Returns the largest of two signed numbers.\n        */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n            return a >= b ? a : b;\n    }\n}\n"
    },
    "contracts/ACTUS/Core/Conventions/BusinessDayConventions.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\n\nimport \"../../../external/BokkyPooBah/BokkyPooBahsDateTimeLibrary.sol\";\n\nimport \"../ACTUSTypes.sol\";\n\n\n/**\n * @title BusinessDayConventions\n * @notice Contains conventions of how to handle non-business days when generating schedules of events.\n * The events schedule time can be shifted or not, if shifted it is possible that it is shifted to the next\n * or previous valid business days, etc.\n */\ncontract BusinessDayConventions {\n\n    /**\n     * @notice Used in POFs and STFs for DCFs.\n     * No shifting is applied if a Calc/Shift instead of Shift/Calc BDC is provided.\n     */\n    function shiftCalcTime(\n        uint256 timestamp,\n        BusinessDayConvention convention,\n        Calendar calendar,\n        uint256 maturityDate\n    )\n        public\n        pure\n        returns (uint256)\n    {\n        if (\n            convention == BusinessDayConvention.CSF ||\n            convention == BusinessDayConvention.CSMF ||\n            convention == BusinessDayConvention.CSP ||\n            convention == BusinessDayConvention.CSMP\n        ) {\n            return timestamp;\n        }\n\n        return shiftEventTime(timestamp, convention, calendar, maturityDate);\n    }\n\n    /*\n     * @notice Used for generating event schedules (for single events and event cycles schedules).\n     * This convention assumes that when shifting the events schedule time according\n     * to a BDC, the time is shifted first and calculations are performed thereafter.\n     * (Calculations in POFs and STFs are based on the shifted time as well)\n     */\n    function shiftEventTime(\n        uint256 timestamp,\n        BusinessDayConvention convention,\n        Calendar calendar,\n        uint256 maturityDate\n    )\n        public\n        pure\n        returns (uint256)\n    {\n        // do not shift if equal to maturity date\n        if (timestamp == maturityDate) return timestamp;\n\n        // Shift/Calc Following, Calc/Shift following\n        if (convention == BusinessDayConvention.SCF || convention == BusinessDayConvention.CSF) {\n            return getClosestBusinessDaySameDayOrFollowing(timestamp, calendar);\n        // Shift/Calc Modified Following, Calc/Shift Modified following\n        // Same as unmodified if shifted date is in the same month, if not it returns the previous buiness-day\n        } else if (convention == BusinessDayConvention.SCMF || convention == BusinessDayConvention.CSMF) {\n            uint256 followingOrSameBusinessDay = getClosestBusinessDaySameDayOrFollowing(timestamp, calendar);\n            if (BokkyPooBahsDateTimeLibrary.getMonth(followingOrSameBusinessDay) == BokkyPooBahsDateTimeLibrary.getMonth(timestamp)) {\n                return followingOrSameBusinessDay;\n            }\n            return getClosestBusinessDaySameDayOrPreceeding(timestamp, calendar);\n        // Shift/Calc Preceeding, Calc/Shift Preceeding\n        } else if (convention == BusinessDayConvention.SCP || convention == BusinessDayConvention.CSP) {\n            return getClosestBusinessDaySameDayOrPreceeding(timestamp, calendar);\n        // Shift/Calc Modified Preceeding, Calc/Shift Modified Preceeding\n        // Same as unmodified if shifted date is in the same month, if not it returns the following buiness-day\n        } else if (convention == BusinessDayConvention.SCMP || convention == BusinessDayConvention.CSMP) {\n            uint256 preceedingOrSameBusinessDay = getClosestBusinessDaySameDayOrPreceeding(timestamp, calendar);\n            if (BokkyPooBahsDateTimeLibrary.getMonth(preceedingOrSameBusinessDay) == BokkyPooBahsDateTimeLibrary.getMonth(timestamp)) {\n                return preceedingOrSameBusinessDay;\n            }\n            return getClosestBusinessDaySameDayOrFollowing(timestamp, calendar);\n        }\n\n        return timestamp;\n    }\n\n    /**\n     * @notice Returns the following business day if a non-business day is provided.\n     * (Returns the same day if calendar != MondayToFriday)\n     */\n    function getClosestBusinessDaySameDayOrFollowing(uint256 timestamp, Calendar calendar)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (calendar == Calendar.MF) {\n            if (BokkyPooBahsDateTimeLibrary.getDayOfWeek(timestamp) == 6) {\n                return BokkyPooBahsDateTimeLibrary.addDays(timestamp, 2);\n            } else if (BokkyPooBahsDateTimeLibrary.getDayOfWeek(timestamp) == 7) {\n                return BokkyPooBahsDateTimeLibrary.addDays(timestamp, 1);\n            }\n        }\n        return timestamp;\n    }\n\n    /**\n     * @notice Returns the previous buiness day if a non-businessday is provided.\n     * (Returns the same day if calendar != MondayToFriday)\n     */\n    function getClosestBusinessDaySameDayOrPreceeding(uint256 timestamp, Calendar calendar)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (calendar == Calendar.MF) {\n            if (BokkyPooBahsDateTimeLibrary.getDayOfWeek(timestamp) == 6) {\n                return BokkyPooBahsDateTimeLibrary.subDays(timestamp, 1);\n            } else if (BokkyPooBahsDateTimeLibrary.getDayOfWeek(timestamp) == 7) {\n                return BokkyPooBahsDateTimeLibrary.subDays(timestamp, 2);\n            }\n        }\n        return timestamp;\n    }\n}\n"
    },
    "contracts/Core/Base/OracleProxy/IOracleProxy.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\n\n\ninterface IOracleProxy {\n\n    /**\n     * @notice Returns a data point for given id and timestamp.\n     * @dev Has to be implement by each Oracle Proxy. It should never revert.\n     * @param identifier identifier of the data\n     * @param timestamp timestamp of\n     * @return Int256 value, isSet\n     */\n    function getDataPoint(bytes32 identifier, uint256 timestamp) external view returns (int256, bool);\n}"
    },
    "contracts/Core/Base/AssetActor/IAssetActor.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../SharedTypes.sol\";\n\n\ninterface IAssetActor {\n\n    function progress(bytes32 assetId)\n        external;\n\n    function progressWith(bytes32 assetId, bytes32 _event)\n        external;\n}\n"
    },
    "contracts/Core/PAM/PAMActor.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../ACTUS/Engines/PAM/IPAMEngine.sol\";\n\nimport \"../Base/AssetActor/BaseActor.sol\";\nimport \"./IPAMRegistry.sol\";\n\n\n/**\n * @title PAMActor\n * @notice TODO\n */\ncontract PAMActor is BaseActor {\n\n    constructor(IAssetRegistry assetRegistry, IOracleProxy defaultOracleProxy) BaseActor(assetRegistry, defaultOracleProxy) {}\n\n    /**\n     * @notice Derives initial state of the asset terms and stores together with\n     * terms, schedule, ownership, engine, admin of the asset in the contract types specific AssetRegistry.\n     * @param terms asset specific terms\n     * @param schedule schedule of the asset\n     * @param ownership ownership of the asset\n     * @param engine address of the ACTUS engine used for the spec. ContractType\n     * @param admin address of the admin of the asset (optional)\n     */\n    function initialize(\n        PAMTerms calldata terms,\n        bytes32[] calldata schedule,\n        AssetOwnership calldata ownership,\n        address engine,\n        address admin\n    )\n        external\n    {\n        require(\n            engine != address(0) && IEngine(engine).contractType() == ContractType.PAM,\n            \"ANNActor.initialize: CONTRACT_TYPE_OF_ENGINE_UNSUPPORTED\"\n        );\n\n        // solium-disable-next-line\n        bytes32 assetId = keccak256(abi.encode(terms, block.timestamp));\n\n        // compute the initial state of the asset\n        State memory initialState = IPAMEngine(engine).computeInitialState(terms);\n\n        // register the asset in the AssetRegistry\n        IPAMRegistry(address(assetRegistry)).registerAsset(\n            assetId,\n            terms,\n            initialState,\n            schedule,\n            ownership,\n            engine,\n            address(this),\n            admin\n        );\n\n        emit InitializedAsset(assetId, ContractType.PAM, ownership.creatorObligor, ownership.counterpartyObligor);\n    }\n\n    function computeStateAndPayoffForEvent(bytes32 assetId, State memory state, bytes32 _event)\n        internal\n        view\n        override\n        returns (State memory, int256)\n    {\n        address engine = assetRegistry.getEngine(assetId);\n        PAMTerms memory terms = IPAMRegistry(address(assetRegistry)).getTerms(assetId);\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n\n        int256 payoff = IPAMEngine(engine).computePayoffForEvent(\n            terms,\n            state,\n            _event,\n            getExternalDataForPOF(\n                assetId,\n                eventType,\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate)\n            )\n        );\n        state = IPAMEngine(engine).computeStateForEvent(\n            terms,\n            state,\n            _event,\n            getExternalDataForSTF(\n                assetId,\n                eventType,\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate)\n            )\n        );\n\n        return (state, payoff);\n    }\n\n    /**\n     * @notice Retrieves external data (such as market object data, block time, underlying asset state)\n     * used for evaluating the STF for a given event.\n     */\n    function getExternalDataForSTF(\n        bytes32 assetId,\n        EventType eventType,\n        uint256 timestamp\n    )\n        internal\n        view\n        override\n        returns (bytes32)\n    {\n        if (eventType == EventType.RR) {\n            // get rate from DataRegistry\n            (int256 resetRate, bool isSet) = defaultOracleProxy.getDataPoint(\n                assetRegistry.getBytes32ValueForTermsAttribute(assetId, \"marketObjectCodeRateReset\"),\n                timestamp\n            );\n            if (isSet) return bytes32(resetRate);\n        } else if (eventType == EventType.CE) {\n            // get current timestamp\n            // solium-disable-next-line\n            return bytes32(block.timestamp);\n        }\n\n        return bytes32(0);\n    }\n}"
    },
    "contracts/ACTUS/Engines/PAM/IPAMEngine.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../Core/ACTUSTypes.sol\";\nimport \"../IEngine.sol\";\n\n\n/**\n * @title IEngine\n * @notice Interface which all Engines have to implement\n */\ninterface IPAMEngine is IEngine {\n\n    /**\n     * @notice Initialize contract state space based on the contract terms.\n     * @param terms terms of the contract\n     * @return initial state of the contract\n     */\n    function computeInitialState(PAMTerms calldata terms)\n        external\n        pure\n        returns (State memory);\n\n    /**\n     * Applys an event to the current state of a contract and returns the resulting contract state.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event to be applied to the contract state\n     * @param externalData external data needed for STF evaluation (e.g. rate for RR events)\n     * @return the resulting contract state\n     */\n    function computeStateForEvent(\n        PAMTerms calldata terms,\n        State calldata state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        external\n        pure\n        returns (State memory);\n\n    /**\n     * Evaluates the payoff for an event under the current state of the contract.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which the payoff should be evaluated\n     * @param externalData external data needed for POF evaluation (e.g. fxRate)\n     * @return the payoff of the event\n     */\n    function computePayoffForEvent(\n        PAMTerms calldata terms,\n        State calldata state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        external\n        pure\n        returns (int256);\n\n    /**\n     * @notice Computes a schedule segment of non-cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @return segment of the non-cyclic schedule\n     */\n    function computeNonCyclicScheduleSegment(\n        PAMTerms calldata terms,\n        uint256 segmentStart,\n        uint256 segmentEnd\n    )\n        external\n        pure\n        returns (bytes32[] memory);\n\n    /**\n     * @notice Computes the next non-cyclic contract events based on the contract terms\n     * and the timestamp on which the prev. event occured.\n     * @dev Assumes that non-cyclic events of the same event type have a unique schedule time\n     * @param terms terms of the contract\n     * @param lastNonCyclicEvent last non-cyclic event\n     * @return next non-cyclic event\n     */\n    function computeNextNonCyclicEvent(\n        PAMTerms calldata terms,\n        bytes32 lastNonCyclicEvent\n    )\n        external\n        pure\n        returns (bytes32);\n\n    /**\n     * @notice Computes a schedule segment of cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param lastScheduleTime last occurrence of cyclic event\n     * @param eventType eventType of the cyclic schedule\n     * @return event schedule segment\n     */\n    function computeNextCyclicEvent(\n        PAMTerms calldata terms,\n        uint256 lastScheduleTime,\n        EventType eventType\n    )\n        external\n        pure\n        returns(bytes32);\n\n    /**\n     * @notice Computes a schedule segment of cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @param eventType eventType of the cyclic schedule\n     * @return event schedule segment\n     */\n    function computeCyclicScheduleSegment(\n        PAMTerms calldata terms,\n        uint256 segmentStart,\n        uint256 segmentEnd,\n        EventType eventType\n    )\n        external\n        pure\n        returns (bytes32[] memory);\n\n    /**\n     * @notice Verifies that the provided event is still scheduled under the terms, the current state of the\n     * contract and the current state of the underlying.\n     * @param _event event for which to check if its still scheduled\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param hasUnderlying boolean indicating whether the contract has an underlying contract\n     * @param underlyingState state of the underlying (empty state object if non-existing)\n     * @return boolean indicating whether event is still scheduled\n     */\n    function isEventScheduled(\n        bytes32 _event,\n        PAMTerms calldata terms,\n        State calldata state,\n        bool hasUnderlying,\n        State calldata underlyingState\n    )\n        external\n        pure\n        returns (bool);\n}\n"
    },
    "contracts/Core/PAM/IPAMRegistry.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../Base/SharedTypes.sol\";\nimport \"../Base/AssetRegistry/IAssetRegistry.sol\";\n\n\ninterface IPAMRegistry is IAssetRegistry {\n\n    function registerAsset(\n        bytes32 assetId,\n        PAMTerms calldata terms,\n        State calldata state,\n        bytes32[] calldata schedule,\n        AssetOwnership calldata ownership,\n        address engine,\n        address actor,\n        address admin\n    )\n        external;\n    \n    function getTerms(bytes32 assetId)\n        external\n        view\n        returns (PAMTerms memory);\n\n    function setTerms(bytes32 assetId, PAMTerms calldata terms)\n        external;\n}\n"
    },
    "contracts/Core/PAM/PAMRegistry.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../ACTUS/Engines/PAM/IPAMEngine.sol\";\n\nimport \"../Base/SharedTypes.sol\";\nimport \"../Base/AssetRegistry/BaseRegistry.sol\";\nimport \"./PAMEncoder.sol\";\nimport \"./IPAMRegistry.sol\";\n\n\n/**\n * @title PAMRegistry\n * @notice Registry for ACTUS Protocol assets\n */\ncontract PAMRegistry is BaseRegistry, IPAMRegistry {\n\n    using PAMEncoder for Asset;\n\n    \n    constructor() BaseRegistry() {}\n\n    /**\n     * @notice\n     * @param assetId id of the asset\n     * @param terms asset specific terms (PAMTerms)\n     * @param state initial state of the asset\n     * @param schedule schedule of the asset\n     * @param ownership ownership of the asset\n     * @param engine ACTUS Engine of the asset\n     * @param actor account which is allowed to update the asset state\n     * @param admin account which as admin rights (optional)\n     */\n    function registerAsset(\n        bytes32 assetId,\n        PAMTerms calldata terms,\n        State calldata state,\n        bytes32[] calldata schedule,\n        AssetOwnership calldata ownership,\n        address engine,\n        address actor,\n        address admin\n    )\n        external\n        override\n        onlyApprovedActors\n    {\n        setAsset(assetId, state, schedule, ownership, engine, actor, admin);\n        assets[assetId].encodeAndSetPAMTerms(terms);\n    }\n\n    /**\n     * @notice Returns the terms of an asset.\n     * @param assetId id of the asset\n     * @return terms of the asset\n     */\n    function getTerms(bytes32 assetId)\n        external\n        view\n        override\n        returns (PAMTerms memory)\n    {\n        return assets[assetId].decodeAndGetPAMTerms();\n    }\n\n    /**\n     * @notice Set the terms of the asset\n     * @dev Can only be set by authorized account.\n     * @param assetId id of the asset\n     * @param terms new terms\n     */\n    function setTerms(bytes32 assetId, PAMTerms calldata terms)\n        external\n        override\n        isAuthorized (assetId)\n    {\n        assets[assetId].encodeAndSetPAMTerms(terms);\n        emit UpdatedTerms(assetId);\n    }\n\n    function getEnumValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (uint8)\n    {\n        return assets[assetId].decodeAndGetEnumValueForPAMAttribute(attribute);\n    }\n\n    function getAddressValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (address)\n    {\n        return assets[assetId].decodeAndGetAddressValueForForPAMAttribute(attribute);\n    }\n\n    function getBytes32ValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (bytes32)\n    {\n        return assets[assetId].decodeAndGetBytes32ValueForForPAMAttribute(attribute);\n    }\n\n    function getUIntValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (uint256)\n    {\n        return assets[assetId].decodeAndGetUIntValueForForPAMAttribute(attribute);\n    }\n\n    function getIntValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (int256)\n    {\n        return assets[assetId].decodeAndGetIntValueForForPAMAttribute(attribute);\n    }\n\n    function getPeriodValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (IP memory)\n    {\n        return assets[assetId].decodeAndGetPeriodValueForForPAMAttribute(attribute);\n    }\n\n    function getCycleValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (IPS memory)\n    {\n        return assets[assetId].decodeAndGetCycleValueForForPAMAttribute(attribute);\n    }\n\n    function getContractReferenceValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (ContractReference memory)\n    {\n        return assets[assetId].decodeAndGetContractReferenceValueForPAMAttribute(attribute);\n    }\n\n    function getNextComputedEvent(bytes32 assetId)\n        internal\n        view\n        override(TermsRegistry)\n        returns (bytes32, bool)\n    {\n        Asset storage asset = assets[assetId];\n        PAMTerms memory terms = asset.decodeAndGetPAMTerms();\n\n        EventType nextEventType;\n        uint256 nextScheduleTime;\n        bool isCyclicEvent = true;\n\n        // IP\n        {\n            (EventType eventType, uint256 scheduleTime) = decodeEvent(IPAMEngine(asset.engine).computeNextCyclicEvent(\n                terms,\n                asset.schedule.lastScheduleTimeOfCyclicEvent[EventType.IP],\n                EventType.IP\n            ));\n\n            if (\n                (nextScheduleTime == 0)\n                || (scheduleTime < nextScheduleTime)\n                || (nextScheduleTime == scheduleTime && getEpochOffset(eventType) < getEpochOffset(nextEventType))\n            ) {\n                nextScheduleTime = scheduleTime;\n                nextEventType = eventType;\n            }\n        }\n\n        // IPCI\n        {\n            (EventType eventType, uint256 scheduleTime) = decodeEvent(IPAMEngine(asset.engine).computeNextCyclicEvent(\n                terms,\n                asset.schedule.lastScheduleTimeOfCyclicEvent[EventType.IPCI],\n                EventType.IPCI\n            ));\n\n            if (\n                (nextScheduleTime == 0)\n                || (scheduleTime != 0 && scheduleTime < nextScheduleTime)\n                || (scheduleTime != 0 && nextScheduleTime == scheduleTime && getEpochOffset(eventType) < getEpochOffset(nextEventType))\n            ) {\n                nextScheduleTime = scheduleTime;\n                nextEventType = eventType;\n            }        \n        }\n\n        // FP\n        {\n            (EventType eventType, uint256 scheduleTime) = decodeEvent(IPAMEngine(asset.engine).computeNextCyclicEvent(\n                terms,\n                asset.schedule.lastScheduleTimeOfCyclicEvent[EventType.FP],\n                EventType.FP\n            ));\n\n            if (\n                (nextScheduleTime == 0)\n                || (scheduleTime != 0 && scheduleTime < nextScheduleTime)\n                || (scheduleTime != 0 && nextScheduleTime == scheduleTime && getEpochOffset(eventType) < getEpochOffset(nextEventType))\n            ) {\n                nextScheduleTime = scheduleTime;\n                nextEventType = eventType;\n            }        \n        }\n\n        // SC\n        {\n            (EventType eventType, uint256 scheduleTime) = decodeEvent(IPAMEngine(asset.engine).computeNextCyclicEvent(\n                terms,\n                asset.schedule.lastScheduleTimeOfCyclicEvent[EventType.SC],\n                EventType.SC\n            ));\n\n            if (\n                (nextScheduleTime == 0)\n                || (scheduleTime != 0 && scheduleTime < nextScheduleTime)\n                || (scheduleTime != 0 && nextScheduleTime == scheduleTime && getEpochOffset(eventType) < getEpochOffset(nextEventType))\n            ) {\n                nextScheduleTime = scheduleTime;\n                nextEventType = eventType;\n            }        \n        }\n\n        // Non-Cyclic\n        {\n            (EventType eventType, uint256 scheduleTime) = decodeEvent(IPAMEngine(asset.engine).computeNextNonCyclicEvent(\n                terms,\n                asset.schedule.lastNonCyclicEvent\n            ));\n\n            if (\n                (nextScheduleTime == 0)\n                || (scheduleTime != 0 && scheduleTime < nextScheduleTime)\n                || (scheduleTime != 0 && nextScheduleTime == scheduleTime && getEpochOffset(eventType) < getEpochOffset(nextEventType))\n            ) {\n                nextScheduleTime = scheduleTime;\n                nextEventType = eventType;\n                isCyclicEvent = false;\n            }        \n        }\n\n        return (encodeEvent(nextEventType, nextScheduleTime), isCyclicEvent);\n    }\n}\n"
    },
    "contracts/Core/PAM/PAMEncoder.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../Base/SharedTypes.sol\";\nimport \"../Base/AssetRegistry/BaseRegistryStorage.sol\";\n\n\nlibrary PAMEncoder {\n\n    function storeInPackedTerms(Asset storage asset, bytes32 attributeKey, bytes32 value) private {\n        // skip if value did not change\n        if (asset.packedTerms[attributeKey] == value) return;\n        asset.packedTerms[attributeKey] = value;\n    }\n    \n    /**\n     * @dev Tightly pack and store only non-zero overwritten terms (LifecycleTerms)\n     * @notice All non zero values of the overwrittenTerms object are stored.\n     * It does not check if overwrittenAttributesMap actually marks attribute as overwritten.\n     */\n    function encodeAndSetPAMTerms(Asset storage asset, PAMTerms memory terms) external {\n        storeInPackedTerms(\n            asset,\n            \"enums\",\n            bytes32(uint256(uint8(terms.contractType))) << 248 |\n            bytes32(uint256(uint8(terms.calendar))) << 240 |\n            bytes32(uint256(uint8(terms.contractRole))) << 232 |\n            bytes32(uint256(uint8(terms.dayCountConvention))) << 224 |\n            bytes32(uint256(uint8(terms.businessDayConvention))) << 216 |\n            bytes32(uint256(uint8(terms.endOfMonthConvention))) << 208 |\n            bytes32(uint256(uint8(terms.scalingEffect))) << 200 |\n            bytes32(uint256(uint8(terms.feeBasis))) << 192\n        );\n\n        storeInPackedTerms(asset, \"currency\", bytes32(uint256(terms.currency) << 96));\n        storeInPackedTerms(asset, \"settlementCurrency\", bytes32(uint256(terms.settlementCurrency) << 96));\n\n        storeInPackedTerms(asset, \"marketObjectCodeRateReset\", bytes32(terms.marketObjectCodeRateReset));\n\n        storeInPackedTerms(asset, \"statusDate\", bytes32(terms.statusDate));\n        storeInPackedTerms(asset, \"initialExchangeDate\", bytes32(terms.initialExchangeDate));\n        storeInPackedTerms(asset, \"maturityDate\", bytes32(terms.maturityDate));\n        storeInPackedTerms(asset, \"issueDate\", bytes32(terms.issueDate));\n        storeInPackedTerms(asset, \"purchaseDate\", bytes32(terms.purchaseDate));\n        storeInPackedTerms(asset, \"capitalizationEndDate\", bytes32(terms.capitalizationEndDate));\n        storeInPackedTerms(asset, \"cycleAnchorDateOfInterestPayment\", bytes32(terms.cycleAnchorDateOfInterestPayment));\n        storeInPackedTerms(asset, \"cycleAnchorDateOfRateReset\", bytes32(terms.cycleAnchorDateOfRateReset));\n        storeInPackedTerms(asset, \"cycleAnchorDateOfScalingIndex\", bytes32(terms.cycleAnchorDateOfScalingIndex));\n        storeInPackedTerms(asset, \"cycleAnchorDateOfFee\", bytes32(terms.cycleAnchorDateOfFee));\n\n        storeInPackedTerms(asset, \"notionalPrincipal\", bytes32(terms.notionalPrincipal));\n        storeInPackedTerms(asset, \"nominalInterestRate\", bytes32(terms.nominalInterestRate));\n        storeInPackedTerms(asset, \"accruedInterest\", bytes32(terms.accruedInterest));\n        storeInPackedTerms(asset, \"rateMultiplier\", bytes32(terms.rateMultiplier));\n        storeInPackedTerms(asset, \"rateSpread\", bytes32(terms.rateSpread));\n        storeInPackedTerms(asset, \"nextResetRate\", bytes32(terms.nextResetRate));\n        storeInPackedTerms(asset, \"feeRate\", bytes32(terms.feeRate));\n        storeInPackedTerms(asset, \"feeAccrued\", bytes32(terms.feeAccrued));\n        storeInPackedTerms(asset, \"premiumDiscountAtIED\", bytes32(terms.premiumDiscountAtIED));\n        storeInPackedTerms(asset, \"priceAtPurchaseDate\", bytes32(terms.priceAtPurchaseDate));\n        storeInPackedTerms(asset, \"priceAtTerminationDate\", bytes32(terms.priceAtTerminationDate));\n        storeInPackedTerms(asset, \"lifeCap\", bytes32(terms.lifeCap));\n        storeInPackedTerms(asset, \"lifeFloor\", bytes32(terms.lifeFloor));\n        storeInPackedTerms(asset, \"periodCap\", bytes32(terms.periodCap));\n        storeInPackedTerms(asset, \"periodFloor\", bytes32(terms.periodFloor));\n\n        storeInPackedTerms(\n            asset,\n            \"gracePeriod\",\n            bytes32(uint256(terms.gracePeriod.i)) << 24 |\n            bytes32(uint256(terms.gracePeriod.p)) << 16 |\n            bytes32(uint256((terms.gracePeriod.isSet) ? 1 : 0)) << 8\n        );\n        storeInPackedTerms(\n            asset,\n            \"delinquencyPeriod\",\n            bytes32(uint256(terms.delinquencyPeriod.i)) << 24 |\n            bytes32(uint256(terms.delinquencyPeriod.p)) << 16 |\n            bytes32(uint256((terms.delinquencyPeriod.isSet) ? 1 : 0)) << 8\n        );\n\n        storeInPackedTerms(\n            asset,\n            \"cycleOfInterestPayment\",\n            bytes32(uint256(terms.cycleOfInterestPayment.i)) << 24 |\n            bytes32(uint256(terms.cycleOfInterestPayment.p)) << 16 |\n            bytes32(uint256(terms.cycleOfInterestPayment.s)) << 8 |\n            bytes32(uint256((terms.cycleOfInterestPayment.isSet) ? 1 : 0))\n        );\n        storeInPackedTerms(\n            asset,\n            \"cycleOfRateReset\",\n            bytes32(uint256(terms.cycleOfRateReset.i)) << 24 |\n            bytes32(uint256(terms.cycleOfRateReset.p)) << 16 |\n            bytes32(uint256(terms.cycleOfRateReset.s)) << 8 |\n            bytes32(uint256((terms.cycleOfRateReset.isSet) ? 1 : 0))\n        );\n        storeInPackedTerms(\n            asset,\n            \"cycleOfScalingIndex\",\n            bytes32(uint256(terms.cycleOfScalingIndex.i)) << 24 |\n            bytes32(uint256(terms.cycleOfScalingIndex.p)) << 16 |\n            bytes32(uint256(terms.cycleOfScalingIndex.s)) << 8 |\n            bytes32(uint256((terms.cycleOfScalingIndex.isSet) ? 1 : 0))\n        );\n        storeInPackedTerms(\n            asset,\n            \"cycleOfFee\",\n            bytes32(uint256(terms.cycleOfFee.i)) << 24 |\n            bytes32(uint256(terms.cycleOfFee.p)) << 16 |\n            bytes32(uint256(terms.cycleOfFee.s)) << 8 |\n            bytes32(uint256((terms.cycleOfFee.isSet) ? 1 : 0))\n        );\n    }\n\n    /**\n     * @dev Decode and loads PAMTerms\n     */\n    function decodeAndGetPAMTerms(Asset storage asset) external view returns (PAMTerms memory) {\n        return PAMTerms(\n            ContractType(uint8(uint256(asset.packedTerms[\"enums\"] >> 248))),\n            Calendar(uint8(uint256(asset.packedTerms[\"enums\"] >> 240))),\n            ContractRole(uint8(uint256(asset.packedTerms[\"enums\"] >> 232))),\n            DayCountConvention(uint8(uint256(asset.packedTerms[\"enums\"] >> 224))),\n            BusinessDayConvention(uint8(uint256(asset.packedTerms[\"enums\"] >> 216))),\n            EndOfMonthConvention(uint8(uint256(asset.packedTerms[\"enums\"] >> 208))),\n            ScalingEffect(uint8(uint256(asset.packedTerms[\"enums\"] >> 200))),\n            FeeBasis(uint8(uint256(asset.packedTerms[\"enums\"] >> 192))),\n\n            address(uint160(uint256(asset.packedTerms[\"currency\"]) >> 96)),\n            address(uint160(uint256(asset.packedTerms[\"settlementCurrency\"]) >> 96)),\n\n            asset.packedTerms[\"marketObjectCodeRateReset\"],\n\n            uint256(asset.packedTerms[\"statusDate\"]),\n            uint256(asset.packedTerms[\"initialExchangeDate\"]),\n            uint256(asset.packedTerms[\"maturityDate\"]),\n            uint256(asset.packedTerms[\"issueDate\"]),\n            uint256(asset.packedTerms[\"purchaseDate\"]),\n            uint256(asset.packedTerms[\"capitalizationEndDate\"]),\n            uint256(asset.packedTerms[\"cycleAnchorDateOfInterestPayment\"]),\n            uint256(asset.packedTerms[\"cycleAnchorDateOfRateReset\"]),\n            uint256(asset.packedTerms[\"cycleAnchorDateOfScalingIndex\"]),\n            uint256(asset.packedTerms[\"cycleAnchorDateOfFee\"]),\n\n            int256(asset.packedTerms[\"notionalPrincipal\"]),\n            int256(asset.packedTerms[\"nominalInterestRate\"]),\n            int256(asset.packedTerms[\"accruedInterest\"]),\n            int256(asset.packedTerms[\"rateMultiplier\"]),\n            int256(asset.packedTerms[\"rateSpread\"]),\n            int256(asset.packedTerms[\"nextResetRate\"]),\n            int256(asset.packedTerms[\"feeRate\"]),\n            int256(asset.packedTerms[\"feeAccrued\"]),\n            int256(asset.packedTerms[\"premiumDiscountAtIED\"]),\n            int256(asset.packedTerms[\"priceAtPurchaseDate\"]),\n            int256(asset.packedTerms[\"priceAtTerminationDate\"]),\n            int256(asset.packedTerms[\"lifeCap\"]),\n            int256(asset.packedTerms[\"lifeFloor\"]),\n            int256(asset.packedTerms[\"periodCap\"]),\n            int256(asset.packedTerms[\"periodFloor\"]),\n            \n            IP(\n                uint256(asset.packedTerms[\"gracePeriod\"] >> 24),\n                P(uint8(uint256(asset.packedTerms[\"gracePeriod\"] >> 16))),\n                (asset.packedTerms[\"gracePeriod\"] >> 8 & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            ),\n            IP(\n                uint256(asset.packedTerms[\"delinquencyPeriod\"] >> 24),\n                P(uint8(uint256(asset.packedTerms[\"delinquencyPeriod\"] >> 16))),\n                (asset.packedTerms[\"delinquencyPeriod\"] >> 8 & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            ),\n\n            IPS(\n                uint256(asset.packedTerms[\"cycleOfInterestPayment\"] >> 24),\n                P(uint8(uint256(asset.packedTerms[\"cycleOfInterestPayment\"] >> 16))),\n                S(uint8(uint256(asset.packedTerms[\"cycleOfInterestPayment\"] >> 8))),\n                (asset.packedTerms[\"cycleOfInterestPayment\"] & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            ),\n            IPS(\n                uint256(asset.packedTerms[\"cycleOfRateReset\"] >> 24),\n                P(uint8(uint256(asset.packedTerms[\"cycleOfRateReset\"] >> 16))),\n                S(uint8(uint256(asset.packedTerms[\"cycleOfRateReset\"] >> 8))),\n                (asset.packedTerms[\"cycleOfRateReset\"] & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            ),\n            IPS(\n                uint256(asset.packedTerms[\"cycleOfScalingIndex\"] >> 24),\n                P(uint8(uint256(asset.packedTerms[\"cycleOfScalingIndex\"] >> 16))),\n                S(uint8(uint256(asset.packedTerms[\"cycleOfScalingIndex\"] >> 8))),\n                (asset.packedTerms[\"cycleOfScalingIndex\"] & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            ),\n            IPS(\n                uint256(asset.packedTerms[\"cycleOfFee\"] >> 24),\n                P(uint8(uint256(asset.packedTerms[\"cycleOfFee\"] >> 16))),\n                S(uint8(uint256(asset.packedTerms[\"cycleOfFee\"] >> 8))),\n                (asset.packedTerms[\"cycleOfFee\"] & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            )\n        );\n    }\n\n    function decodeAndGetEnumValueForPAMAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (uint8)\n    {\n        if (attributeKey == bytes32(\"contractType\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 248));\n        } else if (attributeKey == bytes32(\"calendar\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 240));\n        } else if (attributeKey == bytes32(\"contractRole\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 232));\n        } else if (attributeKey == bytes32(\"dayCountConvention\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 224));\n        } else if (attributeKey == bytes32(\"businessDayConvention\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 216));\n        } else if (attributeKey == bytes32(\"endOfMonthConvention\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 208));\n        } else if (attributeKey == bytes32(\"scalingEffect\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 200));\n        } else if (attributeKey == bytes32(\"feeBasis\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 192));\n        } else {\n            return uint8(0);\n        }\n    }\n\n    function decodeAndGetAddressValueForForPAMAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (address)\n    {\n        if (attributeKey == bytes32(\"currency\")) {\n            return address(uint160(uint256(asset.packedTerms[\"currency\"]) >> 96));\n        } else if (attributeKey == bytes32(\"settlementCurrency\")) {\n            return address(uint160(uint256(asset.packedTerms[\"settlementCurrency\"]) >> 96));\n        } else {\n            return address(0);\n        }   \n    }\n\n    function decodeAndGetBytes32ValueForForPAMAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (bytes32)\n    {\n        return asset.packedTerms[attributeKey];\n    }\n\n    function decodeAndGetUIntValueForForPAMAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (uint256)\n    {\n        return uint256(asset.packedTerms[attributeKey]);\n    }\n\n    function decodeAndGetIntValueForForPAMAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (int256)\n    {\n        return int256(asset.packedTerms[attributeKey]);\n    }\n\n    function decodeAndGetPeriodValueForForPAMAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (IP memory)\n    {\n        if (\n            attributeKey == bytes32(\"gracePeriod\")\n            || attributeKey == bytes32(\"delinquencyPeriod\")\n        ) {\n            return IP(\n                uint256(asset.packedTerms[attributeKey] >> 24),\n                P(uint8(uint256(asset.packedTerms[attributeKey] >> 16))),\n                (asset.packedTerms[attributeKey] >> 8 & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            );\n        } else {\n            return IP(0, P(0), false);\n        }\n    }\n\n    function decodeAndGetCycleValueForForPAMAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (IPS memory)\n    {\n        if (\n            attributeKey == bytes32(\"cycleOfInterestPayment\")\n            || attributeKey == bytes32(\"cycleOfRateReset\")\n            || attributeKey == bytes32(\"cycleOfScalingIndex\")\n            || attributeKey == bytes32(\"cycleOfFee\")\n        ) {\n            return IPS(\n                uint256(asset.packedTerms[attributeKey] >> 24),\n                P(uint8(uint256(asset.packedTerms[attributeKey] >> 16))),\n                S(uint8(uint256(asset.packedTerms[attributeKey] >> 8))),\n                (asset.packedTerms[attributeKey] & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            );\n        } else {\n            return IPS(0, P(0), S(0), false);\n        }\n    }\n\n    function decodeAndGetContractReferenceValueForPAMAttribute(Asset storage /* asset */, bytes32 /* attributeKey */)\n        external\n        pure\n        returns (ContractReference memory)\n    {\n        return ContractReference(\n            bytes32(0),\n            bytes32(0),\n            ContractReferenceType(0),\n            ContractReferenceRole(0)\n        );\n    }\n}"
    },
    "contracts/Core/CERTF/CERTFEncoder.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../Base/SharedTypes.sol\";\nimport \"../Base/AssetRegistry/BaseRegistryStorage.sol\";\n\n\nlibrary CERTFEncoder {\n\n    function storeInPackedTerms(Asset storage asset, bytes32 attributeKey, bytes32 value) private {\n        // skip if value did not change\n        if (asset.packedTerms[attributeKey] == value) return;\n        asset.packedTerms[attributeKey] = value;\n    }\n\n    /**\n     * @dev Tightly pack and store only non-zero overwritten terms (LifecycleTerms)\n     * @notice All non zero values of the overwrittenTerms object are stored.\n     * It does not check if overwrittenAttributesMap actually marks attribute as overwritten.\n     */\n    function encodeAndSetCERTFTerms(Asset storage asset, CERTFTerms memory terms) external {\n        storeInPackedTerms(\n            asset,\n            \"enums\",\n            bytes32(uint256(uint8(terms.contractType))) << 248 |\n            bytes32(uint256(uint8(terms.calendar))) << 240 |\n            bytes32(uint256(uint8(terms.contractRole))) << 232 |\n            bytes32(uint256(uint8(terms.dayCountConvention))) << 224 |\n            bytes32(uint256(uint8(terms.businessDayConvention))) << 216 |\n            bytes32(uint256(uint8(terms.endOfMonthConvention))) << 208 |\n            bytes32(uint256(uint8(terms.couponType))) << 200\n        );\n\n        storeInPackedTerms(asset, \"currency\", bytes32(uint256(terms.currency) << 96));\n        storeInPackedTerms(asset, \"settlementCurrency\", bytes32(uint256(terms.settlementCurrency) << 96));\n\n        storeInPackedTerms(asset, \"statusDate\", bytes32(terms.statusDate));\n        storeInPackedTerms(asset, \"initialExchangeDate\", bytes32(terms.initialExchangeDate));\n        storeInPackedTerms(asset, \"maturityDate\", bytes32(terms.maturityDate));\n        storeInPackedTerms(asset, \"issueDate\", bytes32(terms.issueDate));\n        storeInPackedTerms(asset, \"cycleAnchorDateOfRedemption\", bytes32(terms.cycleAnchorDateOfRedemption));\n        storeInPackedTerms(asset, \"cycleAnchorDateOfTermination\", bytes32(terms.cycleAnchorDateOfTermination));\n        storeInPackedTerms(asset, \"cycleAnchorDateOfCoupon\", bytes32(terms.cycleAnchorDateOfCoupon));\n\n        storeInPackedTerms(asset, \"nominalPrice\", bytes32(terms.nominalPrice));\n        storeInPackedTerms(asset, \"issuePrice\", bytes32(terms.issuePrice));\n        storeInPackedTerms(asset, \"quantity\", bytes32(terms.quantity));\n        storeInPackedTerms(asset, \"denominationRatio\", bytes32(terms.denominationRatio));\n        storeInPackedTerms(asset, \"couponRate\", bytes32(terms.couponRate));\n\n        storeInPackedTerms(\n            asset,\n            \"gracePeriod\",\n            bytes32(uint256(terms.gracePeriod.i)) << 24 |\n            bytes32(uint256(terms.gracePeriod.p)) << 16 |\n            bytes32(uint256((terms.gracePeriod.isSet) ? 1 : 0)) << 8\n        );\n        storeInPackedTerms(\n            asset,\n            \"delinquencyPeriod\",\n            bytes32(uint256(terms.delinquencyPeriod.i)) << 24 |\n            bytes32(uint256(terms.delinquencyPeriod.p)) << 16 |\n            bytes32(uint256((terms.delinquencyPeriod.isSet) ? 1 : 0)) << 8\n        );\n        storeInPackedTerms(\n            asset,\n            \"settlementPeriod\",\n            bytes32(uint256(terms.settlementPeriod.i)) << 24 |\n            bytes32(uint256(terms.settlementPeriod.p)) << 16 |\n            bytes32(uint256((terms.settlementPeriod.isSet) ? 1 : 0)) << 8\n        );\n        storeInPackedTerms(\n            asset,\n            \"fixingPeriod\",\n            bytes32(uint256(terms.fixingPeriod.i)) << 24 |\n            bytes32(uint256(terms.fixingPeriod.p)) << 16 |\n            bytes32(uint256((terms.fixingPeriod.isSet) ? 1 : 0)) << 8\n        );\n        storeInPackedTerms(\n            asset,\n            \"redemptionRecordPeriod\",\n            bytes32(uint256(terms.redemptionRecordPeriod.i)) << 24 |\n            bytes32(uint256(terms.redemptionRecordPeriod.p)) << 16 |\n            bytes32(uint256((terms.redemptionRecordPeriod.isSet) ? 1 : 0)) << 8\n        );\n\n        storeInPackedTerms(\n            asset,\n            \"cycleOfRedemption\",\n            bytes32(uint256(terms.cycleOfRedemption.i)) << 24 |\n            bytes32(uint256(terms.cycleOfRedemption.p)) << 16 |\n            bytes32(uint256(terms.cycleOfRedemption.s)) << 8 |\n            bytes32(uint256((terms.cycleOfRedemption.isSet) ? 1 : 0))\n        );\n        storeInPackedTerms(\n            asset,\n            \"cycleOfTermination\",\n            bytes32(uint256(terms.cycleOfTermination.i)) << 24 |\n            bytes32(uint256(terms.cycleOfTermination.p)) << 16 |\n            bytes32(uint256(terms.cycleOfTermination.s)) << 8 |\n            bytes32(uint256((terms.cycleOfTermination.isSet) ? 1 : 0))\n        );\n        storeInPackedTerms(\n            asset,\n            \"cycleOfCoupon\",\n            bytes32(uint256(terms.cycleOfCoupon.i)) << 24 |\n            bytes32(uint256(terms.cycleOfCoupon.p)) << 16 |\n            bytes32(uint256(terms.cycleOfCoupon.s)) << 8 |\n            bytes32(uint256((terms.cycleOfCoupon.isSet) ? 1 : 0))\n        );\n\n        storeInPackedTerms(\n            asset,\n            \"contractReference_1_object\",\n            terms.contractReference_1.object\n        );\n        storeInPackedTerms(\n            asset,\n            \"contractReference_1_object2\",\n            terms.contractReference_1.object2\n        );\n        storeInPackedTerms(\n            asset,\n            \"contractReference_1_type_role\",\n            bytes32(uint256(terms.contractReference_1._type)) << 16 |\n            bytes32(uint256(terms.contractReference_1.role)) << 8\n        );\n\n        storeInPackedTerms(\n            asset,\n            \"contractReference_2_object\",\n            terms.contractReference_2.object\n        );\n        storeInPackedTerms(\n            asset,\n            \"contractReference_2_object2\",\n            terms.contractReference_2.object2\n        );\n        storeInPackedTerms(\n            asset,\n            \"contractReference_2_type_role\",\n            bytes32(uint256(terms.contractReference_2._type)) << 16 |\n            bytes32(uint256(terms.contractReference_2.role)) << 8\n        );\n    }\n\n    /**\n     * @dev Decode and loads CERTFTerms\n     */\n    function decodeAndGetCERTFTerms(Asset storage asset) external view returns (CERTFTerms memory) {\n        return CERTFTerms(\n            ContractType(uint8(uint256(asset.packedTerms[\"enums\"] >> 248))),\n            Calendar(uint8(uint256(asset.packedTerms[\"enums\"] >> 240))),\n            ContractRole(uint8(uint256(asset.packedTerms[\"enums\"] >> 232))),\n            DayCountConvention(uint8(uint256(asset.packedTerms[\"enums\"] >> 224))),\n            BusinessDayConvention(uint8(uint256(asset.packedTerms[\"enums\"] >> 216))),\n            EndOfMonthConvention(uint8(uint256(asset.packedTerms[\"enums\"] >> 208))),\n            CouponType(uint8(uint256(asset.packedTerms[\"enums\"] >> 200))),\n\n            address(uint160(uint256(asset.packedTerms[\"currency\"]) >> 96)),\n            address(uint160(uint256(asset.packedTerms[\"settlementCurrency\"]) >> 96)),\n\n            uint256(asset.packedTerms[\"statusDate\"]),\n            uint256(asset.packedTerms[\"initialExchangeDate\"]),\n            uint256(asset.packedTerms[\"maturityDate\"]),\n            uint256(asset.packedTerms[\"issueDate\"]),\n            uint256(asset.packedTerms[\"cycleAnchorDateOfRedemption\"]),\n            uint256(asset.packedTerms[\"cycleAnchorDateOfTermination\"]),\n            uint256(asset.packedTerms[\"cycleAnchorDateOfCoupon\"]),\n\n            int256(asset.packedTerms[\"nominalPrice\"]),\n            int256(asset.packedTerms[\"issuePrice\"]),\n            int256(asset.packedTerms[\"quantity\"]),\n            int256(asset.packedTerms[\"denominationRatio\"]),\n            int256(asset.packedTerms[\"couponRate\"]),\n\n            IP(\n                uint256(asset.packedTerms[\"gracePeriod\"] >> 24),\n                P(uint8(uint256(asset.packedTerms[\"gracePeriod\"] >> 16))),\n                (asset.packedTerms[\"gracePeriod\"] >> 8 & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            ),\n            IP(\n                uint256(asset.packedTerms[\"delinquencyPeriod\"] >> 24),\n                P(uint8(uint256(asset.packedTerms[\"delinquencyPeriod\"] >> 16))),\n                (asset.packedTerms[\"delinquencyPeriod\"] >> 8 & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            ),\n            IP(\n                uint256(asset.packedTerms[\"settlementPeriod\"] >> 24),\n                P(uint8(uint256(asset.packedTerms[\"settlementPeriod\"] >> 16))),\n                (asset.packedTerms[\"settlementPeriod\"] >> 8 & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            ),\n            IP(\n                uint256(asset.packedTerms[\"fixingPeriod\"] >> 24),\n                P(uint8(uint256(asset.packedTerms[\"fixingPeriod\"] >> 16))),\n                (asset.packedTerms[\"fixingPeriod\"] >> 8 & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            ),\n            IP(\n                uint256(asset.packedTerms[\"redemptionRecordPeriod\"] >> 24),\n                P(uint8(uint256(asset.packedTerms[\"redemptionRecordPeriod\"] >> 16))),\n                (asset.packedTerms[\"redemptionRecordPeriod\"] >> 8 & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            ),\n            IPS(\n                uint256(asset.packedTerms[\"cycleOfRedemption\"] >> 24),\n                P(uint8(uint256(asset.packedTerms[\"cycleOfRedemption\"] >> 16))),\n                S(uint8(uint256(asset.packedTerms[\"cycleOfRedemption\"] >> 8))),\n                (asset.packedTerms[\"cycleOfRedemption\"] & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            ),\n            IPS(\n                uint256(asset.packedTerms[\"cycleOfTermination\"] >> 24),\n                P(uint8(uint256(asset.packedTerms[\"cycleOfTermination\"] >> 16))),\n                S(uint8(uint256(asset.packedTerms[\"cycleOfTermination\"] >> 8))),\n                (asset.packedTerms[\"cycleOfTermination\"] & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            ),\n            IPS(\n                uint256(asset.packedTerms[\"cycleOfCoupon\"] >> 24),\n                P(uint8(uint256(asset.packedTerms[\"cycleOfCoupon\"] >> 16))),\n                S(uint8(uint256(asset.packedTerms[\"cycleOfCoupon\"] >> 8))),\n                (asset.packedTerms[\"cycleOfCoupon\"] & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            ),\n            ContractReference(\n                asset.packedTerms[\"contractReference_1_object\"],\n                asset.packedTerms[\"contractReference_1_object2\"],\n                ContractReferenceType(uint8(uint256(asset.packedTerms[\"contractReference_1_type_role\"] >> 16))),\n                ContractReferenceRole(uint8(uint256(asset.packedTerms[\"contractReference_1_type_role\"] >> 8)))\n            ),\n            ContractReference(\n                asset.packedTerms[\"contractReference_2_object\"],\n                asset.packedTerms[\"contractReference_2_object2\"],\n                ContractReferenceType(uint8(uint256(asset.packedTerms[\"contractReference_2_type_role\"] >> 16))),\n                ContractReferenceRole(uint8(uint256(asset.packedTerms[\"contractReference_2_type_role\"] >> 8)))\n            )\n        );\n    }\n\n    function decodeAndGetEnumValueForCERTFAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (uint8)\n    {\n        if (attributeKey == bytes32(\"contractType\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 248));\n        } else if (attributeKey == bytes32(\"calendar\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 240));\n        } else if (attributeKey == bytes32(\"contractRole\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 232));\n        } else if (attributeKey == bytes32(\"dayCountConvention\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 224));\n        } else if (attributeKey == bytes32(\"businessDayConvention\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 216));\n        } else if (attributeKey == bytes32(\"endOfMonthConvention\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 208));\n        } else if (attributeKey == bytes32(\"couponType\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 200));\n        } else {\n            return uint8(0);\n        }\n    }\n\n    function decodeAndGetAddressValueForForCERTFAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (address)\n    {\n        if (attributeKey == bytes32(\"currency\")) {\n            return address(uint160(uint256(asset.packedTerms[\"currency\"]) >> 96));\n        } else if (attributeKey == bytes32(\"settlementCurrency\")) {\n            return address(uint160(uint256(asset.packedTerms[\"settlementCurrency\"]) >> 96));\n        } else {\n            return address(0);\n        }\n    }\n\n    function decodeAndGetBytes32ValueForForCERTFAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (bytes32)\n    {\n        return asset.packedTerms[attributeKey];\n    }\n\n    function decodeAndGetUIntValueForForCERTFAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (uint256)\n    {\n        return uint256(asset.packedTerms[attributeKey]);\n    }\n\n    function decodeAndGetIntValueForForCERTFAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (int256)\n    {\n        return int256(asset.packedTerms[attributeKey]);\n    }\n\n    function decodeAndGetPeriodValueForForCERTFAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (IP memory)\n    {\n        if (\n            attributeKey == bytes32(\"gracePeriod\")\n            || attributeKey == bytes32(\"delinquencyPeriod\")\n            || attributeKey == bytes32(\"settlementPeriod\")\n            || attributeKey == bytes32(\"fixingPeriod\")\n            || attributeKey == bytes32(\"redemptionRecordPeriod\")\n        ) {\n            return IP(\n                uint256(asset.packedTerms[attributeKey] >> 24),\n                P(uint8(uint256(asset.packedTerms[attributeKey] >> 16))),\n                (asset.packedTerms[attributeKey] >> 8 & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            );\n        } else {\n            return IP(0, P(0), false);\n        }\n    }\n\n    function decodeAndGetCycleValueForForCERTFAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (IPS memory)\n    {\n        if (\n            attributeKey == bytes32(\"cycleOfRedemption\")\n            || attributeKey == bytes32(\"cycleOfTermination\")\n            || attributeKey == bytes32(\"cycleOfCoupon\")\n        ) {\n            return IPS(\n                uint256(asset.packedTerms[attributeKey] >> 24),\n                P(uint8(uint256(asset.packedTerms[attributeKey] >> 16))),\n                S(uint8(uint256(asset.packedTerms[attributeKey] >> 8))),\n                (asset.packedTerms[attributeKey] & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            );\n        } else {\n            return IPS(0, P(0), S(0), false);\n        }\n    }\n\n    function decodeAndGetContractReferenceValueForCERTFAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (ContractReference memory)\n    {\n        if (attributeKey == bytes32(\"contractReference_1\")) {\n            return ContractReference(\n                asset.packedTerms[\"contractReference_1_object\"],\n                asset.packedTerms[\"contractReference_1_object2\"],\n                ContractReferenceType(uint8(uint256(asset.packedTerms[\"contractReference_1_type_role\"] >> 16))),\n                ContractReferenceRole(uint8(uint256(asset.packedTerms[\"contractReference_1_type_role\"] >> 8)))\n            );\n        } else if (attributeKey == bytes32(\"contractReference_2\")) {\n            return ContractReference(\n                asset.packedTerms[\"contractReference_2_object\"],\n                asset.packedTerms[\"contractReference_2_object2\"],\n                ContractReferenceType(uint8(uint256(asset.packedTerms[\"contractReference_2_type_role\"] >> 16))),\n                ContractReferenceRole(uint8(uint256(asset.packedTerms[\"contractReference_2_type_role\"] >> 8)))\n            );\n        } else {\n            return ContractReference(\n                bytes32(0),\n                bytes32(0),\n                ContractReferenceType(0),\n                ContractReferenceRole(0)\n            );\n        }\n    }\n}\n"
    },
    "contracts/Core/CERTF/CERTFRegistry.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../ACTUS/Engines/CERTF/ICERTFEngine.sol\";\n\nimport \"../Base/SharedTypes.sol\";\nimport \"../Base/AssetRegistry/BaseRegistry.sol\";\nimport \"./CERTFEncoder.sol\";\nimport \"./ICERTFRegistry.sol\";\n\n\n/**\n * @title CERTFRegistry\n * @notice Registry for ACTUS Protocol assets\n */\ncontract CERTFRegistry is BaseRegistry, ICERTFRegistry {\n\n    using CERTFEncoder for Asset;\n\n\n    constructor() BaseRegistry() {}\n\n    /**\n     * @notice\n     * @param assetId id of the asset\n     * @param terms asset specific terms (CERTFTerms)\n     * @param state initial state of the asset\n     * @param schedule schedule of the asset\n     * @param ownership ownership of the asset\n     * @param engine ACTUS Engine of the asset\n     * @param actor account which is allowed to update the asset state\n     * @param admin account which as admin rights (optional)\n     */\n    function registerAsset(\n        bytes32 assetId,\n        CERTFTerms calldata terms,\n        State calldata state,\n        bytes32[] calldata schedule,\n        AssetOwnership calldata ownership,\n        address engine,\n        address actor,\n        address admin\n    )\n        external\n        override\n        onlyApprovedActors\n    {\n        setAsset(assetId, state, schedule, ownership, engine, actor, admin);\n        assets[assetId].encodeAndSetCERTFTerms(terms);\n    }\n\n    /**\n     * @notice Returns the terms of an asset.\n     * @param assetId id of the asset\n     * @return terms of the asset\n     */\n    function getTerms(bytes32 assetId)\n        external\n        view\n        override\n        returns (CERTFTerms memory)\n    {\n        return assets[assetId].decodeAndGetCERTFTerms();\n    }\n\n    /**\n     * @notice Set the terms of the asset\n     * @dev Can only be set by authorized account.\n     * @param assetId id of the asset\n     * @param terms new terms\n     */\n    function setTerms(bytes32 assetId, CERTFTerms calldata terms)\n        external\n        override\n        isAuthorized (assetId)\n    {\n        assets[assetId].encodeAndSetCERTFTerms(terms);\n        emit UpdatedTerms(assetId);\n    }\n\n    function getEnumValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (uint8)\n    {\n        return assets[assetId].decodeAndGetEnumValueForCERTFAttribute(attribute);\n    }\n\n    function getAddressValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (address)\n    {\n        return assets[assetId].decodeAndGetAddressValueForForCERTFAttribute(attribute);\n    }\n\n    function getBytes32ValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (bytes32)\n    {\n        return assets[assetId].decodeAndGetBytes32ValueForForCERTFAttribute(attribute);\n    }\n\n    function getUIntValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (uint256)\n    {\n        return assets[assetId].decodeAndGetUIntValueForForCERTFAttribute(attribute);\n    }\n\n    function getIntValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (int256)\n    {\n        return assets[assetId].decodeAndGetIntValueForForCERTFAttribute(attribute);\n    }\n\n    function getPeriodValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (IP memory)\n    {\n        return assets[assetId].decodeAndGetPeriodValueForForCERTFAttribute(attribute);\n    }\n\n    function getCycleValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (IPS memory)\n    {\n        return assets[assetId].decodeAndGetCycleValueForForCERTFAttribute(attribute);\n    }\n\n    function getContractReferenceValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (ContractReference memory)\n    {\n        return assets[assetId].decodeAndGetContractReferenceValueForCERTFAttribute(attribute);\n    }\n\n    function getNextComputedEvent(bytes32 assetId)\n        internal\n        view\n        override(TermsRegistry)\n        returns (bytes32, bool)\n    {\n        Asset storage asset = assets[assetId];\n        CERTFTerms memory terms = asset.decodeAndGetCERTFTerms();\n\n        EventType nextEventType;\n        uint256 nextScheduleTime;\n        bool isCyclicEvent = true;\n\n        // COF\n        {\n            (EventType eventType, uint256 scheduleTime) = decodeEvent(ICERTFEngine(asset.engine).computeNextCyclicEvent(\n                terms,\n                asset.schedule.lastScheduleTimeOfCyclicEvent[EventType.COF],\n                EventType.COF\n            ));\n\n            if (\n                (nextScheduleTime == 0)\n                || (scheduleTime < nextScheduleTime)\n                || (nextScheduleTime == scheduleTime && getEpochOffset(eventType) < getEpochOffset(nextEventType))\n            ) {\n                nextScheduleTime = scheduleTime;\n                nextEventType = eventType;\n            }\n        }\n\n        // COP\n        {\n            (EventType eventType, uint256 scheduleTime) = decodeEvent(ICERTFEngine(asset.engine).computeNextCyclicEvent(\n                terms,\n                asset.schedule.lastScheduleTimeOfCyclicEvent[EventType.COP],\n                EventType.COP\n            ));\n\n            if (\n                (nextScheduleTime == 0)\n                || (scheduleTime != 0 && scheduleTime < nextScheduleTime)\n                || (scheduleTime != 0 && nextScheduleTime == scheduleTime && getEpochOffset(eventType) < getEpochOffset(nextEventType))\n            ) {\n                nextScheduleTime = scheduleTime;\n                nextEventType = eventType;\n            }\n        }\n\n        // REF\n        {\n            (EventType eventType, uint256 scheduleTime) = decodeEvent(ICERTFEngine(asset.engine).computeNextCyclicEvent(\n                terms,\n                asset.schedule.lastScheduleTimeOfCyclicEvent[EventType.REF],\n                EventType.REF\n            ));\n\n            if (\n                (nextScheduleTime == 0)\n                || (scheduleTime != 0 && scheduleTime < nextScheduleTime)\n                || (scheduleTime != 0 && nextScheduleTime == scheduleTime && getEpochOffset(eventType) < getEpochOffset(nextEventType))\n            ) {\n                nextScheduleTime = scheduleTime;\n                nextEventType = eventType;\n            }\n        }\n\n        // REP\n        {\n            (EventType eventType, uint256 scheduleTime) = decodeEvent(ICERTFEngine(asset.engine).computeNextCyclicEvent(\n                terms,\n                asset.schedule.lastScheduleTimeOfCyclicEvent[EventType.REP],\n                EventType.REP\n            ));\n\n            if (\n                (nextScheduleTime == 0)\n                || (scheduleTime != 0 && scheduleTime < nextScheduleTime)\n                || (scheduleTime != 0 && nextScheduleTime == scheduleTime && getEpochOffset(eventType) < getEpochOffset(nextEventType))\n            ) {\n                nextScheduleTime = scheduleTime;\n                nextEventType = eventType;\n            }\n        }\n\n        // EXE\n        {\n            (EventType eventType, uint256 scheduleTime) = decodeEvent(ICERTFEngine(asset.engine).computeNextCyclicEvent(\n                terms,\n                asset.schedule.lastScheduleTimeOfCyclicEvent[EventType.EXE],\n                EventType.EXE\n            ));\n\n            if (\n                (nextScheduleTime == 0)\n                || (scheduleTime != 0 && scheduleTime < nextScheduleTime)\n                || (scheduleTime != 0 && nextScheduleTime == scheduleTime && getEpochOffset(eventType) < getEpochOffset(nextEventType))\n            ) {\n                nextScheduleTime = scheduleTime;\n                nextEventType = eventType;\n            }\n        }\n\n        // Non-Cyclic\n        {\n            (EventType eventType, uint256 scheduleTime) = decodeEvent(ICERTFEngine(asset.engine).computeNextNonCyclicEvent(\n                terms,\n                asset.schedule.lastNonCyclicEvent\n            ));\n\n            if (\n                (nextScheduleTime == 0)\n                || (scheduleTime != 0 && scheduleTime < nextScheduleTime)\n                || (scheduleTime != 0 && nextScheduleTime == scheduleTime && getEpochOffset(eventType) < getEpochOffset(nextEventType))\n            ) {\n                nextScheduleTime = scheduleTime;\n                nextEventType = eventType;\n                isCyclicEvent = false;\n            }        \n        }\n\n        return (encodeEvent(nextEventType, nextScheduleTime), isCyclicEvent);\n    }\n}\n"
    },
    "contracts/ACTUS/Engines/CERTF/ICERTFEngine.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../Core/ACTUSTypes.sol\";\nimport \"../IEngine.sol\";\n\n\n/**\n * @title IEngine\n * @notice Interface which all Engines have to implement\n */\ninterface ICERTFEngine is IEngine {\n\n    /**\n     * @notice Initialize contract state space based on the contract terms.\n     * @param terms terms of the contract\n     * @return initial state of the contract\n     */\n    function computeInitialState(CERTFTerms calldata terms)\n        external\n        pure\n        returns (State memory);\n\n    /**\n     * Applys an event to the current state of a contract and returns the resulting contract state.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event to be applied to the contract state\n     * @param externalData external data needed for STF evaluation (e.g. rate for RR events)\n     * @return the resulting contract state\n     */\n    function computeStateForEvent(\n        CERTFTerms calldata terms,\n        State calldata state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        external\n        pure\n        returns (State memory);\n\n    /**\n     * Evaluates the payoff for an event under the current state of the contract.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which the payoff should be evaluated\n     * @param externalData external data needed for POF evaluation (e.g. fxRate)\n     * @return the payoff of the event\n     */\n    function computePayoffForEvent(\n        CERTFTerms calldata terms,\n        State calldata state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        external\n        pure\n        returns (int256);\n\n    /**\n     * @notice Computes a schedule segment of non-cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @return segment of the non-cyclic schedule\n     */\n    function computeNonCyclicScheduleSegment(\n        CERTFTerms calldata terms,\n        uint256 segmentStart,\n        uint256 segmentEnd\n    )\n        external\n        pure\n        returns (bytes32[] memory);\n\n    /**\n     * @notice Computes a schedule segment of cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @param eventType eventType of the cyclic schedule\n     * @return event schedule segment\n     */\n    function computeCyclicScheduleSegment(\n        CERTFTerms calldata terms,\n        uint256 segmentStart,\n        uint256 segmentEnd,\n        EventType eventType\n    )\n        external\n        pure\n        returns (bytes32[] memory);\n\n    /**\n     * @notice Computes the next non-cyclic contract events based on the contract terms\n     * and the timestamp on which the prev. event occured.\n     * @dev Assumes that non-cyclic events of the same event type have a unique schedule time\n     * @param terms terms of the contract\n     * @param lastNonCyclicEvent last non-cyclic event\n     * @return next non-cyclic event\n     */\n    function computeNextNonCyclicEvent(\n        CERTFTerms calldata terms,\n        bytes32 lastNonCyclicEvent\n    )\n        external\n        pure\n        returns (bytes32);\n\n    /**\n     * @notice Computes a schedule segment of cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param lastScheduleTime last occurrence of cyclic event\n     * @param eventType eventType of the cyclic schedule\n     * @return event schedule segment\n     */\n    function computeNextCyclicEvent(\n        CERTFTerms calldata terms,\n        uint256 lastScheduleTime,\n        EventType eventType\n    )\n        external\n        pure\n        returns(bytes32);\n\n    /**\n     * @notice Verifies that the provided event is still scheduled under the terms, the current state of the\n     * contract and the current state of the underlying.\n     * @param _event event for which to check if its still scheduled\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param hasUnderlying boolean indicating whether the contract has an underlying contract\n     * @param underlyingState state of the underlying (empty state object if non-existing)\n     * @return boolean indicating whether event is still scheduled\n     */\n    function isEventScheduled(\n        bytes32 _event,\n        CERTFTerms calldata terms,\n        State calldata state,\n        bool hasUnderlying,\n        State calldata underlyingState\n    )\n        external\n        pure\n        returns (bool);\n}\n"
    },
    "contracts/Core/CERTF/ICERTFRegistry.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../Base/SharedTypes.sol\";\nimport \"../Base/AssetRegistry/IAssetRegistry.sol\";\n\n\ninterface ICERTFRegistry is IAssetRegistry {\n\n    function registerAsset(\n        bytes32 assetId,\n        CERTFTerms calldata terms,\n        State calldata state,\n        bytes32[] calldata schedule,\n        AssetOwnership calldata ownership,\n        address engine,\n        address actor,\n        address admin\n    )\n        external;\n    \n    function getTerms(bytes32 assetId)\n        external\n        view\n        returns (CERTFTerms memory);\n\n    function setTerms(bytes32 assetId, CERTFTerms calldata terms)\n        external;\n}\n"
    },
    "contracts/Extensions/ICT/ICT.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../../ACTUS/Core/ACTUSTypes.sol\";\nimport \"../../ACTUS/Core/Utils/EventUtils.sol\";\nimport \"../../ACTUS/Core/Utils/PeriodUtils.sol\";\nimport \"../../ACTUS/Core/Conventions/BusinessDayConventions.sol\";\nimport \"../../ACTUS/Core/SignedMath.sol\";\nimport \"../../Core/Base/AssetRegistry/IAssetRegistry.sol\";\nimport \"../../Core/Base/OracleProxy/DataRegistryProxy/IDataRegistryProxy.sol\";\nimport \"./DepositAllocater.sol\";\n\n\ncontract ICT is\n    IERC20,\n    DepositAllocater,\n    Ownable,\n    EventUtils,\n    PeriodUtils,\n    BusinessDayConventions\n{\n    using Address for address;\n    using SafeMath for uint256;\n    using SignedMath for int256;\n\n    IAssetRegistry public assetRegistry;\n    IDataRegistryProxy public dataRegistryProxy;\n\n    bytes32 public marketObjectCode;\n    bytes32 public assetId;\n\n\n    constructor(\n        IAssetRegistry _assetRegistry,\n        IDataRegistryProxy _dataRegistryProxy,\n        bytes32 _marketObjectCode,\n        address owner\n    )\n        DepositAllocater(\"Investment Certifacte Token\", \"ICT\")\n    {\n        require(\n            address(_assetRegistry).isContract(),\n            \"ICT.initialize: INVALID_ASSET_REGISTRY\"\n        );\n        require(\n            address(_dataRegistryProxy).isContract(),\n            \"ICT.initialize: INVALID_DATA_REGISTRY\"\n        );\n\n        transferOwnership(owner);\n\n        assetRegistry = _assetRegistry;\n        dataRegistryProxy = _dataRegistryProxy;\n        marketObjectCode = _marketObjectCode;\n    }\n\n    function setAssetId(bytes32 _assetId)\n        public\n        onlyOwner\n    {\n        require (\n            assetId == bytes32(0),\n            \"ICT.setAssetId: ASSET_ID_ALREADY_SET\"\n        );\n\n        assetId = _assetId;\n    }\n\n    function createDepositForEvent(bytes32 _event)\n        public\n        nonReentrant()\n    {\n        require(\n            assetRegistry.isRegistered(assetId) == true,\n            \"ICT.createDepositForEvent: ASSET_DOES_NOT_EXIST\"\n        );\n\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n\n        // redemption is comprised of REF, EXE, REP events\n        // only REF is needed for the ICT redemption workflow\n        require(\n            eventType != EventType.EXE && eventType != EventType.REP,\n            \"ICT.createDepositForEvent: FORBIDDEN_EVEN_TYPE\"\n        );\n\n        address currency = assetRegistry.getAddressValueForTermsAttribute(assetId, \"currency\");\n\n        createDeposit(\n            _event,\n            scheduleTime,\n            // latest registration date on EXE\n            (eventType == EventType.REF)\n                ? getTimestampPlusPeriod(\n                    assetRegistry.getPeriodValueForTermsAttribute(assetId, \"redemptionRecordPeriod\"),\n                    scheduleTime)\n                : 0,\n            (eventType == EventType.REF),\n            currency\n        );\n    }\n\n    function fetchDepositAmountForEvent(bytes32 _event)\n        public\n        nonReentrant()\n    {\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n\n        (bool isSettled, int256 payoff) = assetRegistry.isEventSettled(\n            assetId,\n            (eventType != EventType.REF)\n                ? _event\n                : encodeEvent(\n                    EventType.REP,\n                    getTimestampPlusPeriod(\n                        assetRegistry.getPeriodValueForTermsAttribute(assetId, \"settlementPeriod\"),\n                        scheduleTime\n                    )\n                )\n        );\n\n        require(\n            isSettled == true,\n            \"ICT.fetchDepositAmountForEvent: NOT_YET_DEPOSITED\"\n        );\n\n        updateDepositAmount(\n            _event,\n            (payoff >= 0) ? uint256(payoff) : uint256(payoff * -1)\n        );\n    }\n\n    /**\n     * @param _event encoded redemption to register for\n     * @param amount amount of tokens to redeem\n     */\n    function registerForRedemption(bytes32 _event, uint256 amount)\n        public\n        nonReentrant()\n    {\n        require(\n            assetRegistry.isRegistered(assetId) == true,\n            \"ICT.registerForRedemption: ASSET_DOES_NOT_EXIST\"\n        );\n\n        signalAmountForDeposit(_event, amount);\n\n        Deposit storage deposit = deposits[_event];\n        // assuming number of decimals used for numbers in actus-solidity == number of decimals of ICT\n        int256 quantity = assetRegistry.getIntValueForStateAttribute(assetId, \"quantity\");\n        int256 totalSupply = int256(totalSupplyAt(deposit.scheduledFor));\n        int256 ratioSignaled = int256(deposit.totalAmountSignaled).floatDiv(totalSupply);\n        int256 exerciseQuantity = ratioSignaled.floatMult(quantity);\n\n        (EventType eventType, ) = decodeEvent(_event);\n\n        uint256 timestamp = shiftCalcTime(\n            (eventType != EventType.REF) ? deposit.scheduledFor : deposit.signalingCutoff,\n            BusinessDayConvention(assetRegistry.getEnumValueForTermsAttribute(assetId, \"businessDayConvention\")),\n            Calendar(assetRegistry.getEnumValueForTermsAttribute(assetId, \"calendar\")),\n            assetRegistry.getUIntValueForTermsAttribute(assetId, \"maturityDate\")\n        );\n\n        dataRegistryProxy.publishDataPoint(marketObjectCode, timestamp, exerciseQuantity);\n    }\n\n    /**\n     * @param _event encoded redemption to cancel the registration for\n     */\n    function cancelRegistrationForRedemption(bytes32 _event)\n        public\n        nonReentrant()\n    {\n        require(\n            assetRegistry.isRegistered(assetId) == true,\n            \"ICT.createDepositForEvent: ASSET_DOES_NOT_EXIST\"\n        );\n\n        signalAmountForDeposit(_event, 0);\n\n        Deposit storage deposit = deposits[_event];\n        // assuming number of decimals used for numbers in actus-solidity == number of decimals of ICT\n        int256 quantity = assetRegistry.getIntValueForStateAttribute(assetId, \"quantity\");\n        int256 totalSupply = int256(totalSupplyAt(deposit.scheduledFor));\n        int256 ratioSignaled = int256(deposit.totalAmountSignaled).floatDiv(totalSupply);\n        int256 exerciseQuantity = ratioSignaled.floatMult(quantity);\n\n        (EventType eventType, ) = decodeEvent(_event);\n\n        uint256 timestamp = shiftCalcTime(\n            (eventType != EventType.REF) ? deposit.scheduledFor : deposit.signalingCutoff,\n            BusinessDayConvention(assetRegistry.getEnumValueForTermsAttribute(assetId, \"businessDayConvention\")),\n            Calendar(assetRegistry.getEnumValueForTermsAttribute(assetId, \"calendar\")),\n            assetRegistry.getUIntValueForTermsAttribute(assetId, \"maturityDate\")\n        );\n\n        dataRegistryProxy.publishDataPoint(marketObjectCode, timestamp, exerciseQuantity);\n    }\n\n    function mint(address account, uint256 amount)\n        public\n        onlyOwner\n        returns(bool)\n    {\n        super._mint(account, amount);\n        return true;\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    )\n        internal\n        virtual\n        override\n    {\n        require(\n            totalAmountSignaledByHolder[from] == 0,\n            \"ICT._transfer: HOLDER_IS_SIGNALING\"\n        );\n        super._transfer(from, to, value);\n    }\n\n    function transferDeposit(\n        address payee,\n        Deposit storage deposit,\n        bytes32 depositId\n    )\n        internal\n        virtual\n        override\n    {\n        if (deposit.onlySignaled == true && deposit.signaledAmounts[payee] > 0) {\n            _burn(payee, deposit.signaledAmounts[payee]);\n        }\n        // `nonReentrant`-protected (by the `DepositAllocator`)\n        super.transferDeposit(payee, deposit, depositId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/Core/Base/OracleProxy/DataRegistryProxy/IDataRegistryProxy.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\n\ninterface IDataRegistryProxy {\n\n    function isRegistered(bytes32 setId)\n        external\n        view\n        returns (bool);\n\n    function getLastUpdatedTimestamp(bytes32 setId)\n        external\n        view\n        returns (uint256);\n\n    function getDataProvider(bytes32 setId)\n        external\n        view\n        returns (address);\n\n    function setDataProvider(\n        bytes32 setId,\n        address provider\n    )\n        external;\n\n    function publishDataPoint(\n        bytes32 setId,\n        uint256 timestamp,\n        int256 dataPoint\n    )\n        external;\n\n    function getDataPoint(\n        bytes32 setId,\n        uint256 timestamp\n    )\n        external\n        view\n        returns (int256, bool);\n}\n"
    },
    "contracts/Extensions/ICT/DepositAllocater.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport \"./CheckpointedToken.sol\";\n\n\nstruct Deposit {\n    // Time at which the deposit is scheduled for\n    uint256 scheduledFor;\n    // Time until which holders can signal for a deposit\n    uint256 signalingCutoff;\n    // Deposit amount in WEI\n    uint256 amount;\n    // Amount of funds claimed so far\n    uint256 claimedAmount;\n    // Sum of the signaled tokens of whitelisted token holders (only used if isWhitelisted == true)\n    uint256 totalAmountSignaled;\n    // Address of the token in which the deposit is made\n    address token;\n    // Indicates whether holders have to signal in advance to claim their share of the deposit\n    bool onlySignaled;\n    // List of addresses which have withdrawn their share of funds of the deposit\n    mapping (address => bool) claimed;\n    // Subset of holders which can claim their share of funds of the deposit\n    mapping (address => uint256) signaledAmounts;\n}\n\n/**\n * @title Logic for distributing funds based on checkpointing\n * @dev abstract contract\n */\ncontract DepositAllocater is CheckpointedToken, ReentrancyGuard {\n\n    using SafeMath for uint256;\n\n    // depositId => Deposit\n    mapping(bytes32 => Deposit) public deposits;\n    // holder => amount signaled\n    mapping(address => uint256) public totalAmountSignaledByHolder;\n\n\n    constructor(string memory name, string memory symbol) CheckpointedToken(name, symbol) {}\n\n    function createDeposit(bytes32 depositId, uint256 scheduledFor, uint256 signalingCutoff, bool onlySignaled, address token) public {\n        Deposit storage deposit = deposits[depositId];\n\n        require(\n            deposit.scheduledFor == uint256(0),\n            \"Deposit.createDeposit: DEPOSIT_ALREADY_EXISTS\"\n        );\n\n        deposit.scheduledFor = scheduledFor;\n        deposit.signalingCutoff = signalingCutoff;\n        deposit.onlySignaled = onlySignaled;\n        deposit.token = token;\n    }\n\n    function updateDepositAmount(bytes32 depositId, uint256 amount) public {\n        Deposit storage deposit = deposits[depositId];\n\n        require(\n            deposit.scheduledFor != uint256(0),\n            \"Deposit.updateDepositAmount: DEPOSIT_DOES_NOT_EXIST\"\n        );\n\n        require(\n            deposit.amount == uint256(0),\n            \"Deposit.updateDepositAmount: DEPOSIT_AMOUNT_ALREADY_SET\"\n        );\n\n        deposit.amount = amount;\n    }\n\n    function signalAmountForDeposit(bytes32 depositId, uint256 signalAmount) public {\n        Deposit storage deposit = deposits[depositId];\n\n        require(\n            deposit.scheduledFor != uint256(0),\n            \"Deposit.signalAmountForDeposit: DEPOSIT_DOES_NOT_EXIST\"\n        );\n\n        require(\n            deposit.onlySignaled == true,\n            \"Deposit.signalAmountForDeposit: SIGNALING_NOT_ENABLED\"\n        );\n\n        require(\n            deposit.signalingCutoff > block.timestamp,\n            \"Deposit.signalAmountForDeposit: SIGNALING_ENDED\"\n        );\n\n        require(\n            totalAmountSignaledByHolder[msg.sender] <= balanceOfAt(msg.sender, block.timestamp),\n            \"Deposit.signalAmountForDeposit: SIGNAL_AMOUNT_EXCEEDS_BALANCE\"\n        );\n\n        // increment total amount of signaled by the holder comprising all deposits\n        if (signalAmount == 0) {\n            totalAmountSignaledByHolder[msg.sender] = totalAmountSignaledByHolder[msg.sender].sub(deposit.signaledAmounts[msg.sender]);\n        } else if (signalAmount < deposit.signaledAmounts[msg.sender]) {\n            uint256 deltaAmountSignaled = deposit.signaledAmounts[msg.sender].sub(signalAmount);\n            totalAmountSignaledByHolder[msg.sender] = totalAmountSignaledByHolder[msg.sender].sub(deltaAmountSignaled);\n        } else {\n            uint256 deltaAmountSignaled = signalAmount.sub(deposit.signaledAmounts[msg.sender]);\n            totalAmountSignaledByHolder[msg.sender] = totalAmountSignaledByHolder[msg.sender].add(deltaAmountSignaled);\n        }\n\n        // update total amount signaled for deposit\n        deposit.totalAmountSignaled = deposit.totalAmountSignaled.sub(deposit.signaledAmounts[msg.sender]);\n        deposit.totalAmountSignaled = deposit.totalAmountSignaled.add(signalAmount);\n        // update the signaled amount of holder\n        deposit.signaledAmounts[msg.sender] = signalAmount;\n    }\n\n    /**\n     * @notice Issuer can push funds to provided addresses\n     * @param depositId Id of the deposit\n     * @param payees Addresses to which to push the funds\n     */\n    function pushFundsToAddresses(\n        bytes32 depositId,\n        address payable[] memory payees\n    )\n        public\n    {\n        Deposit storage deposit = deposits[depositId];\n\n        for (uint256 i = 0; i < payees.length; i++) {\n            if (deposit.claimed[payees[i]] == false) {\n                transferDeposit(payees[i], deposit, depositId);\n            }\n        }\n    }\n\n    /**\n     * @notice Withdraws the holders share of funds of the deposit\n     * @param depositId Id of the deposit\n     */\n    function claimDeposit(bytes32 depositId) public {\n        Deposit storage deposit = deposits[depositId];\n\n        require(\n            deposit.claimed[msg.sender] == false,\n            \"Deposit.claimDeposit: DEPOSIT_ALREADY_CLAIMED\"\n        );\n\n        transferDeposit(msg.sender, deposit, depositId);\n    }\n\n    /**\n     * @notice Internal function for transferring deposits\n     * @param payee Address of holder\n     * @param deposit Pointer to deposit in storage\n     */\n    function transferDeposit(\n        address payee,\n        Deposit storage deposit,\n        bytes32 depositId\n    )\n        internal\n        virtual\n        nonReentrant()\n    {\n        uint256 claim = calculateClaimOnDeposit(payee, depositId);\n\n        deposit.claimed[payee] = true;\n        deposit.claimedAmount = claim.add(deposit.claimedAmount);\n\n        // decrease total amount signaled by holder for all deposits by the holders signaled amount of the deposit\n        totalAmountSignaledByHolder[payee] = totalAmountSignaledByHolder[payee].sub(deposit.signaledAmounts[payee]);\n\n        if (claim > 0) {\n            require(\n                IERC20(deposit.token).transfer(payee, claim),\n                \"Deposit.transferDeposit: TRANSFER_FAILED\"\n            );\n        }\n    }\n\n    /**\n     * @notice Calculate claimable amount of a deposit for a given address\n     * @param payee Address of holder\n     * @param depositId Id of the deposit\n     * @return withdrawable amount\n     */\n    function calculateClaimOnDeposit(address payee, bytes32 depositId) public view returns(uint256) {\n        Deposit storage deposit = deposits[depositId];\n\n        if (deposit.claimed[payee]) return 0;\n\n        uint256 totalSupply = totalSupplyAt(deposit.scheduledFor);\n        // if deposit is marked as `onlySignaled` use the holders signaled amount\n        // instead of the holders checkpointed balance\n        uint256 balance = (deposit.onlySignaled)\n            ? deposit.signaledAmounts[payee]\n            : balanceOfAt(payee, deposit.scheduledFor);\n        // if deposit is marked as `onlySignaled` use the total amount signaled\n        // instead of the checkpointed total supply\n        uint256 claim = balance.mul(deposit.amount).div(\n            (deposit.onlySignaled) ? deposit.totalAmountSignaled : totalSupply\n        );\n\n        return claim;\n    }\n\n    /**\n     * @notice Returns params of a deposit\n     * @return scheduledFor\n     * @return amount\n     * @return claimedAmount\n     * @return totalAmountSignaled\n     * @return onlySignaled\n     * @return token\n     */\n    function getDeposit(bytes32 depositId)\n        public\n        view\n        returns (\n            uint256 scheduledFor,\n            uint256 amount,\n            uint256 claimedAmount,\n            uint256 totalAmountSignaled,\n            bool onlySignaled,\n            address token\n        )\n    {\n        Deposit storage deposit = deposits[depositId];\n\n        scheduledFor = deposit.scheduledFor;\n        amount = deposit.amount;\n        claimedAmount = deposit.claimedAmount;\n        totalAmountSignaled = deposit.totalAmountSignaled;\n        onlySignaled = deposit.onlySignaled;\n        token = deposit.token;\n    }\n\n    /**\n     * @notice Checks whether an address has withdrawn funds for a deposit\n     * @param depositId Id of the deposit\n     * @return bool whether the address has claimed\n     */\n    function hasClaimedDeposit(address holder, bytes32 depositId) external view returns (bool) {\n        return deposits[depositId].claimed[holder];\n    }\n}\n"
    },
    "contracts/Extensions/ICT/CheckpointedToken.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./Checkpoints.sol\";\n\n\ncontract CheckpointedToken is ERC20, Checkpoints {\n\n    using SafeMath for uint256;\n\n    // Checkpointed total supply\n    Checkpoint[] public checkpointTotalSupply;\n    // Map each holder to a series of checkpoints\n    mapping(address => Checkpoint[]) public checkpointBalances;\n    // holders\n    address[] public holders;\n    // holder => exists\n    mapping(address => bool) public holderExists;\n    // Number of holders with non-zero balance\n    uint256 public holderCount;\n\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}\n\n    /**\n     * @notice returns an array of holders with non zero balance at a given checkpoint\n     * @param checkpointId Checkpoint id at which holder list is to be populated\n     * @return list of holders\n     */\n    function getHoldersAt(uint256 checkpointId) public view returns(address[] memory) {\n        uint256 count;\n        uint256 i;\n        address[] memory activeHolders = holders;\n        for (i = 0; i < activeHolders.length; i++) {\n            if (balanceOfAt(activeHolders[i], checkpointId) > 0) {\n                count++;\n            } else {\n                activeHolders[i] = address(0);\n            }\n        }\n        address[] memory _holders = new address[](count);\n        count = 0;\n        for (i = 0; i < activeHolders.length; i++) {\n            if (activeHolders[i] != address(0)) {\n                _holders[count] = activeHolders[i];\n                count++;\n            }\n        }\n        return _holders;\n    }\n\n    function getHolderSubsetAt(\n        uint256 checkpointId,\n        uint256 start,\n        uint256 end\n    )\n        public\n        view\n        returns(address[] memory)\n    {\n        uint256 size = holders.length;\n        if (end >= size) {\n            size = size - start;\n        } else {\n            size = end - start + 1;\n        }\n        address[] memory holderSubset = new address[](size);\n        for(uint256 j; j < size; j++)\n            holderSubset[j] = holders[j + start];\n\n        uint256 count;\n        uint256 i;\n        for (i = 0; i < holderSubset.length; i++) {\n            if (balanceOfAt(holderSubset[i], checkpointId) > 0) {\n                count++;\n            } else {\n                holderSubset[i] = address(0);\n            }\n        }\n        address[] memory _holders = new address[](count);\n        count = 0;\n        for (i = 0; i < holderSubset.length; i++) {\n            if (holderSubset[i] != address(0)) {\n                _holders[count] = holderSubset[i];\n                count++;\n            }\n        }\n        return _holders;\n    }\n\n    function getNumberOfHolders() public view returns(uint256) {\n        return holders.length;\n    }\n\n    /**\n     * @notice Queries the balances of a holder at a specific timestamp\n     * @param holder Holder to query balance for\n     * @param timestamp Timestamp of the balance checkpoint\n     */\n    function balanceOfAt(address holder, uint256 timestamp) public view returns(uint256) {\n        return getValueAt(checkpointBalances[holder], timestamp);\n    }\n\n    /**\n     * @notice Queries totalSupply at a specific timestamp\n     * @param timestamp Timestamp of the totalSupply checkpoint\n     * @return uint256\n     */\n    function totalSupplyAt(uint256 timestamp) public view returns(uint256) {\n        return getValueAt(checkpointTotalSupply, timestamp);\n    }\n\n    function _isExistingHolder(address holder) internal view returns(bool) {\n        return holderExists[holder];\n    }\n\n    function _adjustHolderCount(address from, address to, uint256 value) internal {\n        if ((value == 0) || (from == to)) {\n            return;\n        }\n        // Check whether receiver is a new token holder\n        if ((balanceOf(to) == 0) && (to != address(0))) {\n            holderCount = holderCount.add(1);\n            if (!_isExistingHolder(to)) {\n                holders.push(to);\n                holderExists[to] = true;\n            }\n        }\n        // Check whether sender is moving all of their tokens\n        if (value == balanceOf(from)) {\n            holderCount = holderCount.sub(1);\n        }\n    }\n\n    /**\n     * @notice Internal - adjusts totalSupply at checkpoint before a token transfer\n     */\n    function _adjustTotalSupplyCheckpoints() internal {\n        updateValueAtNow(checkpointTotalSupply, totalSupply());\n    }\n\n    /**\n     * @notice Internal - adjusts token holder balance at checkpoint before a token transfer\n     * @param holder address of the token holder affected\n     */\n    function _adjustBalanceCheckpoints(address holder) internal {\n        updateValueAtNow(checkpointBalances[holder], balanceOf(holder));\n    }\n\n    /**\n     * @notice Updates internal variables when performing a transfer\n     * @param from sender of transfer\n     * @param to receiver of transfer\n     * @param value value of transfer\n     */\n    function _updateTransfer(address from, address to, uint256 value) internal {\n        _adjustHolderCount(from, to, value);\n        _adjustTotalSupplyCheckpoints();\n        _adjustBalanceCheckpoints(from);\n        _adjustBalanceCheckpoints(to);\n    }\n\n    function _mint(\n        address tokenHolder,\n        uint256 value\n    )\n        internal\n        override\n    {\n        super._mint(tokenHolder, value);\n        _updateTransfer(address(0), tokenHolder, value);\n    }\n\n    function _burn(\n        address tokenHolder,\n        uint256 value\n    )\n        internal\n        override\n    {\n        super._burn(tokenHolder, value);\n        _updateTransfer(tokenHolder, address(0), value);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    )\n        internal\n        virtual\n        override\n    {\n        super._transfer(from, to, value);\n        _updateTransfer(from, to, value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/Extensions/ICT/Checkpoints.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\n\ncontract Checkpoints {\n\n    // Emit when new checkpoint created\n    event CheckpointCreated(uint256 indexed checkpointId);\n\n    /** \n     * @dev `Checkpoint` is the structure that attaches a timestamp to a \n     * given value, the timestamp attached is the one that last changed the value\n     */\n    struct Checkpoint {\n        // `timestamp` is the timestamp that the value was generated from\n        uint128 timestamp;\n        // `value` is the amount of tokens at a specific timestamp\n        uint256 value;\n    }\n\n    /**\n     * @notice Queries a value at a defined checkpoint\n     * @param checkpoints array of Checkpoint objects\n     * @param timestamp timestamp to retrieve the value at\n     * @return uint256\n     */\n    function getValueAt(\n        Checkpoint[] storage checkpoints,\n        uint256 timestamp\n    ) \n        internal\n        view \n        returns (uint256)\n    {\n        // initially return 0\n        if (checkpoints.length == 0) return 0;\n\n        // Shortcut for the actual value\n        if (timestamp >= checkpoints[checkpoints.length - 1].timestamp)\n            return checkpoints[checkpoints.length - 1].value;\n        if (timestamp < checkpoints[0].timestamp) return 0;\n\n        // Binary search of the value in the array\n        uint256 min = 0;\n        uint256 max = checkpoints.length - 1;\n        while (max > min) {\n            uint256 mid = (max + min + 1) / 2;\n            if (checkpoints[mid].timestamp <= timestamp) {\n                min = mid;\n            } else {\n                max = mid - 1;\n            }\n        }\n        return checkpoints[min].value;\n    }\n\n    /**\n     * @notice Create a new checkpoint for a value if\n     * there does not exist a checkpoint for the current block timestamp,\n     * otherwise updates the value of the current checkpoint.\n     * @param checkpoints Checkpointed values\n     * @param value Value to be updated\n     */ \n    function updateValueAtNow(\n        Checkpoint[] storage checkpoints,\n        uint value\n    )\n        internal\n    {\n        // create a new checkpoint if:\n        // - there are no checkpoints\n        // - the current block has a greater timestamp than the last checkpoint\n        // otherwise update value at current checkpoint\n        if (\n            checkpoints.length == 0\n            || (block.timestamp > checkpoints[checkpoints.length - 1].timestamp)\n        ) {\n            // create checkpoint with value\n            checkpoints.push(Checkpoint({ timestamp: uint128(block.timestamp), value: value }));\n\n            emit CheckpointCreated(checkpoints.length - 1);\n            \n        } else {\n            // update value at current checkpoint\n            Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length - 1];\n            oldCheckPoint.value = value;\n        }\n    }\n}"
    },
    "contracts/SettlementToken.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\ninterface ERC20Interface {\n    event Transfer(address indexed from, address indexed to, uint tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n    \n    function transfer(address to, uint tokens) external returns (bool success);\n    function transferFrom(address from, address to, uint tokens) external returns (bool success);\n    function approve(address spender, uint tokens) external returns (bool success);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address tokenOwner) external view returns (uint balance);\n    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\n}\n\ninterface FaucetInterface {\n    function drip(address receiver, uint tokens) external;\n}\n\ninterface ApproveAndCallFallBack {\n    function receiveApproval(address from, uint256 tokens, address token, bytes calldata data) external;\n}\n\ncontract SettlementToken is ERC20, FaucetInterface, Ownable {\n    using SafeMath for uint256;\n\n    constructor() ERC20(\"STLMT\", \"Settlement Token\") {\n        uint256 amount = 1000000 * (10**18);\n        _mint(msg.sender, amount);\n    }\n\n    function approveAndCall(address spender, uint256 tokens, bytes memory data) public returns (bool success) {\n        // allowed[msg.sender][spender] = tokens;\n        // emit Approval(msg.sender, spender, tokens);\n        _approve(msg.sender, spender, tokens);\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\n        return true;\n    }\n\n    function drip(address receiver, uint256 tokens) public override {\n        _mint(receiver, tokens);\n    }\n\n    function transferAnyERC20Token(address tokenAddress, uint256 tokens) public onlyOwner returns (bool success) {\n        return IERC20(tokenAddress).transfer(owner(), tokens);\n    }\n}\n"
    },
    "contracts/NoSettlementToken.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\ninterface ERC20Interface {\n    event Transfer(address indexed from, address indexed to, uint tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n    \n    function transfer(address to, uint tokens) external returns (bool success);\n    function transferFrom(address from, address to, uint tokens) external returns (bool success);\n    function approve(address spender, uint tokens) external returns (bool success);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address tokenOwner) external view returns (uint balance);\n    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\n}\n\ncontract NoSettlementToken is ERC20Interface {\n\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n\n    constructor() {\n        symbol = \"NO_STLMT\";\n        name = \"No Settlement Token\";\n        decimals = 18;\n    }\n    \n    function transfer(address to, uint tokens) external override returns (bool success) {\n        emit Transfer(msg.sender, to, tokens);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint tokens) external override returns (bool success) {\n        emit Transfer(from, to, tokens);\n        return true;\n    }\n\n    function approve(address spender, uint tokens) external override returns (bool success) {\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n\n    function totalSupply() external pure override returns (uint) {\n        return ~uint256(0);\n    }\n\n    function balanceOf(address /* tokenOwner */) external pure override returns (uint balance) {\n        return ~uint256(0);\n    }\n\n    function allowance(address /* tokenOwner */, address /* spender */) external pure override returns (uint remaining) {\n        return ~uint256(0);\n    }\n}\n"
    },
    "contracts/Extensions/FDT/FundsDistributionToken.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\n\nimport \"../../external/math/SafeConversion.sol\";\nimport \"./IFundsDistributionToken.sol\";\n\n\n/**\n * @title FundsDistributionToken\n * @author Johannes Escherich\n * @author Roger-Wu\n * @author Johannes Pfeffer\n * @author Tom Lam\n * @dev A  mintable token that can represent claims on cash flow of arbitrary assets such as dividends, loan repayments,\n * fee or revenue shares among large numbers of token holders. Anyone can deposit funds, token holders can withdraw\n * their claims.\n * FundsDistributionToken (FDT) implements the accounting logic. FDT-Extension contracts implement methods for depositing and\n * withdrawing funds in Ether or according to a token standard such as ERC20, ERC223, ERC777.\n */\nabstract contract FundsDistributionToken is IFundsDistributionToken, ERC20 {\n\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    using SafeConversion for uint256;\n    using SafeConversion for int256;\n\n    // optimize, see https://github.com/ethereum/EIPs/issues/1726#issuecomment-472352728\n    uint256 constant internal pointsMultiplier = 2**128;\n    uint256 internal pointsPerShare;\n\n    mapping(address => int256) internal pointsCorrection;\n    mapping(address => uint256) internal withdrawnFunds;\n\n\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}\n\n    /**\n     * prev. distributeDividends\n     * @notice Distributes funds to token holders.\n     * @dev It reverts if the total supply of tokens is 0.\n     * It emits the `FundsDistributed` event if the amount of received ether is greater than 0.\n     * About undistributed funds:\n     *   In each distribution, there is a small amount of funds which does not get distributed,\n     *     which is `(msg.value * pointsMultiplier) % totalSupply()`.\n     *   With a well-chosen `pointsMultiplier`, the amount funds that are not getting distributed\n     *     in a distribution can be less than 1 (base unit).\n     *   We can actually keep track of the undistributed ether in a distribution\n     *     and try to distribute it in the next distribution ....... todo implement\n     */\n    function _distributeFunds(uint256 value) internal {\n        require(totalSupply() > 0, \"FundsDistributionToken._distributeFunds: SUPPLY_IS_ZERO\");\n\n        if (value > 0) {\n            pointsPerShare = pointsPerShare.add(\n                value.mul(pointsMultiplier) / totalSupply()\n            );\n            emit FundsDistributed(msg.sender, value);\n        }\n    }\n\n    /**\n     * prev. withdrawDividend\n     * @notice Prepares funds withdrawal\n     * @dev It emits a `FundsWithdrawn` event if the amount of withdrawn ether is greater than 0.\n     */\n    function _prepareWithdrawFor(address _owner) internal returns (uint256) {\n        uint256 _withdrawableDividend = withdrawableFundsOf(_owner);\n\n        withdrawnFunds[_owner] = withdrawnFunds[_owner].add(_withdrawableDividend);\n\n        emit FundsWithdrawn(_owner, _withdrawableDividend);\n\n        return _withdrawableDividend;\n    }\n\n    /**\n     * prev. withdrawableDividendOf\n     * @notice View the amount of funds that an address can withdraw.\n     * @param _owner The address of a token holder.\n     * @return The amount funds that `_owner` can withdraw.\n     */\n    function withdrawableFundsOf(address _owner) public view override returns(uint256) {\n        return accumulativeFundsOf(_owner).sub(withdrawnFunds[_owner]);\n    }\n\n    /**\n     * prev. withdrawnDividendOf\n     * @notice View the amount of funds that an address has withdrawn.\n     * @param _owner The address of a token holder.\n     * @return The amount of funds that `_owner` has withdrawn.\n     */\n    function withdrawnFundsOf(address _owner) public view returns(uint256) {\n        return withdrawnFunds[_owner];\n    }\n\n    /**\n     * prev. accumulativeDividendOf\n     * @notice View the amount of funds that an address has earned in total.\n     * @dev accumulativeFundsOf(_owner) = withdrawableFundsOf(_owner) + withdrawnFundsOf(_owner)\n     * = (pointsPerShare * balanceOf(_owner) + pointsCorrection[_owner]) / pointsMultiplier\n     * @param _owner The address of a token holder.\n     * @return The amount of funds that `_owner` has earned in total.\n     */\n    function accumulativeFundsOf(address _owner) public view returns(uint256) {\n        return pointsPerShare.mul(balanceOf(_owner)).toInt256Safe()\n            .add(pointsCorrection[_owner]).toUint256Safe() / pointsMultiplier;\n    }\n\n    /**\n     * @dev Internal function that transfer tokens from one address to another.\n     * Update pointsCorrection to keep funds unchanged.\n     * @param from The address to transfer from.\n     * @param to The address to transfer to.\n     * @param value The amount to be transferred.\n     */\n    function _transfer(address from, address to, uint256 value) internal override {\n        super._transfer(from, to, value);\n\n        int256 _magCorrection = pointsPerShare.mul(value).toInt256Safe();\n        pointsCorrection[from] = pointsCorrection[from].add(_magCorrection);\n        pointsCorrection[to] = pointsCorrection[to].sub(_magCorrection);\n    }\n\n    /**\n     * @dev Internal function that mints tokens to an account.\n     * Update pointsCorrection to keep funds unchanged.\n     * @param account The account that will receive the created tokens.\n     * @param value The amount that will be created.\n     */\n    function _mint(address account, uint256 value) internal override {\n        super._mint(account, value);\n\n        pointsCorrection[account] = pointsCorrection[account]\n            .sub( (pointsPerShare.mul(value)).toInt256Safe() );\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given account.\n     * Update pointsCorrection to keep funds unchanged.\n     * @param account The account whose tokens will be burnt.\n     * @param value The amount that will be burnt.\n     */\n    function _burn(address account, uint256 value) internal override {\n        super._burn(account, value);\n\n        pointsCorrection[account] = pointsCorrection[account]\n            .add( (pointsPerShare.mul(value)).toInt256Safe() );\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SignedSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @title SignedSafeMath\n * @dev Signed math operations with safety checks that revert on error.\n */\nlibrary SignedSafeMath {\n    int256 constant private _INT256_MIN = -2**255;\n\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\n\n        int256 c = a * b;\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, \"SignedSafeMath: division by zero\");\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\n\n        int256 c = a / b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\n\n        return c;\n    }\n}\n"
    },
    "contracts/external/math/SafeConversion.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\n\n/**\n * @title SafeConversion\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeConversion {\n    function toUint256Safe(int256 a) internal pure returns (uint256) {\n        require(a >= 0);\n        return uint256(a);\n    }\n\n    function toInt256Safe(uint256 a) internal pure returns (int256) {\n        int256 b = int256(a);\n        require(b >= 0);\n        return b;\n    }\n}"
    },
    "contracts/Extensions/FDT/IFundsDistributionToken.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\n\n\ninterface IFundsDistributionToken {\n\n    /**\n     * @dev Returns the total amount of funds a given address is able to withdraw currently.\n     * @param owner Address of FundsDistributionToken holder\n     * @return A uint256 representing the available funds for a given account\n     */\n    function withdrawableFundsOf(address owner) external view returns (uint256);\n\n    /**\n     * @dev Withdraws all available funds for a FundsDistributionToken holder.\n     */\n    function withdrawFunds() external;\n\n    /**\n     * @dev This event emits when new funds are distributed\n     * @param by the address of the sender who distributed funds\n     * @param fundsDistributed the amount of funds received for distribution\n     */\n    event FundsDistributed(address indexed by, uint256 fundsDistributed);\n\n    /**\n     * @dev This event emits when distributed funds are withdrawn by a token holder.\n     * @param by the address of the receiver of funds\n     * @param fundsWithdrawn the amount of funds that were withdrawn\n     */\n    event FundsWithdrawn(address indexed by, uint256 fundsWithdrawn);\n}\n"
    },
    "contracts/Extensions/FDT/VanillaFDT/VanillaFDT.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\n\nimport \"../../../external/math/SafeConversion.sol\";\nimport \"../FundsDistributionToken.sol\";\nimport \"../IFundsDistributionToken.sol\";\n\n\ncontract VanillaFDT is\n    IFundsDistributionToken,\n    FundsDistributionToken,\n    Ownable\n{\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n    using SafeConversion for uint256;\n    using SafeConversion for int256;\n\n\n    // token in which the funds can be sent to the FundsDistributionToken\n    IERC20 public fundsToken;\n\n    // balance of fundsToken that the FundsDistributionToken currently holds\n    uint256 public fundsTokenBalance;\n\n    modifier onlyFundsToken() {\n        require(\n            msg.sender == address(fundsToken),\n            \"VanillaFDT.onlyFundsToken: UNAUTHORIZED_SENDER\"\n        );\n        _;\n    }\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        IERC20 _fundsToken,\n        address owner,\n        uint256 initialAmount\n    )\n        FundsDistributionToken(name, symbol)\n    {\n        require(\n            address(_fundsToken) != address(0),\n            \"VanillaFDT: INVALID_FUNDS_TOKEN_ADDRESS\"\n        );\n\n        fundsToken = _fundsToken;\n        transferOwnership(owner);\n        _mint(owner, initialAmount);\n    }\n\n    /**\n     * @notice Withdraws all available funds for a token holder\n     */\n    function withdrawFunds() external override {\n        _withdrawFundsFor(msg.sender);\n    }\n\n    /**\n     * @notice Register a payment of funds in tokens. May be called directly after a deposit is made.\n     * @dev Calls _updateFundsTokenBalance(), whereby the contract computes the delta of the previous and the new\n     * funds token balance and increments the total received funds (cumulative) by delta by calling _registerFunds()\n     */\n    function updateFundsReceived() external {\n        int256 newFunds = _updateFundsTokenBalance();\n\n        if (newFunds > 0) {\n            _distributeFunds(newFunds.toUint256Safe());\n        }\n    }\n\n    /**\n     * @notice Withdraws funds for a set of token holders\n     */\n    function pushFunds(address[] memory owners) public {\n        for (uint256 i = 0; i < owners.length; i++) {\n            _withdrawFundsFor(owners[i]);\n        }\n    }\n\n    /**\n     * @notice Overrides the parent class token transfer function to enforce restrictions.\n     */\n    function transfer(address to, uint256 value) public override returns (bool) {\n        return super.transfer(to, value);\n    }\n\n    /**\n     * @notice Overrides the parent class token transferFrom function to enforce restrictions.\n     */\n    function transferFrom(address from, address to, uint256 value) public override returns (bool) {\n        return super.transferFrom(from, to, value);\n    }\n\n    /**\n     * @notice Exposes the ability to mint new FDTs for a given account. Caller has to be the owner of the FDT.\n     */\n    function mint(address account, uint256 amount) public onlyOwner returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n\n    /**\n     * @notice Exposes the ability to burn exisiting FDTs for a given account. Caller has to be the owner of the FDT.\n     */\n    function burn(address account, uint256 amount) public onlyOwner returns (bool) {\n        _burn(account, amount);\n        return true;\n    }\n\n    /**\n     * @notice Withdraws all available funds for a token holder\n     */\n    function _withdrawFundsFor(address owner) internal {\n        uint256 withdrawableFunds = _prepareWithdrawFor(owner);\n\n        require(\n            fundsToken.transfer(owner, withdrawableFunds),\n            \"VanillaFDT.withdrawFunds: TRANSFER_FAILED\"\n        );\n\n        _updateFundsTokenBalance();\n    }\n\n    /**\n     * @dev Updates the current funds token balance\n     * and returns the difference of new and previous funds token balances\n     * @return A int256 representing the difference of the new and previous funds token balance\n     */\n    function _updateFundsTokenBalance() internal returns (int256) {\n        uint256 prevFundsTokenBalance = fundsTokenBalance;\n\n        fundsTokenBalance = fundsToken.balanceOf(address(this));\n\n        return int256(fundsTokenBalance).sub(int256(prevFundsTokenBalance));\n    }\n}\n"
    },
    "contracts/Extensions/FDT/SimpleRestrictedFDT/SimpleRestrictedFDT.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\n\nimport \"../../../external/math/SafeConversion.sol\";\nimport \"../FundsDistributionToken.sol\";\nimport \"../IFundsDistributionToken.sol\";\n\n\n/**\n * @notice This contract allows a list of administrators to be tracked. This list can then be enforced\n * on functions with administrative permissions.  Only the owner of the contract should be allowed\n * to modify the administrator list.\n */\ncontract Administratable is Ownable {\n    // The mapping to track administrator accounts - true is reserved for admin addresses.\n    mapping(address => bool) public administrators;\n\n    // Events to allow tracking add/remove.\n    event AdminAdded(address indexed addedAdmin, address indexed addedBy);\n    event AdminRemoved(address indexed removedAdmin, address indexed removedBy);\n\n    /**\n     * @notice Function modifier to enforce administrative permissions.\n     */\n    modifier onlyAdministrator() {\n        require(\n            isAdministrator(msg.sender),\n            \"Calling account is not an administrator.\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Add an admin to the list.  This should only be callable by the owner of the contract.\n     */\n    function addAdmin(address adminToAdd) public onlyOwner {\n        // Verify the account is not already an admin\n        require(\n            administrators[adminToAdd] == false,\n            \"Account to be added to admin list is already an admin\"\n        );\n\n        // Set the address mapping to true to indicate it is an administrator account.\n        administrators[adminToAdd] = true;\n\n        // Emit the event for any watchers.\n        emit AdminAdded(adminToAdd, msg.sender);\n    }\n\n    /**\n     * @notice Remove an admin from the list.  This should only be callable by the owner of the contract.\n     */\n    function removeAdmin(address adminToRemove) public onlyOwner {\n        // Verify the account is an admin\n        require(\n            administrators[adminToRemove] == true,\n            \"Account to be removed from admin list is not already an admin\"\n        );\n\n        // Set the address mapping to false to indicate it is NOT an administrator account.\n        administrators[adminToRemove] = false;\n\n        // Emit the event for any watchers.\n        emit AdminRemoved(adminToRemove, msg.sender);\n    }\n\n    /**\n     * @notice Determine if the message sender is in the administrators list.\n     */\n    function isAdministrator(address addressToTest) public view returns (bool) {\n        return administrators[addressToTest];\n    }\n}\n\n/**\n * @notice Keeps track of whitelists and can check if sender and reciever are configured to allow a transfer.\n * Only administrators can update the whitelists.\n * Any address can only be a member of one whitelist at a time.\n */\ncontract Whitelistable is Administratable {\n    // Zero is reserved for indicating it is not on a whitelist\n    uint8 constant internal NO_WHITELIST = 0;\n\n    // The mapping to keep track of which whitelist any address belongs to.\n    // 0 is reserved for no whitelist and is the default for all addresses.\n    mapping(address => uint8) public addressWhitelists;\n\n    // The mapping to keep track of each whitelist's outbound whitelist flags.\n    // Boolean flag indicates whether outbound transfers are enabled.\n    mapping(uint8 => mapping(uint8 => bool)) public outboundWhitelistsEnabled;\n\n    // Events to allow tracking add/remove.\n    event AddressAddedToWhitelist(\n        address indexed addedAddress,\n        uint8 indexed whitelist,\n        address indexed addedBy\n    );\n    event AddressRemovedFromWhitelist(\n        address indexed removedAddress,\n        uint8 indexed whitelist,\n        address indexed removedBy\n    );\n    event OutboundWhitelistUpdated(\n        address indexed updatedBy,\n        uint8 indexed sourceWhitelist,\n        uint8 indexed destinationWhitelist,\n        bool from,\n        bool to\n    );\n\n    /**\n     * @notice Sets an address's white list ID.  Only administrators should be allowed to update this.\n     * If an address is on an existing whitelist, it will just get updated to the new value (removed from previous).\n     */\n    function addToWhitelist(address addressToAdd, uint8 whitelist)\n        public\n        onlyAdministrator\n    {\n        // Verify the whitelist is valid\n        require(whitelist != NO_WHITELIST, \"Invalid whitelist ID supplied\");\n\n        // Save off the previous white list\n        uint8 previousWhitelist = addressWhitelists[addressToAdd];\n\n        // Set the address's white list ID\n        addressWhitelists[addressToAdd] = whitelist;\n\n        // If the previous whitelist existed then we want to indicate it has been removed\n        if (previousWhitelist != NO_WHITELIST) {\n            // Emit the event for tracking\n            emit AddressRemovedFromWhitelist(\n                addressToAdd,\n                previousWhitelist,\n                msg.sender\n            );\n        }\n\n        // Emit the event for new whitelist\n        emit AddressAddedToWhitelist(addressToAdd, whitelist, msg.sender);\n    }\n\n    /**\n     * @notice Clears out an address's white list ID.  Only administrators should be allowed to update this.\n     */\n    function removeFromWhitelist(address addressToRemove)\n        public\n        onlyAdministrator\n    {\n        // Save off the previous white list\n        uint8 previousWhitelist = addressWhitelists[addressToRemove];\n\n        // Zero out the previous white list\n        addressWhitelists[addressToRemove] = NO_WHITELIST;\n\n        // Emit the event for tracking\n        emit AddressRemovedFromWhitelist(\n            addressToRemove,\n            previousWhitelist,\n            msg.sender\n        );\n    }\n\n    /**\n     * @notice Sets the flag to indicate whether source whitelist is allowed to send to destination whitelist.\n     * Only administrators should be allowed to update this.\n     */\n    function updateOutboundWhitelistEnabled(\n        uint8 sourceWhitelist,\n        uint8 destinationWhitelist,\n        bool newEnabledValue\n    ) public onlyAdministrator {\n        // Get the old enabled flag\n        bool oldEnabledValue = outboundWhitelistsEnabled[sourceWhitelist][destinationWhitelist];\n\n        // Update to the new value\n        outboundWhitelistsEnabled[sourceWhitelist][destinationWhitelist] = newEnabledValue;\n\n        // Emit event for tracking\n        emit OutboundWhitelistUpdated(\n            msg.sender,\n            sourceWhitelist,\n            destinationWhitelist,\n            oldEnabledValue,\n            newEnabledValue\n        );\n    }\n\n    /**\n     * @notice Determine if the a sender is allowed to send to the receiver.\n     * The source whitelist must be enabled to send to the whitelist where the receive exists.\n     */\n    function checkWhitelistAllowed(address sender, address receiver)\n        public\n        view\n        returns (bool)\n    {\n        // First get each address white list\n        uint8 senderWhiteList = addressWhitelists[sender];\n        uint8 receiverWhiteList = addressWhitelists[receiver];\n\n        // If either address is not on a white list then the check should fail\n        if (\n            senderWhiteList == NO_WHITELIST || receiverWhiteList == NO_WHITELIST\n        ) {\n            return false;\n        }\n\n        // Determine if the sending whitelist is allowed to send to the destination whitelist\n        return outboundWhitelistsEnabled[senderWhiteList][receiverWhiteList];\n    }\n}\n\n/**\n * @notice Restrictions start off as enabled. Once they are disabled, they cannot be re-enabled.\n * Only the owner may disable restrictions.\n */\ncontract Restrictable is Ownable {\n    // State variable to track whether restrictions are enabled.  Defaults to true.\n    bool private _restrictionsEnabled = true;\n\n    // Event emitted when flag is disabled\n    event RestrictionsDisabled(address indexed owner);\n\n    /**\n     * @notice Function to update the enabled flag on restrictions to disabled.  Only the owner should be able to call.\n     * This is a permanent change that cannot be undone\n     */\n    function disableRestrictions() public onlyOwner {\n        require(_restrictionsEnabled, \"Restrictions are already disabled.\");\n\n        // Set the flag\n        _restrictionsEnabled = false;\n\n        // Trigger the event\n        emit RestrictionsDisabled(msg.sender);\n    }\n\n    /**\n     * @notice View function to determine if restrictions are enabled\n     */\n    function isRestrictionEnabled() public view returns (bool) {\n        return _restrictionsEnabled;\n    }\n}\n\nabstract contract ERC1404 is IERC20 {\n\n    /**\n     * @notice Detects if a transfer will be reverted and if so returns an appropriate reference code\n     * @param from Sending address\n     * @param to Receiving address\n     * @param value Amount of tokens being transferred\n     * @return Code by which to reference message for rejection reasoning\n     * @dev Overwrite with your custom transfer restriction logic\n     */\n    function detectTransferRestriction(address from, address to, uint256 value)\n        public\n        view\n        virtual\n        returns (uint8);\n\n    /**\n     * @notice Returns a human-readable message for a given restriction code\n     * @param restrictionCode Identifier for looking up a message\n     * @return Text showing the restriction's reasoning\n     * @dev Overwrite with your custom message and restrictionCode handling\n     */\n    function messageForTransferRestriction(uint8 restrictionCode)\n        public\n        view\n        virtual\n        returns (string memory);\n}\n\ncontract SimpleRestrictedFDT is\n    IFundsDistributionToken,\n    FundsDistributionToken,\n    ERC1404,\n    Whitelistable,\n    Restrictable\n{\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n    using SafeConversion for uint256;\n    using SafeConversion for int256;\n\n    // ERC1404 Error codes and messages\n    uint8 public constant SUCCESS_CODE = 0;\n    uint8 public constant FAILURE_NON_WHITELIST = 1;\n    string public constant SUCCESS_MESSAGE = \"SUCCESS\";\n    string public constant FAILURE_NON_WHITELIST_MESSAGE = \"The transfer was restricted due to white list configuration.\";\n    string public constant UNKNOWN_ERROR = \"Unknown Error Code\";\n\n    // token in which the funds can be sent to the FundsDistributionToken\n    IERC20 public fundsToken;\n\n    // balance of fundsToken that the FundsDistributionToken currently holds\n    uint256 public fundsTokenBalance;\n\n    modifier onlyFundsToken() {\n        require(\n            msg.sender == address(fundsToken),\n            \"SimpleRestrictedFDT.onlyFundsToken: UNAUTHORIZED_SENDER\"\n        );\n        _;\n    }\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        IERC20 _fundsToken,\n        address owner,\n        uint256 initialAmount\n    )\n        FundsDistributionToken(name, symbol)\n    {\n        require(\n            address(_fundsToken) != address(0),\n            \"SimpleRestrictedFDT: INVALID_FUNDS_TOKEN_ADDRESS\"\n        );\n\n        fundsToken = _fundsToken;\n        transferOwnership(owner);\n        _mint(owner, initialAmount);\n    }\n\n    /**\n  \t * @notice Evaluates whether a transfer should be allowed or not.\n  \t */\n    modifier notRestricted(address from, address to, uint256 value) {\n        uint8 restrictionCode = detectTransferRestriction(from, to, value);\n        require(\n            restrictionCode == SUCCESS_CODE,\n            messageForTransferRestriction(restrictionCode)\n        );\n        _;\n    }\n\n    /**\n\t * @notice Withdraws all available funds for a token holder\n\t */\n    function withdrawFunds() external override {\n        _withdrawFundsFor(msg.sender);\n    }\n\n    /**\n\t * @notice Register a payment of funds in tokens. May be called directly after a deposit is made.\n\t * @dev Calls _updateFundsTokenBalance(), whereby the contract computes the delta of the previous and the new\n\t * funds token balance and increments the total received funds (cumulative) by delta by calling _registerFunds()\n\t */\n    function updateFundsReceived() external {\n        int256 newFunds = _updateFundsTokenBalance();\n\n        if (newFunds > 0) {\n            _distributeFunds(newFunds.toUint256Safe());\n        }\n    }\n\n    /**\n     * @notice Withdraws funds for a set of token holders\n     */\n    function pushFunds(address[] memory owners) public {\n        for (uint256 i = 0; i < owners.length; i++) {\n            _withdrawFundsFor(owners[i]);\n        }\n    }\n\n    /**\n  \t * @notice Overrides the parent class token transfer function to enforce restrictions.\n  \t */\n    function transfer(address to, uint256 value)\n        public\n        notRestricted(msg.sender, to, value)\n        override(IERC20, ERC20)\n        returns (bool success)\n    {\n        success = super.transfer(to, value);\n    }\n\n    /**\n  \t * @notice Overrides the parent class token transferFrom function to enforce restrictions.\n  \t */\n    function transferFrom(address from, address to, uint256 value)\n        public\n        notRestricted(from, to, value)\n        override(IERC20, ERC20)\n        returns (bool success)\n    {\n        success = super.transferFrom(from, to, value);\n    }\n\n    /**\n     * @notice Exposes the ability to mint new FDTs for a given account. Caller has to be the owner of the FDT.\n     */\n    function mint(address account, uint256 amount) public onlyOwner returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n\n    /**\n     * @notice Exposes the ability to burn exisiting FDTs for a given account. Caller has to be the owner of the FDT.\n     */\n    function burn(address account, uint256 amount) public onlyOwner returns (bool) {\n        _burn(account, amount);\n        return true;\n    }\n\n    /**\n  \t * @notice This function detects whether a transfer should be restricted and not allowed.\n  \t * If the function returns SUCCESS_CODE (0) then it should be allowed.\n  \t */\n    function detectTransferRestriction(address from, address to, uint256)\n        public\n        view\n        override\n        returns (uint8)\n    {\n        // If the restrictions have been disabled by the owner, then just return success\n        // Logic defined in Restrictable parent class\n        if (!isRestrictionEnabled()) {\n            return SUCCESS_CODE;\n        }\n\n        // If the contract owner is transferring, then ignore reistrictions\n        if (from == owner()) {\n            return SUCCESS_CODE;\n        }\n\n        // Restrictions are enabled, so verify the whitelist config allows the transfer.\n        // Logic defined in Whitelistable parent class\n        if (!checkWhitelistAllowed(from, to)) {\n            return FAILURE_NON_WHITELIST;\n        }\n\n        // If no restrictions were triggered return success\n        return SUCCESS_CODE;\n    }\n\n    /**\n  \t * @notice This function allows a wallet or other client to get a human readable string to show\n  \t * a user if a transfer was restricted.  It should return enough information for the user\n  \t * to know why it failed.\n  \t */\n    function messageForTransferRestriction(uint8 restrictionCode)\n        public\n        pure\n        override\n        returns (string memory)\n    {\n        if (restrictionCode == SUCCESS_CODE) {\n            return SUCCESS_MESSAGE;\n        }\n\n        if (restrictionCode == FAILURE_NON_WHITELIST) {\n            return FAILURE_NON_WHITELIST_MESSAGE;\n        }\n\n        // An unknown error code was passed in.\n        return UNKNOWN_ERROR;\n    }\n\n    /**\n     * @notice Withdraws all available funds for a token holder\n     */\n    function _withdrawFundsFor(address owner) internal {\n        uint256 withdrawableFunds = _prepareWithdrawFor(owner);\n\n        require(\n            fundsToken.transfer(owner, withdrawableFunds),\n            \"SimpleRestrictedFDT.withdrawFunds: TRANSFER_FAILED\"\n        );\n\n        _updateFundsTokenBalance();\n    }\n\n    /**\n\t * @dev Updates the current funds token balance\n\t * and returns the difference of new and previous funds token balances\n\t * @return A int256 representing the difference of the new and previous funds token balance\n\t */\n    function _updateFundsTokenBalance() internal returns (int256) {\n        uint256 prevFundsTokenBalance = fundsTokenBalance;\n\n        fundsTokenBalance = fundsToken.balanceOf(address(this));\n\n        return int256(fundsTokenBalance).sub(int256(prevFundsTokenBalance));\n    }\n}\n"
    },
    "contracts/Extensions/FDT/CMTA20FDT/CMTA20FDT.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\n\nimport \"../../../external/math/SafeConversion.sol\";\nimport \"../FundsDistributionToken.sol\";\nimport \"../IFundsDistributionToken.sol\";\n\n\n/**\n * @title IContactable\n * @dev IContactable interface\n * @author Sébastien Krafft - <sebastien.krafft@mtpelerin.com>\n */\ninterface IContactable {\n  /**\n   * @notice Purpose: this event is emitted when the contact information is changed\n   * @param contact - new contact information\n   */\n  event LogContactSet(string contact);\n\n  function setContact(string calldata _contact) external;\n  function contact() external view returns (string memory);\n}\n\n/**\n * @title IDestroyable\n * @dev IDestroyable interface\n * @author Sébastien Krafft - <sebastien.krafft@mtpelerin.com>\n */\ninterface IDestroyable {\n  /**\n   * @notice Purpose: this event is emitted when issued tokens are destroyed.\n   * @param shareholders - list of shareholders of destroyed tokens\n   */\n  event LogDestroyed(address[] shareholders);\n\n  /**\n   * @notice Purpose: to destroy issued tokens.\n   * Conditions: only issuer can execute this function.\n   * @param shareholders - list of shareholders\n   */\n  function destroy(address[] calldata shareholders) external;\n}\n\n/**\n * @title IIdentifiable\n * @dev IIdentifiable interface\n * @author Sébastien Krafft - <sebastien.krafft@mtpelerin.com>\n */\ninterface IIdentifiable {\n  function setMyIdentity(bytes calldata _identity) external;\n  function identity(address shareholder) external view returns (bytes memory);\n}\n\n/**\n * @title IIssuable\n * @dev IIssuable interface\n * @author Sébastien Krafft - <sebastien.krafft@mtpelerin.com>\n */\ninterface IIssuable {\n  /**\n   * @notice Purpose: this event is emitted when new tokens are issued.\n   * @param value - amount of newly issued tokens\n   */\n  event LogIssued(uint256 value);\n  /**\n  * @notice Purpose: this event is emitted when tokens are redeemed.\n  * @param value - amount of redeemed tokens\n  */\n  event LogRedeemed(uint256 value);\n\n  function issue(uint256 value) external;\n  function redeem(uint256 value) external;\n}\n\n/**\n * @title IReassignable\n * @dev IReassignable interface\n * @author Sébastien Krafft - <sebastien.krafft@mtpelerin.com>\n */\ninterface IReassignable {\n  /**\n   * @notice Purpose: to withdraw tokens from the original address and\n   * transfer those tokens to the replacement address.\n   * Use in cases when e.g. investor loses access to his account.\n   * Conditions:\n   * Throw error if the `original` address supplied is not a shareholder.\n   * Throw error if the 'replacement' address already holds tokens.\n   * Original address MUST NOT be reused again.\n   * Only issuer can execute this function.\n   * @param original - original address\n   * @param replacement - replacement address\n   */\n  function reassign(address original, address replacement) external;\n\n  /**\n   * @notice Purpose: this event is emitted when tokens are withdrawn from one address and issued to a new one.\n   * @param original - original address\n   * @param replacement - replacement address\n   * @param value - amount transfered from original to replacement\n   */\n  event LogReassigned(address indexed original, address indexed replacement, uint256 value);\n}\n\n/**\n * @title IRule\n * @dev IRule interface.\n */\ninterface IRule {\n  function isTransferValid(address _from, address _to, uint256 _amount) external view returns (bool isValid);\n  function detectTransferRestriction(address _from, address _to, uint256 _amount) external view returns (uint8);\n  function canReturnTransferRestrictionCode(uint8 _restrictionCode) external view returns (bool);\n  function messageForTransferRestriction(uint8 _restrictionCode) external view returns (string memory);\n}\n\n/**\n * @title IRuleEngine\n * @dev IRuleEngine \n */\ninterface IRuleEngine {\n  function setRules(IRule[] calldata _rules) external;\n  function ruleLength() external view returns (uint256);\n  function rule(uint256 ruleId) external view returns (IRule);\n  function rules() external view returns(IRule[] memory);\n  function validateTransfer(address _from, address _to, uint256 _amount) external view returns (bool);\n  function detectTransferRestriction(address _from, address _to, uint256 _value) external view returns (uint8);\n  function messageForTransferRestriction (uint8 _restrictionCode) external view returns (string memory);\n}\n\ncontract CMTA20FDT is\n    IFundsDistributionToken,\n    FundsDistributionToken,\n    Ownable,\n    Pausable,\n    IContactable,\n    IIdentifiable,\n    IIssuable,\n    IDestroyable,\n    IReassignable\n{\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n    using SafeConversion for uint256;\n    using SafeConversion for int256;\n\n    // token in which the funds can be sent to the FundsDistributionToken\n    IERC20 public fundsToken;\n\n    // balance of fundsToken that the FundsDistributionToken currently holds\n    uint256 public fundsTokenBalance;\n\n    // CMTA20 params\n    uint8 internal constant TRANSFER_OK = 0;\n    uint8 internal constant TRANSFER_REJECTED_PAUSED = 1;\n    string internal constant TEXT_TRANSFER_OK = \"No restriction\";\n    string internal constant TEXT_TRANSFER_REJECTED_PAUSED = \"All transfers paused\";\n    string public override contact;\n    mapping (address => bytes) internal identities;\n    IRuleEngine public ruleEngine;\n\n    event LogRuleEngineSet(address indexed newRuleEngine);\n\n\n    modifier onlyFundsToken() {\n        require(\n            msg.sender == address(fundsToken),\n            \"CMTA20FDT.onlyFundsToken: UNAUTHORIZED_SENDER\"\n        );\n        _;\n    }\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        IERC20 _fundsToken,\n        address owner,\n        uint256 initialAmount\n    )\n        FundsDistributionToken(name, symbol)\n    {\n        require(\n            address(_fundsToken) != address(0),\n            \"CMTA20FDT: INVALID_FUNDS_TOKEN_ADDRESS\"\n        );\n\n        fundsToken = _fundsToken;\n\n        transferOwnership(owner);\n        _mint(owner, initialAmount);\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     */\n    function pause() external whenNotPaused onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @dev Returns to normal state.\n     */\n    function unpause() external whenPaused onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @notice Purpose: set optional rule engine by owner()\n     * @param _ruleEngine - the rule engine that will approve/reject transfers\n     */\n    function setRuleEngine(IRuleEngine _ruleEngine) external onlyOwner {\n        ruleEngine = _ruleEngine;\n        emit LogRuleEngineSet(address(_ruleEngine));\n    }\n\n    /**\n     * @notice Purpose: set contact point for shareholders\n     * @param _contact - the contact information for the shareholders\n     */\n    function setContact(string calldata _contact) external override onlyOwner {\n        contact = _contact;\n        emit LogContactSet(_contact);\n    }\n\n    /**\n     * Purpose\n     * Set identity of a potential/actual shareholder. Can only be called by the potential/actual shareholder himself. Has to be encrypted data.\n     * \n     * @param _identity - the potential/actual shareholder identity\n     */\n    function setMyIdentity(bytes calldata _identity) external override {\n        identities[msg.sender] = _identity;\n    }\n\n    /**\n     * @notice Withdraws all available funds for a token holder\n     */\n    function withdrawFunds() external override whenNotPaused {\n        _withdrawFundsFor(msg.sender);\n    }\n\n    /**\n     * @notice Register a payment of funds in tokens. May be called directly after a deposit is made.\n     * @dev Calls _updateFundsTokenBalance(), whereby the contract computes the delta of the previous and the new\n     * funds token balance and increments the total received funds (cumulative) by delta by calling _registerFunds()\n     */\n    function updateFundsReceived() external whenNotPaused {\n        int256 newFunds = _updateFundsTokenBalance();\n\n        if (newFunds > 0) {\n            _distributeFunds(newFunds.toUint256Safe());\n        }\n    }\n\n    /**\n     * @notice Purposee: to withdraw tokens from the original address and\n     * transfer those tokens to the replacement address.\n     * Use in cases when e.g. investor loses access to his account.\n     * Conditions: throw error if the `original` address supplied is not a shareholder.\n     * Only issuer can execute this function.\n     * @param original - original address\n     * @param replacement - replacement address\n     */\n    function reassign(address original, address replacement) external override onlyOwner whenNotPaused {\n        require(original != address(0), \"CM01\");\n        require(replacement != address(0), \"CM02\");\n        require(original != replacement, \"CM03\");\n\n        uint256 originalBalance = balanceOf(original);\n        require(originalBalance != 0, \"CM05\");\n\n        _burn(original, originalBalance);\n        _mint(replacement, originalBalance);\n        \n        emit LogReassigned(original, replacement, originalBalance);\n        emit Transfer(original, replacement, originalBalance);\n    }\n\n    /**\n     * @notice Purpose: to destroy issued tokens.\n     * Conditions: only issuer can execute this function.\n     * @param shareholders - list of shareholders\n    */\n    function destroy(address[] calldata shareholders) external override whenNotPaused onlyOwner {\n        for (uint256 i = 0; i < shareholders.length; i++) {\n            require(shareholders[i] != owner(), \"CM06\");\n            uint256 shareholderBalance = balanceOf(shareholders[i]);\n            _burn(shareholders[i], balanceOf(shareholders[i]));\n            _mint(owner(), shareholderBalance);\n            emit Transfer(shareholders[i], owner(), shareholderBalance);\n        }\n        emit LogDestroyed(shareholders);\n    }\n\n    /**\n     * Purpose\n     * Retrieve identity of a potential/actual shareholder\n     */\n    function identity(address shareholder) external view override returns (bytes memory) {\n        return identities[shareholder];\n    }\n\n    /**\n     * @notice Withdraws funds for a set of token holders\n     */\n    function pushFunds(address[] memory owners) public whenNotPaused {\n        for (uint256 i = 0; i < owners.length; i++) {\n            _withdrawFundsFor(owners[i]);\n        }\n    }\n\n    /**\n     * @notice Overrides the parent class token transfer function to enforce restrictions.\n    */\n    function transfer(address to, uint256 value) public override whenNotPaused returns (bool) {\n        if (address(ruleEngine) != address(0)) {\n            require(ruleEngine.validateTransfer(msg.sender, to, value), \"CM04\");\n            return super.transfer(to, value);\n        } else {\n            return super.transfer(to, value);\n        }\n    }\n\n    /**\n     * @notice Overrides the parent class token transferFrom function to enforce restrictions.\n     */\n    function transferFrom(address from, address to, uint256 value) public override whenNotPaused returns (bool) {\n        if (address(ruleEngine) != address(0)) {\n            require(ruleEngine.validateTransfer(from, to, value), \"CM04\");\n            return super.transferFrom(from, to, value);\n        } else {\n            return super.transferFrom(from, to, value);\n        }\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n     * @param _spender The address which will spend the funds.\n     * @param _value The amount of tokens to be spent.\n     */\n    function approve(address _spender, uint256 _value) public override whenNotPaused returns (bool) {\n        return super.approve(_spender, _value);\n    }\n\n    /**\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n     * @param _spender The address which will spend the funds.\n     * @param _addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) public override whenNotPaused returns (bool) {\n        return super.increaseAllowance(_spender, _addedValue);\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     * @param _spender The address which will spend the funds.\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) public override whenNotPaused returns (bool) {\n        return super.decreaseAllowance(_spender, _subtractedValue);\n    }\n\n    /**\n     * @notice Purpose: Issue tokens on the owner() address\n     * @param _value - amount of newly issued tokens\n     */\n    function issue(uint256 _value) public override whenNotPaused onlyOwner {\n        _mint(owner(), _value);\n        emit Transfer(address(0), owner(), _value);\n        emit LogIssued(_value);\n    }\n\n\n    /**\n     * @notice Purpose: Redeem tokens on the owner() address\n     * @param _value - amount of redeemed tokens\n     */\n    function redeem(uint256 _value) public override whenNotPaused onlyOwner {\n        _burn(owner(), _value);\n        emit Transfer(owner(), address(0), _value);\n        emit LogRedeemed(_value);\n    }\n\n    /**\n     * @notice Exposes the ability to mint new FDTs for a given account. Caller has to be the owner of the FDT.\n     */\n    function mint(address account, uint256 amount) public whenNotPaused onlyOwner returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n\n    /**\n     * @notice Exposes the ability to burn exisiting FDTs for a given account. Caller has to be the owner of the FDT.\n     */\n    function burn(address account, uint256 amount) public whenNotPaused onlyOwner returns (bool) {\n        _burn(account, amount);\n        return true;\n    }\n\n    /**\n     * @dev check if _value token can be transferred from _from to _to\n     * @param _from address The address which you want to send tokens from\n     * @param _to address The address which you want to transfer to\n     * @param _value uint256 the amount of tokens to be transferred\n     */\n    function canTransfer(address _from, address _to, uint256 _value) public view returns (bool) {\n        if (paused()) return false;\n        if (address(ruleEngine) != address(0)) return ruleEngine.validateTransfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * @dev check if _value token can be transferred from _from to _to\n     * @param _from address The address which you want to send tokens from\n     * @param _to address The address which you want to transfer to\n     * @param _value uint256 the amount of tokens to be transferred\n     * @return code of the rejection reason\n     */\n    function detectTransferRestriction(address _from, address _to, uint256 _value) public view returns (uint8) {\n        if (paused()) return TRANSFER_REJECTED_PAUSED;\n        if (address(ruleEngine) != address(0)) return ruleEngine.detectTransferRestriction(_from, _to, _value);\n        return TRANSFER_OK;\n    }\n\n    /**\n     * @dev returns the human readable explaination corresponding to the error code returned by detectTransferRestriction\n     * @param _restrictionCode The error code returned by detectTransferRestriction\n     * @return The human readable explaination corresponding to the error code returned by detectTransferRestriction\n     */\n    function messageForTransferRestriction(uint8 _restrictionCode) public view returns (string memory) {\n        if (_restrictionCode == TRANSFER_OK) return TEXT_TRANSFER_OK;\n        if (_restrictionCode == TRANSFER_REJECTED_PAUSED) return TEXT_TRANSFER_REJECTED_PAUSED;\n        if (address(ruleEngine) != address(0)) return ruleEngine.messageForTransferRestriction(_restrictionCode);\n        revert(\"CMTA20FDT.messageForTransferRestriction: INVALID_RESTRICTION_CODE\");\n    }\n\n    /**\n     * @notice Withdraws all available funds for a token holder\n     */\n    function _withdrawFundsFor(address owner) internal {\n        uint256 withdrawableFunds = _prepareWithdrawFor(owner);\n\n        require(\n            fundsToken.transfer(owner, withdrawableFunds),\n            \"CMTA20FDT.withdrawFunds: TRANSFER_FAILED\"\n        );\n\n        _updateFundsTokenBalance();\n    }\n\n    /**\n     * @dev Updates the current funds token balance\n     * and returns the difference of new and previous funds token balances\n     * @return A int256 representing the difference of the new and previous funds token balance\n     */\n    function _updateFundsTokenBalance() internal returns (int256) {\n        uint256 prevFundsTokenBalance = fundsTokenBalance;\n\n        fundsTokenBalance = fundsToken.balanceOf(address(this));\n\n        return int256(fundsTokenBalance).sub(int256(prevFundsTokenBalance));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../GSN/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor () {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "contracts/Extensions/Forwarder.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n\ncontract Forwarder is Ownable {\n\n    mapping(address => address) public beneficiaries;\n\n\n    function setBeneficiary(address token, address beneficiary) external onlyOwner {\n        require(\n            beneficiaries[token] == address(0),\n            \"Forwarder.setBeneficiary: Beneficary already set for token.\"\n        );\n\n        beneficiaries[token] = beneficiary;\n    }\n\n    function pushAccruedToBeneficiary(address token) external returns(bool) {\n        require(\n           beneficiaries[token] != address(0),\n           \"Forwarder.pushAccruedFundsToBeneficiary: No beneficiary set for token.\"\n        );\n\n        uint256 accruedFunds = IERC20(token).balanceOf(beneficiaries[token]);\n\n        return IERC20(token).transfer(beneficiaries[token], accruedFunds);\n    }\n}\n\n"
    },
    "contracts/Extensions/FDT/CMTA20FDT/SimpleRestrictedRuleEngine.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\n/**\n * @notice This contract allows a list of administrators to be tracked. This list can then be enforced\n * on functions with administrative permissions.  Only the owner of the contract should be allowed\n * to modify the administrator list.\n */\ncontract Administratable is Ownable {\n    // The mapping to track administrator accounts - true is reserved for admin addresses.\n    mapping(address => bool) public administrators;\n\n    // Events to allow tracking add/remove.\n    event AdminAdded(address indexed addedAdmin, address indexed addedBy);\n    event AdminRemoved(address indexed removedAdmin, address indexed removedBy);\n\n    /**\n     * @notice Function modifier to enforce administrative permissions.\n     */\n    modifier onlyAdministrator() {\n        require(\n            isAdministrator(msg.sender),\n            \"Calling account is not an administrator.\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Add an admin to the list.  This should only be callable by the owner of the contract.\n     */\n    function addAdmin(address adminToAdd) public onlyOwner {\n        // Verify the account is not already an admin\n        require(\n            administrators[adminToAdd] == false,\n            \"Account to be added to admin list is already an admin\"\n        );\n\n        // Set the address mapping to true to indicate it is an administrator account.\n        administrators[adminToAdd] = true;\n\n        // Emit the event for any watchers.\n        emit AdminAdded(adminToAdd, msg.sender);\n    }\n\n    /**\n     * @notice Remove an admin from the list.  This should only be callable by the owner of the contract.\n     */\n    function removeAdmin(address adminToRemove) public onlyOwner {\n        // Verify the account is an admin\n        require(\n            administrators[adminToRemove] == true,\n            \"Account to be removed from admin list is not already an admin\"\n        );\n\n        // Set the address mapping to false to indicate it is NOT an administrator account.\n        administrators[adminToRemove] = false;\n\n        // Emit the event for any watchers.\n        emit AdminRemoved(adminToRemove, msg.sender);\n    }\n\n    /**\n     * @notice Determine if the message sender is in the administrators list.\n     */\n    function isAdministrator(address addressToTest) public view returns (bool) {\n        return administrators[addressToTest];\n    }\n}\n\n/**\n * @notice Keeps track of whitelists and can check if sender and reciever are configured to allow a transfer.\n * Only administrators can update the whitelists.\n * Any address can only be a member of one whitelist at a time.\n */\ncontract Whitelistable is Administratable {\n    // Zero is reserved for indicating it is not on a whitelist\n    uint8 constant internal NO_WHITELIST = 0;\n\n    // The mapping to keep track of which whitelist any address belongs to.\n    // 0 is reserved for no whitelist and is the default for all addresses.\n    mapping(address => uint8) public addressWhitelists;\n\n    // The mapping to keep track of each whitelist's outbound whitelist flags.\n    // Boolean flag indicates whether outbound transfers are enabled.\n    mapping(uint8 => mapping(uint8 => bool)) public outboundWhitelistsEnabled;\n\n    // Events to allow tracking add/remove.\n    event AddressAddedToWhitelist(\n        address indexed addedAddress,\n        uint8 indexed whitelist,\n        address indexed addedBy\n    );\n    event AddressRemovedFromWhitelist(\n        address indexed removedAddress,\n        uint8 indexed whitelist,\n        address indexed removedBy\n    );\n    event OutboundWhitelistUpdated(\n        address indexed updatedBy,\n        uint8 indexed sourceWhitelist,\n        uint8 indexed destinationWhitelist,\n        bool from,\n        bool to\n    );\n\n    /**\n     * @notice Sets an address's white list ID.  Only administrators should be allowed to update this.\n     * If an address is on an existing whitelist, it will just get updated to the new value (removed from previous).\n     */\n    function addToWhitelist(address addressToAdd, uint8 whitelist)\n        public\n        onlyAdministrator\n    {\n        // Verify the whitelist is valid\n        require(whitelist != NO_WHITELIST, \"Invalid whitelist ID supplied\");\n\n        // Save off the previous white list\n        uint8 previousWhitelist = addressWhitelists[addressToAdd];\n\n        // Set the address's white list ID\n        addressWhitelists[addressToAdd] = whitelist;\n\n        // If the previous whitelist existed then we want to indicate it has been removed\n        if (previousWhitelist != NO_WHITELIST) {\n            // Emit the event for tracking\n            emit AddressRemovedFromWhitelist(\n                addressToAdd,\n                previousWhitelist,\n                msg.sender\n            );\n        }\n\n        // Emit the event for new whitelist\n        emit AddressAddedToWhitelist(addressToAdd, whitelist, msg.sender);\n    }\n\n    /**\n     * @notice Clears out an address's white list ID.  Only administrators should be allowed to update this.\n     */\n    function removeFromWhitelist(address addressToRemove)\n        public\n        onlyAdministrator\n    {\n        // Save off the previous white list\n        uint8 previousWhitelist = addressWhitelists[addressToRemove];\n\n        // Zero out the previous white list\n        addressWhitelists[addressToRemove] = NO_WHITELIST;\n\n        // Emit the event for tracking\n        emit AddressRemovedFromWhitelist(\n            addressToRemove,\n            previousWhitelist,\n            msg.sender\n        );\n    }\n\n    /**\n     * @notice Sets the flag to indicate whether source whitelist is allowed to send to destination whitelist.\n     * Only administrators should be allowed to update this.\n     */\n    function updateOutboundWhitelistEnabled(\n        uint8 sourceWhitelist,\n        uint8 destinationWhitelist,\n        bool newEnabledValue\n    ) public onlyAdministrator {\n        // Get the old enabled flag\n        bool oldEnabledValue = outboundWhitelistsEnabled[sourceWhitelist][destinationWhitelist];\n\n        // Update to the new value\n        outboundWhitelistsEnabled[sourceWhitelist][destinationWhitelist] = newEnabledValue;\n\n        // Emit event for tracking\n        emit OutboundWhitelistUpdated(\n            msg.sender,\n            sourceWhitelist,\n            destinationWhitelist,\n            oldEnabledValue,\n            newEnabledValue\n        );\n    }\n\n    /**\n     * @notice Determine if the a sender is allowed to send to the receiver.\n     * The source whitelist must be enabled to send to the whitelist where the receive exists.\n     */\n    function checkWhitelistAllowed(address sender, address receiver)\n        public\n        view\n        returns (bool)\n    {\n        // First get each address white list\n        uint8 senderWhiteList = addressWhitelists[sender];\n        uint8 receiverWhiteList = addressWhitelists[receiver];\n\n        // If either address is not on a white list then the check should fail\n        if (\n            senderWhiteList == NO_WHITELIST || receiverWhiteList == NO_WHITELIST\n        ) {\n            return false;\n        }\n\n        // Determine if the sending whitelist is allowed to send to the destination whitelist\n        return outboundWhitelistsEnabled[senderWhiteList][receiverWhiteList];\n    }\n}\n\n/**\n * @notice Restrictions start off as enabled. Once they are disabled, they cannot be re-enabled.\n * Only the owner may disable restrictions.\n */\ncontract Restrictable is Ownable {\n    // State variable to track whether restrictions are enabled.  Defaults to true.\n    bool private _restrictionsEnabled = true;\n\n    // Event emitted when flag is disabled\n    event RestrictionsDisabled(address indexed owner);\n\n    /**\n     * @notice Function to update the enabled flag on restrictions to disabled.  Only the owner should be able to call.\n     * This is a permanent change that cannot be undone\n     */\n    function disableRestrictions() public onlyOwner {\n        require(_restrictionsEnabled, \"Restrictions are already disabled.\");\n\n        // Set the flag\n        _restrictionsEnabled = false;\n\n        // Trigger the event\n        emit RestrictionsDisabled(msg.sender);\n    }\n\n    /**\n     * @notice View function to determine if restrictions are enabled\n     */\n    function isRestrictionEnabled() public view returns (bool) {\n        return _restrictionsEnabled;\n    }\n}\n\n/**\n * @title IRule\n * @dev IRule interface.\n */\ninterface IRule {\n  function isTransferValid(address _from, address _to, uint256 _amount) external view returns (bool isValid);\n  function detectTransferRestriction(address _from, address _to, uint256 _amount) external view returns (uint8);\n  function canReturnTransferRestrictionCode(uint8 _restrictionCode) external view returns (bool);\n  function messageForTransferRestriction(uint8 _restrictionCode) external view returns (string memory);\n}\n\n/**\n * @title IRuleEngine\n * @dev IRuleEngine \n */\ninterface IRuleEngine {\n  function setRules(IRule[] calldata _rules) external;\n  function ruleLength() external view returns (uint256);\n  function rule(uint256 ruleId) external view returns (IRule);\n  function rules() external view returns(IRule[] memory);\n  function validateTransfer(address _from, address _to, uint256 _amount) external view returns (bool);\n  function detectTransferRestriction(address _from, address _to, uint256 _value) external view returns (uint8);\n  function messageForTransferRestriction (uint8 _restrictionCode) external view returns (string memory);\n}\n\ncontract SimpleRestrictedRuleEngine is IRuleEngine, Whitelistable, Restrictable {\n\n    // ERC1404 Error codes and messages\n    uint8 public constant SUCCESS_CODE = 0;\n    uint8 public constant FAILURE_NON_WHITELIST = 1;\n    string public constant SUCCESS_MESSAGE = \"SUCCESS\";\n    string public constant FAILURE_NON_WHITELIST_MESSAGE = \"The transfer was restricted due to white list configuration.\";\n    string public constant UNKNOWN_ERROR = \"Unknown Error Code\";\n\n\n    constructor(address owner) {\n        transferOwnership(owner);\n    }\n\n    function setRules(IRule[] calldata /* rules */) external view override onlyOwner {\n        revert(\"Can not set any additional rules\");\n    }\n    \n    function ruleLength() external pure override returns (uint256) {\n        return 0;\n    }\n    \n    function rule(uint256 /* ruleId */) external pure override returns (IRule) {\n        return IRule(address(0));\n    }\n    \n    function rules() external pure override returns(IRule[] memory _rules) {\n        return _rules;\n    }\n\n    /**\n  \t * @notice This function detects whether a transfer should be restricted and not allowed.\n  \t * If the function returns SUCCESS_CODE (0) then it should be allowed.\n  \t */\n    function detectTransferRestriction(address from, address to, uint256)\n        public\n        view\n        override\n        returns (uint8)\n    {\n        // If the restrictions have been disabled by the owner, then just return success\n        // Logic defined in Restrictable parent class\n        if (!isRestrictionEnabled()) {\n            return SUCCESS_CODE;\n        }\n\n        // If the contract owner is transferring, then ignore reistrictions\n        if (from == owner()) {\n            return SUCCESS_CODE;\n        }\n\n        // Restrictions are enabled, so verify the whitelist config allows the transfer.\n        // Logic defined in Whitelistable parent class\n        if (!checkWhitelistAllowed(from, to)) {\n            return FAILURE_NON_WHITELIST;\n        }\n\n        // If no restrictions were triggered return success\n        return SUCCESS_CODE;\n    }\n\n    /**\n  \t * @notice This function allows a wallet or other client to get a human readable string to show\n  \t * a user if a transfer was restricted.  It should return enough information for the user\n  \t * to know why it failed.\n  \t */\n    function messageForTransferRestriction(uint8 restrictionCode)\n        public\n        pure\n        override\n        returns (string memory)\n    {\n        if (restrictionCode == SUCCESS_CODE) {\n            return SUCCESS_MESSAGE;\n        }\n\n        if (restrictionCode == FAILURE_NON_WHITELIST) {\n            return FAILURE_NON_WHITELIST_MESSAGE;\n        }\n\n        // An unknown error code was passed in.\n        return UNKNOWN_ERROR;\n    }\n\n    function validateTransfer(address from, address to, uint256 amount) public view override returns (bool) {\n      return detectTransferRestriction(from, to, amount) == SUCCESS_CODE;\n    }\n}"
    },
    "contracts/ERC20Token.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\ninterface FaucetInterface {\n    function drip(address receiver, uint tokens) external;\n}\n\ncontract ERC20Token is ERC20, FaucetInterface, Ownable {\n    using SafeMath for uint256;\n\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}\n\n    function drip(address receiver, uint256 tokens) public override {\n        _mint(receiver, tokens);\n    }\n}\n"
    },
    "contracts/Core/Base/OracleProxy/DataRegistryProxy/DataRegistryProxy.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../IOracleProxy.sol\";\nimport \"./IDataRegistryProxy.sol\";\n\n\n/**\n * @title DataRegistryProxy\n * @notice Registry for data which is published by an registered MarketObjectProvider\n */\ncontract DataRegistryProxy is IDataRegistryProxy, IOracleProxy, Ownable {\n\n    event UpdatedDataProvider(bytes32 indexed setId, address provider);\n    event PublishedDataPoint(bytes32 indexed setId, int256 dataPoint, uint256 timestamp);\n\n    struct DataPoint {\n        int256 dataPoint;\n        bool isSet;\n    }\n\n    struct Set {\n        // timestamp => DataPoint\n        mapping(uint256 => DataPoint) dataPoints;\n        uint256 lastUpdatedTimestamp;\n        address provider;\n        bool isSet;\n    }\n\n    mapping(bytes32 => Set) internal sets;\n\n\n    /**\n     * @notice @notice Returns true if there is data registered for a given setId\n     * @param setId setId of the data set\n     * @return true if market object exists\n     */\n    function isRegistered(bytes32 setId)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return sets[setId].isSet;\n    }\n\n    /**\n     * @notice Returns a data point of a market object for a given timestamp.\n     * @param setId id of the data set\n     * @param timestamp timestamp of the data point\n     * @return data point, bool indicating whether data point exists\n     */\n    function getDataPoint(\n        bytes32 setId,\n        uint256 timestamp\n    )\n        external\n        view\n        override(IDataRegistryProxy, IOracleProxy)\n        returns (int256, bool)\n    {\n        return (\n            sets[setId].dataPoints[timestamp].dataPoint,\n            sets[setId].dataPoints[timestamp].isSet\n        );\n    }\n\n    /**\n     * @notice Returns the timestamp on which the last data point for a data set\n     * was submitted.\n     * @param setId id of the data set\n     * @return last updated timestamp\n     */\n    function getLastUpdatedTimestamp(bytes32 setId)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return sets[setId].lastUpdatedTimestamp;\n    }\n\n    /**\n     * @notice Returns the provider for a market object\n     * @param setId id of the data set\n     * @return address of provider\n     */\n    function getDataProvider(bytes32 setId)\n        external\n        view\n        override\n        returns (address)\n    {\n        return sets[setId].provider;\n    }\n\n    /**\n     * @notice Registers / updates a market object provider.\n     * @dev Can only be called by the owner of the DataRegistry.\n     * @param setId id of the data set\n     * @param provider address of the provider\n     */\n    function setDataProvider(\n        bytes32 setId,\n        address provider\n    )\n        external\n        override\n        onlyOwner\n    {\n        sets[setId].provider = provider;\n\n        if (sets[setId].isSet == false) {\n            sets[setId].isSet = true;\n        }\n\n        emit UpdatedDataProvider(setId, provider);\n    }\n\n    /**\n     * @notice Stores a new data point of a data set for a given timestamp.\n     * @dev Can only be called by a whitelisted data provider.\n     * @param setId id of the data set\n     * @param timestamp timestamp of the data point\n     * @param dataPoint the data point of the data set\n     */\n    function publishDataPoint(\n        bytes32 setId,\n        uint256 timestamp,\n        int256 dataPoint\n    )\n        external\n        override\n    {\n        require(\n            msg.sender == sets[setId].provider,\n            \"DataRegistry.publishDataPoint: UNAUTHORIZED_SENDER\"\n        );\n\n        sets[setId].dataPoints[timestamp] = DataPoint(dataPoint, true);\n\n        if (sets[setId].isSet == false) {\n            sets[setId].isSet = true;\n        }\n\n        if (sets[setId].lastUpdatedTimestamp < timestamp) {\n            sets[setId].lastUpdatedTimestamp = timestamp;\n        }\n\n        emit PublishedDataPoint(setId, dataPoint, timestamp);\n    }\n}\n"
    },
    "contracts/Core/CEG/CEGRegistry.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../ACTUS/Engines/CEG/ICEGEngine.sol\";\n\nimport \"../Base/SharedTypes.sol\";\nimport \"../Base/AssetRegistry/BaseRegistry.sol\";\nimport \"./CEGEncoder.sol\";\nimport \"./ICEGRegistry.sol\";\n\n\n/**\n * @title CEGRegistry\n * @notice Registry for ACTUS Protocol assets\n */\ncontract CEGRegistry is BaseRegistry, ICEGRegistry {\n\n    using CEGEncoder for Asset;\n\n    \n    constructor() BaseRegistry() {}\n\n    /**\n     * @notice\n     * @param assetId id of the asset\n     * @param terms asset specific terms (CEGTerms)\n     * @param state initial state of the asset\n     * @param schedule schedule of the asset\n     * @param ownership ownership of the asset\n     * @param engine ACTUS Engine of the asset\n     * @param actor account which is allowed to update the asset state\n     * @param admin account which as admin rights (optional)\n     */\n    function registerAsset(\n        bytes32 assetId,\n        CEGTerms calldata terms,\n        State calldata state,\n        bytes32[] calldata schedule,\n        AssetOwnership calldata ownership,\n        address engine,\n        address actor,\n        address admin\n    )\n        external\n        override\n        onlyApprovedActors\n    {\n        setAsset(assetId, state, schedule, ownership, engine, actor, admin);\n        assets[assetId].encodeAndSetCEGTerms(terms);\n    }\n\n    /**\n     * @notice Returns the terms of an asset.\n     * @param assetId id of the asset\n     * @return terms of the asset\n     */\n    function getTerms(bytes32 assetId)\n        external\n        view\n        override\n        returns (CEGTerms memory)\n    {\n        return assets[assetId].decodeAndGetCEGTerms();\n    }\n\n    /**\n     * @notice Set the terms of the asset\n     * @dev Can only be set by authorized account.\n     * @param assetId id of the asset\n     * @param terms new terms\n     */\n    function setTerms(bytes32 assetId, CEGTerms calldata terms)\n        external\n        override\n        isAuthorized (assetId)\n    {\n        assets[assetId].encodeAndSetCEGTerms(terms);\n        emit UpdatedTerms(assetId);\n    }\n\n    function getEnumValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (uint8)\n    {\n        return assets[assetId].decodeAndGetEnumValueForCEGAttribute(attribute);\n    }\n\n    function getAddressValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (address)\n    {\n        return assets[assetId].decodeAndGetAddressValueForForCEGAttribute(attribute);\n    }\n\n    function getBytes32ValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (bytes32)\n    {\n        return assets[assetId].decodeAndGetBytes32ValueForForCEGAttribute(attribute);\n    }\n\n    function getUIntValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (uint256)\n    {\n        return assets[assetId].decodeAndGetUIntValueForForCEGAttribute(attribute);\n    }\n\n    function getIntValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (int256)\n    {\n        return assets[assetId].decodeAndGetIntValueForForCEGAttribute(attribute);\n    }\n\n    function getPeriodValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (IP memory)\n    {\n        return assets[assetId].decodeAndGetPeriodValueForForCEGAttribute(attribute);\n    }\n\n    function getCycleValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (IPS memory)\n    {\n        return assets[assetId].decodeAndGetCycleValueForForCEGAttribute(attribute);\n    }\n\n    function getContractReferenceValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (ContractReference memory)\n    {\n        return assets[assetId].decodeAndGetContractReferenceValueForCEGAttribute(attribute);\n    }\n\n    function getNextComputedEvent(bytes32 assetId)\n        internal\n        view\n        override(TermsRegistry)\n        returns (bytes32, bool)\n    {\n        Asset storage asset = assets[assetId];\n        CEGTerms memory terms = asset.decodeAndGetCEGTerms();\n\n        EventType nextEventType;\n        uint256 nextScheduleTime;\n        bool isCyclicEvent = true;\n\n        // FP\n        {\n            (EventType eventType, uint256 scheduleTime) = decodeEvent(ICEGEngine(asset.engine).computeNextCyclicEvent(\n                terms,\n                asset.schedule.lastScheduleTimeOfCyclicEvent[EventType.FP],\n                EventType.FP\n            ));\n\n            if (\n                (nextScheduleTime == 0)\n                || (scheduleTime < nextScheduleTime)\n                || (nextScheduleTime == scheduleTime && getEpochOffset(eventType) < getEpochOffset(nextEventType))\n            ) {\n                nextScheduleTime = scheduleTime;\n                nextEventType = eventType;\n            }        \n        }\n\n        // Non-Cyclic\n        {\n            (EventType eventType, uint256 scheduleTime) = decodeEvent(ICEGEngine(asset.engine).computeNextNonCyclicEvent(\n                terms,\n                asset.schedule.lastNonCyclicEvent\n            ));\n\n            if (\n                (nextScheduleTime == 0)\n                || (scheduleTime != 0 && scheduleTime < nextScheduleTime)\n                || (scheduleTime != 0 && nextScheduleTime == scheduleTime && getEpochOffset(eventType) < getEpochOffset(nextEventType))\n            ) {\n                nextScheduleTime = scheduleTime;\n                nextEventType = eventType;\n                isCyclicEvent = false;\n            }        \n        }\n\n        return (encodeEvent(nextEventType, nextScheduleTime), isCyclicEvent);\n    }\n}\n"
    },
    "contracts/ACTUS/Engines/CEG/ICEGEngine.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../Core/ACTUSTypes.sol\";\nimport \"../IEngine.sol\";\n\n\n/**\n * @title IEngine\n * @notice Interface which all Engines have to implement\n */\ninterface ICEGEngine is IEngine {\n\n    /**\n     * @notice Initialize contract state space based on the contract terms.\n     * @param terms terms of the contract\n     * @return initial state of the contract\n     */\n    function computeInitialState(CEGTerms calldata terms)\n        external\n        pure\n        returns (State memory);\n\n    /**\n     * Applys an event to the current state of a contract and returns the resulting contract state.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event to be applied to the contract state\n     * @param externalData external data needed for STF evaluation (e.g. rate for RR events)\n     * @return the resulting contract state\n     */\n    function computeStateForEvent(\n        CEGTerms calldata terms,\n        State calldata state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        external\n        pure\n        returns (State memory);\n\n    /**\n     * Evaluates the payoff for an event under the current state of the contract.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which the payoff should be evaluated\n     * @param externalData external data needed for POF evaluation (e.g. fxRate)\n     * @return the payoff of the event\n     */\n    function computePayoffForEvent(\n        CEGTerms calldata terms,\n        State calldata state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        external\n        pure\n        returns (int256);\n\n    /**\n     * @notice Computes a schedule segment of non-cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @return segment of the non-cyclic schedule\n     */\n    function computeNonCyclicScheduleSegment(\n        CEGTerms calldata terms,\n        uint256 segmentStart,\n        uint256 segmentEnd\n    )\n        external\n        pure\n        returns (bytes32[] memory);\n\n    /**\n     * @notice Computes a schedule segment of cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @param eventType eventType of the cyclic schedule\n     * @return event schedule segment\n     */\n    function computeCyclicScheduleSegment(\n        CEGTerms calldata terms,\n        uint256 segmentStart,\n        uint256 segmentEnd,\n        EventType eventType\n    )\n        external\n        pure\n        returns (bytes32[] memory);\n\n    /**\n     * @notice Computes the next non-cyclic contract events based on the contract terms\n     * and the timestamp on which the prev. event occured.\n     * @dev Assumes that non-cyclic events of the same event type have a unique schedule time\n     * @param terms terms of the contract\n     * @param lastNonCyclicEvent last non-cyclic event\n     * @return next non-cyclic event\n     */\n    function computeNextNonCyclicEvent(\n        CEGTerms calldata terms,\n        bytes32 lastNonCyclicEvent\n    )\n        external\n        pure\n        returns (bytes32);\n\n    /**\n     * @notice Computes a schedule segment of cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param lastScheduleTime last occurrence of cyclic event\n     * @param eventType eventType of the cyclic schedule\n     * @return event schedule segment\n     */\n    function computeNextCyclicEvent(\n        CEGTerms calldata terms,\n        uint256 lastScheduleTime,\n        EventType eventType\n    )\n        external\n        pure\n        returns(bytes32);\n\n    /**\n     * @notice Verifies that the provided event is still scheduled under the terms, the current state of the\n     * contract and the current state of the underlying.\n     * @param _event event for which to check if its still scheduled\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param hasUnderlying boolean indicating whether the contract has an underlying contract\n     * @param underlyingState state of the underlying (empty state object if non-existing)\n     * @return boolean indicating whether event is still scheduled\n     */\n    function isEventScheduled(\n        bytes32 _event,\n        CEGTerms calldata terms,\n        State calldata state,\n        bool hasUnderlying,\n        State calldata underlyingState\n    )\n        external\n        pure\n        returns (bool);\n}\n"
    },
    "contracts/Core/CEG/CEGEncoder.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../Base/SharedTypes.sol\";\nimport \"../Base/AssetRegistry/BaseRegistryStorage.sol\";\n\n\nlibrary CEGEncoder {\n\n    function storeInPackedTerms(Asset storage asset, bytes32 attributeKey, bytes32 value) private {\n        // skip if value did not change\n        if (asset.packedTerms[attributeKey] == value) return;\n        asset.packedTerms[attributeKey] = value;\n    }\n    \n    /**\n     * @dev Tightly pack and store only non-zero overwritten terms (LifecycleTerms)\n     * @notice All non zero values of the overwrittenTerms object are stored.\n     * It does not check if overwrittenAttributesMap actually marks attribute as overwritten.\n     */\n    function encodeAndSetCEGTerms(Asset storage asset, CEGTerms memory terms) external {\n        storeInPackedTerms(\n            asset,\n            \"enums\",\n            bytes32(uint256(uint8(terms.contractType))) << 248 |\n            bytes32(uint256(uint8(terms.calendar))) << 240 |\n            bytes32(uint256(uint8(terms.contractRole))) << 232 |\n            bytes32(uint256(uint8(terms.dayCountConvention))) << 224 |\n            bytes32(uint256(uint8(terms.businessDayConvention))) << 216 |\n            bytes32(uint256(uint8(terms.endOfMonthConvention))) << 208 |\n            bytes32(uint256(uint8(terms.feeBasis))) << 200 |\n            bytes32(uint256(uint8(terms.creditEventTypeCovered))) << 192\n        );\n\n        storeInPackedTerms(asset, \"currency\", bytes32(uint256(terms.currency) << 96));\n        storeInPackedTerms(asset, \"settlementCurrency\", bytes32(uint256(terms.settlementCurrency) << 96));\n\n        storeInPackedTerms(asset, \"statusDate\", bytes32(terms.statusDate));\n        storeInPackedTerms(asset, \"maturityDate\", bytes32(terms.maturityDate));\n        storeInPackedTerms(asset, \"purchaseDate\", bytes32(terms.purchaseDate));\n        storeInPackedTerms(asset, \"cycleAnchorDateOfFee\", bytes32(terms.cycleAnchorDateOfFee));\n\n        storeInPackedTerms(asset, \"notionalPrincipal\", bytes32(terms.notionalPrincipal));\n        \n        storeInPackedTerms(asset, \"feeRate\", bytes32(terms.feeRate));\n        storeInPackedTerms(asset, \"feeAccrued\", bytes32(terms.feeAccrued));\n        storeInPackedTerms(asset, \"priceAtPurchaseDate\", bytes32(terms.priceAtPurchaseDate));\n        storeInPackedTerms(asset, \"priceAtTerminationDate\", bytes32(terms.priceAtTerminationDate));\n\n        storeInPackedTerms(asset, \"coverageOfCreditEnhancement\", bytes32(terms.coverageOfCreditEnhancement));\n\n        storeInPackedTerms(\n            asset,\n            \"gracePeriod\",\n            bytes32(uint256(terms.gracePeriod.i)) << 24 |\n            bytes32(uint256(terms.gracePeriod.p)) << 16 |\n            bytes32(uint256((terms.gracePeriod.isSet) ? 1 : 0)) << 8\n        );\n        storeInPackedTerms(\n            asset,\n            \"delinquencyPeriod\",\n            bytes32(uint256(terms.delinquencyPeriod.i)) << 24 |\n            bytes32(uint256(terms.delinquencyPeriod.p)) << 16 |\n            bytes32(uint256((terms.delinquencyPeriod.isSet) ? 1 : 0)) << 8\n        );\n\n        storeInPackedTerms(\n            asset,\n            \"cycleOfFee\",\n            bytes32(uint256(terms.cycleOfFee.i)) << 24 |\n            bytes32(uint256(terms.cycleOfFee.p)) << 16 |\n            bytes32(uint256(terms.cycleOfFee.s)) << 8 |\n            bytes32(uint256((terms.cycleOfFee.isSet) ? 1 : 0))\n        );\n\n        storeInPackedTerms(\n            asset,\n            \"contractReference_1_type_role\",\n            bytes32(uint256(terms.contractReference_1._type)) << 16 |\n            bytes32(uint256(terms.contractReference_1.role)) << 8\n        );\n\n        storeInPackedTerms(\n            asset,\n            \"contractReference_1_object\",\n            terms.contractReference_1.object\n        );\n        storeInPackedTerms(\n            asset,\n            \"contractReference_1_object2\",\n            terms.contractReference_1.object2\n        );\n\n        storeInPackedTerms(\n            asset,\n            \"contractReference_2_type_role\",\n            bytes32(uint256(terms.contractReference_2._type)) << 16 |\n            bytes32(uint256(terms.contractReference_2.role)) << 8\n        );\n\n        storeInPackedTerms(\n            asset,\n            \"contractReference_2_object\",\n            terms.contractReference_2.object\n        );\n        storeInPackedTerms(\n            asset,\n            \"contractReference_2_object2\",\n            terms.contractReference_2.object2\n        );\n    }\n\n    /**\n     * @dev Decode and loads CEGTerms\n     */\n    function decodeAndGetCEGTerms(Asset storage asset) external view returns (CEGTerms memory) {\n        return CEGTerms(\n            ContractType(uint8(uint256(asset.packedTerms[\"enums\"] >> 248))),\n            Calendar(uint8(uint256(asset.packedTerms[\"enums\"] >> 240))),\n            ContractRole(uint8(uint256(asset.packedTerms[\"enums\"] >> 232))),\n            DayCountConvention(uint8(uint256(asset.packedTerms[\"enums\"] >> 224))),\n            BusinessDayConvention(uint8(uint256(asset.packedTerms[\"enums\"] >> 216))),\n            EndOfMonthConvention(uint8(uint256(asset.packedTerms[\"enums\"] >> 208))),\n            FeeBasis(uint8(uint256(asset.packedTerms[\"enums\"] >> 200))),\n            ContractPerformance(uint8(uint256(asset.packedTerms[\"enums\"] >> 192))),\n\n            address(uint160(uint256(asset.packedTerms[\"currency\"]) >> 96)),\n            address(uint160(uint256(asset.packedTerms[\"settlementCurrency\"]) >> 96)),\n\n            uint256(asset.packedTerms[\"statusDate\"]),\n            uint256(asset.packedTerms[\"maturityDate\"]),\n            uint256(asset.packedTerms[\"purchaseDate\"]),\n            uint256(asset.packedTerms[\"cycleAnchorDateOfFee\"]),\n\n            int256(asset.packedTerms[\"notionalPrincipal\"]),\n\n            int256(asset.packedTerms[\"feeRate\"]),\n            int256(asset.packedTerms[\"feeAccrued\"]),\n            int256(asset.packedTerms[\"priceAtPurchaseDate\"]),\n            int256(asset.packedTerms[\"priceAtTerminationDate\"]),\n\n            int256(asset.packedTerms[\"coverageOfCreditEnhancement\"]),\n\n            IP(\n                uint256(asset.packedTerms[\"gracePeriod\"] >> 24),\n                P(uint8(uint256(asset.packedTerms[\"gracePeriod\"] >> 16))),\n                (asset.packedTerms[\"gracePeriod\"] >> 8 & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            ),\n            IP(\n                uint256(asset.packedTerms[\"delinquencyPeriod\"] >> 24),\n                P(uint8(uint256(asset.packedTerms[\"delinquencyPeriod\"] >> 16))),\n                (asset.packedTerms[\"delinquencyPeriod\"] >> 8 & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            ),\n\n            IPS(\n                uint256(asset.packedTerms[\"cycleOfFee\"] >> 24),\n                P(uint8(uint256(asset.packedTerms[\"cycleOfFee\"] >> 16))),\n                S(uint8(uint256(asset.packedTerms[\"cycleOfFee\"] >> 8))),\n                (asset.packedTerms[\"cycleOfFee\"] & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            ),\n\n            ContractReference(\n                asset.packedTerms[\"contractReference_1_object\"],\n                asset.packedTerms[\"contractReference_1_object2\"],\n                ContractReferenceType(uint8(uint256(asset.packedTerms[\"contractReference_1_type_role\"] >> 16))),\n                ContractReferenceRole(uint8(uint256(asset.packedTerms[\"contractReference_1_type_role\"] >> 8)))\n            ),\n            ContractReference(\n                asset.packedTerms[\"contractReference_2_object\"],\n                asset.packedTerms[\"contractReference_2_object2\"],\n                ContractReferenceType(uint8(uint256(asset.packedTerms[\"contractReference_2_type_role\"] >> 16))),\n                ContractReferenceRole(uint8(uint256(asset.packedTerms[\"contractReference_2_type_role\"] >> 8)))\n            )\n        );\n    }\n\n    function decodeAndGetEnumValueForCEGAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (uint8)\n    {\n        if (attributeKey == \"contractType\") {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 248));\n        } else if (attributeKey == bytes32(\"calendar\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 240));\n        } else if (attributeKey == bytes32(\"contractRole\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 232));\n        } else if (attributeKey == bytes32(\"dayCountConvention\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 224));\n        } else if (attributeKey == bytes32(\"businessDayConvention\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 216));\n        } else if (attributeKey == bytes32(\"endOfMonthConvention\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 208));\n        } else if (attributeKey == bytes32(\"feeBasis\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 200));\n        } else if (attributeKey == bytes32(\"contractPerformance\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 192));\n        } else {\n            return uint8(0);\n        }\n    }\n\n    function decodeAndGetAddressValueForForCEGAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (address)\n    {\n        if (attributeKey == bytes32(\"currency\")) {\n            return address(uint160(uint256(asset.packedTerms[\"currency\"]) >> 96));\n        } else if (attributeKey == bytes32(\"settlementCurrency\")) {\n            return address(uint160(uint256(asset.packedTerms[\"settlementCurrency\"]) >> 96));\n        } else {\n            return address(0);\n        }   \n    }\n\n    function decodeAndGetBytes32ValueForForCEGAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (bytes32)\n    {\n        return asset.packedTerms[attributeKey];\n    }\n\n    function decodeAndGetUIntValueForForCEGAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (uint256)\n    {\n        return uint256(asset.packedTerms[attributeKey]);\n    }\n\n    function decodeAndGetIntValueForForCEGAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (int256)\n    {\n        return int256(asset.packedTerms[attributeKey]);\n    }\n\n    function decodeAndGetPeriodValueForForCEGAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (IP memory)\n    {\n        if (\n            attributeKey == bytes32(\"gracePeriod\")\n            || attributeKey == bytes32(\"delinquencyPeriod\")\n        ) {\n            return IP(\n                uint256(asset.packedTerms[attributeKey] >> 24),\n                P(uint8(uint256(asset.packedTerms[attributeKey] >> 16))),\n                (asset.packedTerms[attributeKey] >> 8 & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            );\n        } else {\n            return IP(0, P(0), false);\n        }\n    }\n\n    function decodeAndGetCycleValueForForCEGAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (IPS memory)\n    {\n        if (\n            attributeKey == bytes32(\"cycleOfFee\")\n        ) {\n            return IPS(\n                uint256(asset.packedTerms[attributeKey] >> 24),\n                P(uint8(uint256(asset.packedTerms[attributeKey] >> 16))),\n                S(uint8(uint256(asset.packedTerms[attributeKey] >> 8))),\n                (asset.packedTerms[attributeKey] & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            );\n        } else {\n            return IPS(0, P(0), S(0), false);\n        }\n    }\n\n    function decodeAndGetContractReferenceValueForCEGAttribute(Asset storage asset , bytes32 attributeKey )\n        external\n        view\n        returns (ContractReference memory)\n    {\n        if (attributeKey == bytes32(\"contractReference_1\")) {\n            return ContractReference(\n                asset.packedTerms[\"contractReference_1_object\"],\n                asset.packedTerms[\"contractReference_1_object2\"],\n                ContractReferenceType(uint8(uint256(asset.packedTerms[\"contractReference_1_type_role\"] >> 16))),\n                ContractReferenceRole(uint8(uint256(asset.packedTerms[\"contractReference_1_type_role\"] >> 8)))\n            );\n        } else if (attributeKey == bytes32(\"contractReference_2\")) {\n            return ContractReference(\n                asset.packedTerms[\"contractReference_2_object\"],\n                asset.packedTerms[\"contractReference_2_object2\"],\n                ContractReferenceType(uint8(uint256(asset.packedTerms[\"contractReference_2_type_role\"] >> 16))),\n                ContractReferenceRole(uint8(uint256(asset.packedTerms[\"contractReference_2_type_role\"] >> 8)))\n            );\n        } else {\n            return ContractReference(\n                bytes32(0),\n                bytes32(0),\n                ContractReferenceType(0),\n                ContractReferenceRole(0)\n            );\n        }\n    }\n}"
    },
    "contracts/Core/CEG/ICEGRegistry.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../Base/SharedTypes.sol\";\nimport \"../Base/AssetRegistry/IAssetRegistry.sol\";\n\n\ninterface ICEGRegistry is IAssetRegistry {\n\n    function registerAsset(\n        bytes32 assetId,\n        CEGTerms calldata terms,\n        State calldata state,\n        bytes32[] calldata schedule,\n        AssetOwnership calldata ownership,\n        address engine,\n        address actor,\n        address admin\n    )\n        external;\n\n    function getTerms(bytes32 assetId)\n        external\n        view\n        returns (CEGTerms memory);\n\n    function setTerms(bytes32 assetId, CEGTerms calldata terms)\n        external;\n}\n"
    },
    "contracts/Core/CEG/CEGActor.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../ACTUS/Engines/CEG/ICEGEngine.sol\";\n\nimport \"../Base/AssetActor/BaseActor.sol\";\nimport \"./ICEGRegistry.sol\";\n\n\n/**\n * @title CEGActor\n * @notice TODO\n */\ncontract CEGActor is BaseActor {\n\n    constructor(IAssetRegistry assetRegistry, IOracleProxy defaultOracleProxy) BaseActor(assetRegistry, defaultOracleProxy) {}\n\n    /**\n     * @notice Derives initial state of the asset terms and stores together with\n     * terms, schedule, ownership, engine, admin of the asset in the contract types specific AssetRegistry.\n     * @param terms asset specific terms\n     * @param schedule schedule of the asset\n     * @param ownership ownership of the asset\n     * @param engine address of the ACTUS engine used for the spec. ContractType\n     * @param admin address of the admin of the asset (optional)\n     */\n    function initialize(\n        CEGTerms calldata terms,\n        bytes32[] calldata schedule,\n        AssetOwnership calldata ownership,\n        address engine,\n        address admin\n    )\n        external\n    {\n        require(\n            engine != address(0) && IEngine(engine).contractType() == ContractType.CEG,\n            \"ANNActor.initialize: CONTRACT_TYPE_OF_ENGINE_UNSUPPORTED\"\n        );\n\n        // solium-disable-next-line\n        bytes32 assetId = keccak256(abi.encode(terms, block.timestamp));\n\n        // check if first contract reference in terms references an underlying asset\n        if (terms.contractReference_1.role == ContractReferenceRole.COVE) {\n            require(\n                terms.contractReference_1.object != bytes32(0),\n                \"CEGACtor.initialize: INVALID_CONTRACT_REFERENCE_1_OBJECT\"\n            );\n        }\n\n        // todo add guarantee validation logic for contract reference 2\n\n        // compute the initial state of the asset\n        State memory initialState = ICEGEngine(engine).computeInitialState(terms);\n\n        // register the asset in the AssetRegistry\n        ICEGRegistry(address(assetRegistry)).registerAsset(\n            assetId,\n            terms,\n            initialState,\n            schedule,\n            ownership,\n            engine,\n            address(this),\n            admin\n        );\n\n        emit InitializedAsset(assetId, ContractType.CEG, ownership.creatorObligor, ownership.counterpartyObligor);\n    }\n\n    function computeStateAndPayoffForEvent(bytes32 assetId, State memory state, bytes32 _event)\n        internal\n        view\n        override\n        returns (State memory, int256)\n    {\n        address engine = assetRegistry.getEngine(assetId);\n        CEGTerms memory terms = ICEGRegistry(address(assetRegistry)).getTerms(assetId);\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n\n        int256 payoff = ICEGEngine(engine).computePayoffForEvent(\n            terms,\n            state,\n            _event,\n            getExternalDataForPOF(\n                assetId,\n                eventType,\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate)\n            )\n        );\n        state = ICEGEngine(engine).computeStateForEvent(\n            terms,\n            state,\n            _event,\n            getExternalDataForSTF(\n                assetId,\n                eventType,\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate)\n            )\n        );\n\n        return (state, payoff);\n    }\n\n    /**\n     * @notice Retrieves external data (such as market object data, block time, underlying asset state)\n     * used for evaluating the STF for a given event.\n     */\n    function getExternalDataForSTF(\n        bytes32 assetId,\n        EventType eventType,\n        uint256 /* timestamp */\n    )\n        internal\n        view\n        override\n        returns (bytes32)\n    {\n        if (eventType == EventType.CE) {\n            // get current timestamp\n            // solium-disable-next-line\n            return bytes32(block.timestamp);\n        } else if (eventType == EventType.EXE) {\n            // get the remaining notionalPrincipal from the underlying\n            ContractReference memory contractReference_1 = assetRegistry.getContractReferenceValueForTermsAttribute(\n                assetId,\n                \"contractReference_1\"\n            );\n            if (contractReference_1.role == ContractReferenceRole.COVE) {\n                bytes32 underlyingAssetId = contractReference_1.object;\n                address underlyingRegistry = address(uint160(uint256(contractReference_1.object2)));\n                require(\n                    IAssetRegistry(underlyingRegistry).isRegistered(underlyingAssetId) == true,\n                    \"BaseActor.getExternalDataForSTF: ASSET_DOES_NOT_EXIST\"\n                );\n                return bytes32(\n                    IAssetRegistry(underlyingRegistry).getIntValueForStateAttribute(underlyingAssetId, \"notionalPrincipal\")\n                );\n            }\n        }\n\n        return bytes32(0);\n    }\n}"
    },
    "contracts/ACTUS/Engines/STK/STKEngine.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\n\nimport \"../../Core/Core.sol\";\nimport \"../../Core/SignedMath.sol\";\nimport \"./ISTKEngine.sol\";\nimport \"./STKSTF.sol\";\nimport \"./STKPOF.sol\";\n\n\n/**\n * @title STKEngine\n * @notice Inherits from BaseEngine by implementing STFs, POFs according to the ACTUS standard for a STK contract\n * @dev All numbers except unix timestamp are represented as multiple of 10 ** 18\n */\ncontract STKEngine is Core, STKSTF, STKPOF, ISTKEngine {\n\n    using SignedSafeMath for int;\n    using SignedMath for int;\n\n\n    function contractType() external pure override returns (ContractType) {\n        return ContractType.STK;\n    }\n\n    /**\n     * Applies an event to the current state of a contract and returns the resulting contract state.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event to be applied to the contract state\n     * @param externalData external data needed for STF evaluation (e.g. rate for RR events)\n     * @return the resulting contract state\n     */\n    function computeStateForEvent(\n        STKTerms calldata terms,\n        State calldata state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        external\n        pure\n        override\n        returns (State memory)\n    {\n        return stateTransitionFunction(\n            terms,\n            state,\n            _event,\n            externalData\n        );\n    }\n\n    /**\n     * Evaluates the payoff for an event under the current state of the contract.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which the payoff should be evaluated\n     * @param externalData external data needed for POF evaluation (e.g. fxRate)\n     * @return the payoff of the event\n     */\n    function computePayoffForEvent(\n        STKTerms calldata terms,\n        State calldata state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        external\n        pure\n        override\n        returns (int256)\n    {\n        // if alternative settlementCurrency is set then apply fxRate to payoff\n        if (terms.settlementCurrency != address(0) && terms.currency != terms.settlementCurrency) {\n            return payoffFunction(\n                terms,\n                state,\n                _event,\n                externalData\n            ).floatMult(int256(externalData));\n        }\n\n        return payoffFunction(\n            terms,\n            state,\n            _event,\n            externalData\n        );\n    }\n\n    /**\n     * @notice Initialize contract state space based on the contract terms.\n     * @param terms terms of the contract\n     * @return the initial state of the contract\n     */\n    function computeInitialState(STKTerms calldata terms)\n        external\n        pure\n        override\n        returns (State memory)\n    {\n        State memory state;\n\n        state.contractPerformance = ContractPerformance.PF;\n        state.statusDate = terms.statusDate;\n\n        return state;\n    }\n\n    /**\n     * @notice Computes a schedule segment of non-cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * _param terms terms of the contract\n     * _param segmentStart start timestamp of the segment\n     * _param segmentEnd end timestamp of the segment\n     * @return segment of the non-cyclic schedule\n     */\n    function computeNonCyclicScheduleSegment(\n        STKTerms calldata terms,\n        uint256 segmentStart,\n        uint256 segmentEnd\n    )\n        external\n        pure\n        override\n        returns (bytes32[] memory)\n    {\n        bytes32[MAX_EVENT_SCHEDULE_SIZE] memory events;\n        uint16 index;\n\n        // issue date\n        if (terms.issueDate != 0) {\n            if (isInSegment(terms.issueDate, segmentStart, segmentEnd)) {\n                events[index] = encodeEvent(EventType.ISS, terms.issueDate);\n                index++;\n            }\n        }\n\n        // TODO: implement when 'Ex/Settlement'- dates get supported in State/Terms\n\n        // remove null entries from returned array\n        bytes32[] memory schedule = new bytes32[](index);\n        for (uint256 i = 0; i < index; i++) {\n            schedule[i] = events[i];\n        }\n\n        return schedule;\n    }\n\n    /**\n     * @notice Computes a schedule segment of cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segment\n     * @param eventType eventType of the cyclic schedule\n     * @return event schedule segment\n     */\n    function computeCyclicScheduleSegment(\n        STKTerms calldata terms,\n        uint256 segmentStart,\n        uint256 segmentEnd,\n        EventType eventType\n    )\n        external\n        pure\n        override\n        returns(bytes32[] memory)\n    {\n        bytes32[MAX_EVENT_SCHEDULE_SIZE] memory events;\n        uint256 index;\n\n        if (eventType == EventType.DIF) {\n            if (terms.cycleAnchorDateOfDividend != 0) {\n                uint256[MAX_CYCLE_SIZE] memory dividendSchedule = computeDatesFromCycleSegment(\n                    terms.cycleAnchorDateOfDividend,\n                    segmentEnd,\n                    terms.cycleOfDividend,\n                    terms.endOfMonthConvention,\n                    false,\n                    segmentStart,\n                    segmentEnd\n                );\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\n                    if (dividendSchedule[i] == 0) break;\n                    if (isInSegment(dividendSchedule[i], segmentStart, segmentEnd) == false) continue;\n                    events[index] = encodeEvent(EventType.DIF, dividendSchedule[i]);\n                    index++;\n                }\n            }\n        }\n\n        // remove null entries from returned array\n        bytes32[] memory schedule = new bytes32[](index);\n        for (uint256 i = 0; i < index; i++) {\n            schedule[i] = events[i];\n        }\n\n        return schedule;\n    }\n\n    /**\n     * @notice Computes the next non-cyclic contract events based on the contract terms\n     * and the timestamp on which the prev. event occured.\n     * @dev Assumes that non-cyclic events of the same event type have a unique schedule time\n     * param terms terms of the contract\n     * param lastNonCyclicEvent last non-cyclic event\n     * @return next non-cyclic event\n     */\n    function computeNextNonCyclicEvent(\n        STKTerms calldata terms,\n        bytes32 lastNonCyclicEvent\n    )\n        external\n        pure\n        override\n        returns (bytes32)\n    {\n        (EventType lastEventType, uint256 lastScheduleTime) = decodeEvent(lastNonCyclicEvent);\n\n        EventType eventTypeNextEvent;\n        uint256 scheduleTimeNextEvent;\n\n        // EventTypes ordered after epoch offset - so we don't have make an additional epochOffset check\n\n        // issue date\n        if (\n            // date for event has to be set in terms and date of event can be in the past\n            (terms.issueDate != 0 && (lastScheduleTime <= terms.issueDate))\n            // date for event has to come before previous candidate for the next event\n            && (scheduleTimeNextEvent == 0 || terms.issueDate < scheduleTimeNextEvent)\n            // avoid endless loop by requiring that the event is not the lastNonCyclicEvent\n            && (lastScheduleTime != terms.issueDate || lastEventType != EventType.ISS)\n        ) {\n            eventTypeNextEvent = EventType.ISS;\n            scheduleTimeNextEvent = terms.issueDate;\n        }\n\n        return encodeEvent(eventTypeNextEvent, scheduleTimeNextEvent);\n    }\n\n    /**\n     * @notice Computes a schedule segment of cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param lastScheduleTime last occurrence of cyclic event\n     * @param eventType eventType of the cyclic schedule\n     * @return event schedule segment\n     */\n    function computeNextCyclicEvent(\n        STKTerms calldata terms,\n        uint256 lastScheduleTime,\n        EventType eventType\n    )\n        external\n        pure\n        override\n        returns(bytes32)\n    {\n        if (eventType == EventType.DIF) {\n            if (terms.cycleAnchorDateOfDividend != 0) {\n                uint256 nextDividendDeclarationDate = computeNextCycleDateFromPrecedingDate(\n                    terms.cycleOfDividend,\n                    terms.endOfMonthConvention,\n                    terms.cycleAnchorDateOfDividend,\n                    lastScheduleTime,\n                    true,\n                    0\n                );\n                if (nextDividendDeclarationDate == uint256(0)) return bytes32(0);\n                return encodeEvent(EventType.DIF, nextDividendDeclarationDate);\n            }\n        }\n\n        return bytes32(0);\n    }\n\n    /**\n     * @notice Verifies that the provided event is still scheduled under the terms, the current state of the\n     * contract and the current state of the underlying.\n     * param _event event for which to check if its still scheduled\n     * param terms terms of the contract\n     * @param state current state of the contract\n     * param hasUnderlying boolean indicating whether the contract has an underlying contract\n     * param underlyingState state of the underlying (empty state object if non-existing)\n     * @return boolean indicating whether event is still scheduled\n     */\n    function isEventScheduled(\n        bytes32 /* _event */,\n        STKTerms calldata /* terms */,\n        State calldata state,\n        bool /* hasUnderlying */,\n        State calldata /* underlyingState */\n    )\n        external\n        pure\n        override\n        returns (bool)\n    {\n        if (\n            state.contractPerformance == ContractPerformance.DF\n            || state.contractPerformance == ContractPerformance.MD\n            || state.contractPerformance == ContractPerformance.TD\n        ) { return false; }\n\n        return true;\n    }\n\n    /**\n     * @notice Implements abstract method which is defined in BaseEngine.\n     * Applies an event to the current state of the contract and returns the resulting state.\n     * The inheriting Engine contract has to map the events type to the designated STF.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which to evaluate the next state for\n     * @param externalData external data needed for STF evaluation (e.g. rate for RR events)\n     * @return the resulting contract state\n     */\n    function stateTransitionFunction(\n        STKTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n\n        if (eventType == EventType.AD) return STF_STK_AD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.ISS) return STF_STK_ISS(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.DIF) return STF_STK_DIF(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.DIX) return STF_STK_DIX(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.DIP) return STF_STK_DIP(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.SPF) return STF_STK_SPF(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.SPS) return STF_STK_SPS(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.REF) return STF_STK_REF(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.REX) return STF_STK_REX(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.REP) return STF_STK_REP(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.TD) return STF_STK_TD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.CE) return STF_STK_CE(terms, state, scheduleTime, externalData);\n\n        revert(\"STKEngine.stateTransitionFunction: ATTRIBUTE_NOT_FOUND\");\n    }\n\n    /**\n     * @notice Implements abstract method which is defined in BaseEngine.\n     * Computes the payoff for an event under the current state of the contract.\n     * The inheriting Engine contract has to map the events type to the designated POF.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which the payoff should be evaluated\n     * @param externalData external data needed for POF evaluation (e.g. fxRate)\n     * @return the payoff of the event\n     */\n    function payoffFunction(\n        STKTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (int256)\n    {\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n\n        if (eventType == EventType.AD) return 0;\n        if (eventType == EventType.ISS) return 0;\n        if (eventType == EventType.DIF) return 0;\n        if (eventType == EventType.DIX) return 0;\n        if (eventType == EventType.SPF) return 0;\n        if (eventType == EventType.SPS) return 0;\n        if (eventType == EventType.REF) return 0;\n        if (eventType == EventType.REX) return 0;\n        if (eventType == EventType.CE) return 0;\n        if (eventType == EventType.DIP) return POF_STK_DIP(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.REP) return POF_STK_REP(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.TD) return POF_STK_TD(terms, state, scheduleTime, externalData);\n\n        revert(\"STKEngine.payoffFunction: ATTRIBUTE_NOT_FOUND\");\n    }\n}\n"
    },
    "contracts/ACTUS/Core/Core.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\r\npragma solidity ^0.7.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./ACTUSTypes.sol\";\r\nimport \"./ACTUSConstants.sol\";\r\nimport \"./Utils/Utils.sol\";\r\nimport \"./Conventions/BusinessDayConventions.sol\";\r\nimport \"./Conventions/ContractRoleConventions.sol\";\r\nimport \"./Conventions/DayCountConventions.sol\";\r\nimport \"./Conventions/EndOfMonthConventions.sol\";\r\n\r\n\r\n/**\r\n * @title Core\r\n * @notice Contains all type definitions, conventions as specified by the ACTUS Standard\r\n * and utility methods for generating event schedules\r\n */\r\ncontract Core is\r\n    ACTUSConstants,\r\n    ContractRoleConventions,\r\n    DayCountConventions,\r\n    EndOfMonthConventions,\r\n    Utils\r\n{}\r\n"
    },
    "contracts/ACTUS/Engines/STK/STKSTF.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\n\nimport \"../../Core/Core.sol\";\nimport \"../../Core/SignedMath.sol\";\n\n\n/**\n * @title STF\n * @notice Contains all state transition functions (STFs) for STK contracts\n */\ncontract STKSTF is Core {\n\n    using SignedSafeMath for int;\n    using SignedMath for int;\n\n\n    /**\n     * State transition for STK monitoring events\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_STK_AD (\n        STKTerms memory /* terms */,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n    internal\n    pure\n    returns (State memory)\n    {\n        state.statusDate = scheduleTime;\n        return state;\n    }\n\n    /**\n     * State transition for STK issue fixing events\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_STK_ISS (\n        STKTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        state.quantity = terms.quantity;\n        state.notionalPrincipal = terms.notionalPrincipal;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for STK dividend fixing events\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_STK_DIF (\n        STKTerms memory /* terms */,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        state.dividendPaymentAmount = int256(externalData);\n        state.lastDividendFixingDate = scheduleTime;\n        state.statusDate = scheduleTime;\n        return state;\n    }\n\n    /**\n     * State transition for STK dividend fixing events\n     * TODO: implement\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_STK_DIX (\n        STKTerms memory /* terms */,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        state.statusDate = scheduleTime;\n        return state;\n    }\n\n    /**\n     * State transition for STK dividend payment events\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_STK_DIP (\n        STKTerms memory /* terms */,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n    internal\n    pure\n    returns (State memory)\n    {\n        state.dividendPaymentAmount = 0;\n        state.statusDate = scheduleTime;\n        return state;\n    }\n\n    /**\n     * State transition for STK split fixing events\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_STK_SPF (\n        STKTerms memory /* terms */,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n    internal\n    pure\n    returns (State memory)\n    {\n        state.splitRatio = int256(externalData);\n        state.statusDate = scheduleTime;\n        return state;\n    }\n\n    /**\n     * State transition for STK split settlement events\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_STK_SPS (\n        STKTerms memory /* terms */,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n    internal\n    pure\n    returns (State memory)\n    {\n        state.quantity = state.splitRatio.floatMult(state.quantity);\n        state.splitRatio = 0;\n        state.statusDate = scheduleTime;\n        return state;\n    }\n\n    /**\n     * State transition for STK redemption fixing events\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_STK_REF (\n        STKTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n    internal\n    pure\n    returns (State memory)\n    {\n        if (terms.redeemableByIssuer == RedeemableByIssuer.Y) {\n            state.exerciseQuantity = int256(externalData);\n        }\n\n        state.statusDate = scheduleTime;\n        return state;\n    }\n\n    /**\n     * State transition for STK redemption payment events\n     * @param state the old state\n     * TODO: implement\n     * @return the new state\n     */\n    function STF_STK_REX (\n        STKTerms memory /* terms */,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        state.statusDate = scheduleTime;\n        return state;\n    }\n\n    /**\n     * State transition for STK redemption payment events\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_STK_REP (\n        STKTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        if (terms.redeemableByIssuer == RedeemableByIssuer.Y) {\n            state.quantity = state.quantity.sub(state.exerciseQuantity);\n            state.exerciseQuantity = 0;\n        }\n\n        state.statusDate = scheduleTime;\n        return state;\n    }\n\n    /**\n     * State transition for STK redemption payment events\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_STK_TD (\n        STKTerms memory /* terms */,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        state.statusDate = scheduleTime;\n        return state;\n    }\n\n    /**\n     * State transition for CERTF settlement\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_STK_CE (\n        STKTerms memory /* terms */,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        state.statusDate = scheduleTime;\n        return state;\n    }\n}\n"
    },
    "contracts/ACTUS/Engines/STK/STKPOF.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\n\nimport \"../../Core/Core.sol\";\nimport \"../../Core/SignedMath.sol\";\n\n\n/**\n * @title POF\n * @notice Contains all Payoff Functions (POFs) for STK contracts\n */\ncontract STKPOF is Core {\n\n    using SignedSafeMath for int;\n    using SignedMath for int;\n\n\n    /**\n     * Payoff Function for STK dividend payment events\n     * @return the dividend payoff\n     */\n    function POF_STK_DIP (\n        STKTerms memory terms,\n        State memory state,\n        uint256 /* scheduleTime */,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        return (\n            roleSign(terms.contractRole) * state.dividendPaymentAmount\n        );\n    }\n\n    /**\n     * Payoff Function for STK redemption payment events\n     * @return the redemption payoff\n     */\n    function POF_STK_REP (\n        STKTerms memory terms,\n        State memory state,\n        uint256 /* scheduleTime */,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        if (terms.redeemableByIssuer == RedeemableByIssuer.Y) {\n            return (\n                roleSign(terms.contractRole) * state.exerciseQuantity\n                .floatMult(terms.redemptionPrice != 0 ? terms.redemptionPrice : int256(externalData))\n            );\n        }\n        \n        return 0;\n    }\n\n     /**\n     * Payoff Function for STK termination events\n     * @return the termination payoff\n     */\n    function POF_STK_TD (\n        STKTerms memory terms,\n        State memory state,\n        uint256 /* scheduleTime */,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        return (\n            roleSign(terms.contractRole) * state.quantity.floatMult(terms.priceAtTerminationDate)\n        );\n    }\n}\n"
    },
    "contracts/ACTUS/Core/Utils/Utils.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../ACTUSTypes.sol\";\nimport \"../Conventions/BusinessDayConventions.sol\";\n\nimport \"./EventUtils.sol\";\nimport \"./PeriodUtils.sol\";\nimport \"./CycleUtils.sol\";\n\n\n/**\n * @title Utils\n * @notice Utility methods used throughout Core and all Engines\n */\ncontract Utils is BusinessDayConventions, EventUtils, PeriodUtils, CycleUtils {\n\n    /**\n     * @notice Returns the event time for a given schedule time\n     * @dev For optimization reasons not located in EventUtil\n     * by applying the BDC specified in the terms\n     */\n    function computeEventTimeForEvent(bytes32 _event, BusinessDayConvention bdc, Calendar calendar, uint256 maturityDate)\n        public\n        pure\n        returns (uint256)\n    {\n        (, uint256 scheduleTime) = decodeEvent(_event);\n\n        // handle maturity date\n        return shiftEventTime(scheduleTime, bdc, calendar, maturityDate);\n    }\n}\n"
    },
    "contracts/ACTUS/Core/Conventions/ContractRoleConventions.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\n\nimport \"../ACTUSTypes.sol\";\n\n\n/**\n * @title ContractRoleConventions\n */\ncontract ContractRoleConventions {\n\n    /**\n     * Returns the role sign for a given Contract Role.\n     */\n    function roleSign(ContractRole contractRole)\n        internal\n        pure\n        returns (int8)\n    {\n        if (contractRole == ContractRole.RPA) return 1;\n        if (contractRole == ContractRole.RPL) return -1;\n\n        if (contractRole == ContractRole.BUY) return 1;\n        if (contractRole == ContractRole.SEL) return -1;\n\n        if (contractRole == ContractRole.RFL) return 1;\n        if (contractRole == ContractRole.PFL) return -1;\n\n        revert(\"ContractRoleConvention.roleSign: ATTRIBUTE_NOT_FOUND\");\n    }\n}\n"
    },
    "contracts/ACTUS/Core/Conventions/DayCountConventions.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\nimport \"../../../external/BokkyPooBah/BokkyPooBahsDateTimeLibrary.sol\";\n\nimport \"../ACTUSTypes.sol\";\nimport \"../SignedMath.sol\";\n\n\n/**\n * @title DayCountConventions\n * @notice Implements various ISDA day count conventions as specified by ACTUS\n */\ncontract DayCountConventions {\n\n    using SafeMath for uint;\n    using SignedSafeMath for int;\n    using SignedMath for int;\n\n    /**\n     * Returns the fraction of the year between two timestamps.\n     */\n    function yearFraction(\n        uint256 startTimestamp,\n        uint256 endTimestamp,\n        DayCountConvention ipdc,\n        uint256 maturityDate\n    )\n        internal\n        pure\n        returns (int256)\n    {\n        require(endTimestamp >= startTimestamp, \"Core.yearFraction: START_NOT_BEFORE_END\");\n        if (ipdc == DayCountConvention.AA) {\n            return actualActual(startTimestamp, endTimestamp);\n        } else if (ipdc == DayCountConvention.A360) {\n            return actualThreeSixty(startTimestamp, endTimestamp);\n        } else if (ipdc == DayCountConvention.A365) {\n            return actualThreeSixtyFive(startTimestamp, endTimestamp);\n        } else if (ipdc == DayCountConvention._30E360) {\n            return thirtyEThreeSixty(startTimestamp, endTimestamp);\n        } else if (ipdc == DayCountConvention._30E360ISDA) {\n            return thirtyEThreeSixtyISDA(startTimestamp, endTimestamp, maturityDate);\n        } else if (ipdc == DayCountConvention._28E336) {\n            // not implemented yet\n            revert(\"DayCountConvention.yearFraction: ATTRIBUTE_NOT_SUPPORTED.\");\n        } else {\n            revert(\"DayCountConvention.yearFraction: ATTRIBUTE_NOT_FOUND.\");\n        }\n    }\n\n    /**\n     * ISDA A/A day count convention\n     */\n    function actualActual(uint256 startTime, uint256 endTime)\n        internal\n        pure\n        returns (int256)\n    {\n        uint256 d1Year = BokkyPooBahsDateTimeLibrary.getYear(startTime);\n        uint256 d2Year = BokkyPooBahsDateTimeLibrary.getYear(endTime);\n\n        int256 firstBasis = (BokkyPooBahsDateTimeLibrary.isLeapYear(startTime)) ? 366 : 365;\n\n        if (d1Year == d2Year) {\n            return int256(BokkyPooBahsDateTimeLibrary.diffDays(startTime, endTime)).floatDiv(firstBasis);\n        }\n\n        int256 secondBasis = (BokkyPooBahsDateTimeLibrary.isLeapYear(endTime)) ? 366 : 365;\n\n        int256 firstFraction = int256(BokkyPooBahsDateTimeLibrary.diffDays(\n            startTime,\n            BokkyPooBahsDateTimeLibrary.timestampFromDate(d1Year.add(1), 1, 1)\n        )).floatDiv(firstBasis);\n        int256 secondFraction = int256(BokkyPooBahsDateTimeLibrary.diffDays(\n            BokkyPooBahsDateTimeLibrary.timestampFromDate(d2Year, 1, 1),\n            endTime\n        )).floatDiv(secondBasis);\n\n        return firstFraction.add(secondFraction).add(int256(d2Year.sub(d1Year).sub(1)));\n    }\n\n    /**\n     * ISDA A/360 day count convention\n     */\n    function actualThreeSixty(uint256 startTime, uint256 endTime)\n        internal\n        pure\n        returns (int256)\n    {\n        return (int256((endTime.sub(startTime)).div(86400)).floatDiv(360));\n    }\n\n    /**\n     * ISDA A/365-Fixed day count convention\n     */\n    function actualThreeSixtyFive(uint256 startTime, uint256 endTime)\n        internal\n        pure\n        returns (int256)\n    {\n        return (int256((endTime.sub(startTime)).div(86400)).floatDiv(365));\n    }\n\n    /**\n     * ISDA 30E/360 day count convention\n     */\n    function thirtyEThreeSixty(uint256 startTime, uint256 endTime)\n        internal\n        pure\n        returns (int256)\n    {\n        uint256 d1Day;\n        uint256 d1Month;\n        uint256 d1Year;\n\n        uint256 d2Day;\n        uint256 d2Month;\n        uint256 d2Year;\n\n        (d1Year, d1Month, d1Day) = BokkyPooBahsDateTimeLibrary.timestampToDate(startTime);\n        (d2Year, d2Month, d2Day) = BokkyPooBahsDateTimeLibrary.timestampToDate(endTime);\n\n        if (d1Day == 31) {\n            d1Day = 30;\n        }\n\n        if (d2Day == 31) {\n            d2Day = 30;\n        }\n\n        int256 delD = int256(d2Day).sub(int256(d1Day));\n        int256 delM = int256(d2Month).sub(int256(d1Month));\n        int256 delY = int256(d2Year).sub(int256(d1Year));\n\n        return ((delY.mul(360).add(delM.mul(30)).add(delD)).floatDiv(360));\n    }\n\n    /**\n     * ISDA 30E/360-ISDA day count convention\n     */\n    function thirtyEThreeSixtyISDA(uint256 startTime, uint256 endTime, uint256 maturityDate)\n        internal\n        pure\n        returns (int256)\n    {\n        uint256 d1Day;\n        uint256 d1Month;\n        uint256 d1Year;\n\n        uint256 d2Day;\n        uint256 d2Month;\n        uint256 d2Year;\n\n        (d1Year, d1Month, d1Day) = BokkyPooBahsDateTimeLibrary.timestampToDate(startTime);\n        (d2Year, d2Month, d2Day) = BokkyPooBahsDateTimeLibrary.timestampToDate(endTime);\n\n        if (d1Day == BokkyPooBahsDateTimeLibrary.getDaysInMonth(startTime)) {\n            d1Day = 30;\n        }\n\n        if (!(endTime == maturityDate && d2Month == 2) && d2Day == BokkyPooBahsDateTimeLibrary.getDaysInMonth(endTime)) {\n            d2Day = 30;\n        }\n\n        int256 delD = int256(d2Day).sub(int256(d1Day));\n        int256 delM = int256(d2Month).sub(int256(d1Month));\n        int256 delY = int256(d2Year).sub(int256(d1Year));\n\n        return ((delY.mul(360).add(delM.mul(30)).add(delD)).floatDiv(360));\n    }\n}"
    },
    "contracts/ACTUS/Core/Conventions/EndOfMonthConventions.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../../external/BokkyPooBah/BokkyPooBahsDateTimeLibrary.sol\";\n\nimport \"../ACTUSTypes.sol\";\n\n\n/**\n * @title EndOfMonthConventions\n * @notice Implements the ACTUS end of month convention.\n */\ncontract EndOfMonthConventions {\n\n    /**\n     * This function makes an adjustment on the end of month convention.\n     * @dev The following is considered to dertermine if schedule dates are shifted to the end of month:\n     * - The convention SD (same day) means not adjusting, EM (end of month) means adjusting\n     * - Dates are only shifted if the schedule start date is an end-of-month date\n     * - Dates are only shifted if the schedule cycle is based on an \"M\" period unit or multiple thereof\n     * @param eomc the end of month convention to adjust\n     * @param startTime timestamp of the cycle start\n     * @param cycle the cycle struct\n     * @return the adjusted end of month convention\n     */\n    function adjustEndOfMonthConvention(\n        EndOfMonthConvention eomc,\n        uint256 startTime,\n        IPS memory cycle\n    )\n        public\n        pure\n        returns (EndOfMonthConvention)\n    {\n        if (eomc == EndOfMonthConvention.EOM) {\n            // check if startTime is last day in month and schedule has month based period\n            // otherwise switch to SD convention\n            if (\n                BokkyPooBahsDateTimeLibrary.getDay(startTime) == BokkyPooBahsDateTimeLibrary.getDaysInMonth(startTime) &&\n                (cycle.p == P.M || cycle.p == P.Q || cycle.p == P.H)\n            ) {\n                return EndOfMonthConvention.EOM;\n            }\n            return EndOfMonthConvention.SD;\n        } else if (eomc == EndOfMonthConvention.SD) {\n            return EndOfMonthConvention.SD;\n        }\n        revert(\"EndOfMonthConvention.adjustEndOfMonthConvention: ATTRIBUTE_NOT_FOUND.\");\n    }\n\n    /**\n\t * This function is for the EndOfMonthConvention.EOM convention and\n\t * shifts a timestamp to the last day of the month.\n\t * @param timestamp the timestmap to shift\n\t * @return the shifted timestamp\n\t */\n\tfunction shiftEndOfMonth(uint256 timestamp)\n\t  internal\n\t  pure\n\t  returns (uint256)\n\t{\n        // // check if startTime is last day in month and schedule has month based period\n        // // otherwise switch to SD convention\n        // if (\n        //     eomc != EndOfMonthConvention.EOM\n        //     || BokkyPooBahsDateTimeLibrary.getDay(startTime) != BokkyPooBahsDateTimeLibrary.getDaysInMonth(startTime)\n        //     || (cycle.p == P.M || cycle.p == P.Q || cycle.p == P.H)\n        // ) {\n        //     // SD\n        //     return timestamp;\n        // }\n\n\t\tuint256 year;\n\t\tuint256 month;\n\t\tuint256 day;\n\t\t(year, month, day) = BokkyPooBahsDateTimeLibrary.timestampToDate(timestamp);\n\t\tuint256 lastDayOfMonth = BokkyPooBahsDateTimeLibrary._getDaysInMonth(year, month);\n\n\t\treturn BokkyPooBahsDateTimeLibrary.timestampFromDate(year, month, lastDayOfMonth);\n\t}\n}\n"
    },
    "contracts/ACTUS/Core/Utils/CycleUtils.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath as SafeMul} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../../../external/BokkyPooBah/BokkyPooBahsDateTimeLibrary.sol\";\n\nimport \"../ACTUSTypes.sol\";\nimport \"../ACTUSConstants.sol\";\nimport \"../Conventions/EndOfMonthConventions.sol\";\nimport \"./PeriodUtils.sol\";\n\n\n/**\n * @title Schedule\n * @notice Methods related to generating event schedules.\n */\ncontract CycleUtils is ACTUSConstants, EndOfMonthConventions, PeriodUtils {\n\n    using BokkyPooBahsDateTimeLibrary for uint;\n    using SafeMul for uint;\n\n    /**\n     * @notice Applies the cycle n - times (n := cycleIndex) to a given date\n     */\n    function getNextCycleDate(IPS memory cycle, uint256 cycleStart, uint256 cycleIndex)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 newTimestamp;\n\n        if (cycle.p == P.D) {\n            newTimestamp = cycleStart.addDays(cycle.i.mul(cycleIndex));\n        } else if (cycle.p == P.W) {\n            newTimestamp = cycleStart.addDays(cycle.i.mul(7).mul(cycleIndex));\n        } else if (cycle.p == P.M) {\n            newTimestamp = cycleStart.addMonths(cycle.i.mul(cycleIndex));\n        } else if (cycle.p == P.Q) {\n            newTimestamp = cycleStart.addMonths(cycle.i.mul(3).mul(cycleIndex));\n        } else if (cycle.p == P.H) {\n            newTimestamp = cycleStart.addMonths(cycle.i.mul(6).mul(cycleIndex));\n        } else if (cycle.p == P.Y) {\n            newTimestamp = cycleStart.addYears(cycle.i.mul(cycleIndex));\n        } else {\n            revert(\"Schedule.getNextCycleDate: ATTRIBUTE_NOT_FOUND\");\n        }\n\n        return newTimestamp;\n    }\n\n    /**\n     * Computes an array of timestamps that represent dates in a cycle falling within a given segment.\n     * @dev There are some notable edge cases: If the cycle is \"not set\" we return the start end end dates\n     * of the cycle if they lie within the segment. Otherwise and empty array is returned.\n     * @param cycleStart start time of the cycle\n     * @param cycleEnd end time of the cycle\n     * @param cycle IPS cycle\n     * @param eomc end of month convention\n     * @param addEndDate end date of the cycle should be added to the result if it falls in the segment\n     * @param segmentStart start time of the segment\n     * @param segmentEnd end time of the segment\n     * @return an array of timestamps from the given cycle that fall within the specified segement\n     */\n    function computeDatesFromCycleSegment(\n        uint256 cycleStart,\n        uint256 cycleEnd,\n        IPS memory cycle,\n        EndOfMonthConvention eomc,\n        bool addEndDate,\n        uint256 segmentStart,\n        uint256 segmentEnd\n    )\n        internal\n        pure\n        returns (uint256[MAX_CYCLE_SIZE] memory)\n    {\n        uint256[MAX_CYCLE_SIZE] memory dates;\n        uint256 index;\n\n        // if the cycle is not set we return only the cycle start end end dates under these conditions:\n        // we return the cycle start, if it's in the segment\n        // in case of addEntTime = true, the cycle end is also returned if in the segment\n        if (cycle.isSet == false) {\n            if (isInSegment(cycleStart, segmentStart, segmentEnd)) {\n                dates[index] = cycleStart;\n                index++;\n            }\n            if (isInSegment(cycleEnd, segmentStart, segmentEnd)) {\n                if (addEndDate == true) dates[index] = cycleEnd;\n            }\n            return dates;\n        }\n\n        uint256 date = cycleStart;\n        uint256 cycleIndex;\n\n        EndOfMonthConvention actualEOMC = adjustEndOfMonthConvention(eomc, cycleStart, cycle);\n\n        // walk through the cycle and create the cycle dates to be returned\n        while (date < cycleEnd) {\n            // if date is in segment and MAX_CYCLE_SIZE is not reached add it to the output array\n            if (isInSegment(date, segmentStart, segmentEnd)) {\n                require(index < (MAX_CYCLE_SIZE - 2), \"Schedule.computeDatesFromCycle: MAX_CYCLE_SIZE\");\n                dates[index] = date;\n                index++;\n            }\n\n            cycleIndex++;\n\n            date = (actualEOMC == EndOfMonthConvention.EOM)\n                ? shiftEndOfMonth(getNextCycleDate(cycle, cycleStart, cycleIndex))\n                : getNextCycleDate(cycle, cycleStart, cycleIndex);\n        }\n\n        // add additional time at the end if addEndDate\n        if (addEndDate == true) {\n            if (isInSegment(cycleEnd, segmentStart, segmentEnd)) {\n                dates[index] = cycleEnd;\n            }\n        }\n\n        // handle a special case where S is set to LONG (e.g. for trimming a cycle to the maturity date)\n        if (index > 0 && isInSegment(dates[index - 1], segmentStart, segmentEnd)) {\n            if (cycle.s == S.LONG && index > 1 && cycleEnd != date) {\n                dates[index - 1] = dates[index];\n                delete dates[index];\n            }\n        }\n\n        return dates;\n    }\n\n    /**\n     * Computes the next date for a given an IPS cycle.\n     * @param cycle IPS cycle\n     * @param eomc end of month convention\n     * @param anchorDate anchor date of the cycle\n     * @param precedingDate the previous date of the cycle\n     * @param addEndDate end date of the cycle should be added to the result if it falls in the segment\n     * @param cycleEnd end date of the cyclic schedule\n     * @return next date of the cycle\n     */\n    function computeNextCycleDateFromPrecedingDate(\n        IPS memory cycle,\n        EndOfMonthConvention eomc,\n        uint256 anchorDate,\n        uint256 precedingDate,\n        bool addEndDate,\n        uint256 cycleEnd\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        if (cycle.isSet == false || precedingDate == 0) return anchorDate;\n\n        uint256 nextCyclicDate = (adjustEndOfMonthConvention(eomc, anchorDate, cycle) == EndOfMonthConvention.EOM)\n            ? shiftEndOfMonth(getNextCycleDate(cycle, precedingDate, 1))\n            : getNextCycleDate(cycle, precedingDate, 1);\n\n        if (addEndDate && cycleEnd != 0) {\n            // handle infinite loop (since preceding date is cycleEnd)\n            if (precedingDate == cycleEnd) return 0;\n            // add occurence at cycle end if date is greater than cycle end\n            if (nextCyclicDate > cycleEnd) return cycleEnd;\n        }\n        // remove occurence if it is one cycle end\n        if (addEndDate == false && cycleEnd != 0 && nextCyclicDate == cycleEnd) return 0;\n\n        return nextCyclicDate;\n    }\n\n    /*\n     * @notice Checks if a timestamp is in a given range.\n     */\n    function isInSegment(\n        uint256 timestamp,\n        uint256 startTimestamp,\n        uint256 endTimestamp\n    )\n        internal\n        pure\n        returns (bool)\n    {\n        if (startTimestamp > endTimestamp) return false;\n        if (startTimestamp <= timestamp && timestamp <= endTimestamp) return true;\n        return false;\n    }\n}\n"
    },
    "contracts/ACTUS/test/STK/TestSTKPOF.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../Engines/STK/STKPOF.sol\";\n\n\n/**\n* These helper contracts expose internal functions for unit testing.\n*/\ncontract TestSTKPOF is STKPOF {\n\n\n    function _POF_STK_DIP(\n        STKTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n    public\n    pure\n    returns (int256)\n    {\n        return POF_STK_DIP(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _POF_STK_REP(\n        STKTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n    public\n    pure\n    returns (int256)\n    {\n        return POF_STK_REP(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _POF_STK_TD(\n        STKTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n    public\n    pure\n    returns (int256)\n    {\n        return POF_STK_TD(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n}\n"
    },
    "contracts/ACTUS/test/TestSignedMath.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../Core/SignedMath.sol\";\n\n\n/**\n* These helper contracts expose internal functions for unit testing.\n*/\ncontract TestSignedMath {\n\n    using SignedMath for int;\n\n    function _floatMult(int256 a, int256 b)\n        public\n        pure\n        returns (int256)\n    {\n        return int(a).floatMult(b);\n    }\n\n    function _floatDiv(int256 a, int256 b)\n        public\n        pure\n        returns (int256)\n    {\n        return int(a).floatDiv(b);\n    }\n\n    function _min(int256 a, int256 b) public pure returns (int256) {\n        return int(a).min(b);\n    }\n\n    function _max(int256 a, int256 b) public pure returns (int256) {\n        return int(a).max(b);\n    }\n}\n"
    },
    "contracts/ACTUS/test/STK/TestSTKSTF.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../Engines/STK/STKSTF.sol\";\n\n/**\n* These helper contracts expose internal functions for unit testing.\n*/\ncontract TestSTKSTF is STKSTF {\n\n\n    function _STF_STK_AD(\n        STKTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_STK_AD(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_STK_ISS(\n        STKTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_STK_ISS(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_STK_DIF(\n        STKTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_STK_DIF(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_STK_DIP(\n        STKTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_STK_DIP(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_STK_SPF(\n        STKTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_STK_SPF(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_STK_SPS(\n        STKTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_STK_SPS(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_STK_REF(\n        STKTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_STK_REF(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_STK_REP(\n        STKTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_STK_REP(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n}\n"
    },
    "contracts/ACTUS/test/TestCore.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../Core/Core.sol\";\n\n\n/**\n* These helper contracts expose internal functions for unit testing.\n*/\ncontract TestCore is Core {\n\n    function _roleSign(ContractRole contractRole)\n        public\n        pure\n        returns (int8)\n    {\n        return roleSign(contractRole);\n    }\n\n    function _yearFraction(\n        uint256 startTimestamp,\n        uint256 endTimestamp,\n        DayCountConvention ipdc,\n        uint256 maturityDate\n    )\n        public\n        pure\n        returns (int256)\n    {\n        return yearFraction(startTimestamp, endTimestamp, ipdc, maturityDate);\n    }\n\n    function _isInSegment(\n        uint256 timestamp,\n        uint256 startTimestamp,\n        uint256 endTimestamp\n    )\n        public\n        pure\n        returns (bool)\n    {\n        return isInSegment(timestamp, startTimestamp, endTimestamp);\n    }\n\n    function _getTimestampPlusPeriod(IP memory period, uint256 timestamp)\n        public\n        pure\n        returns (uint256)\n    {\n        return getTimestampPlusPeriod(period, timestamp);\n    }\n\n    function _getNextCycleDate(IPS memory cycle, uint256 cycleStart, uint256 cycleIndex)\n        public\n        pure\n        returns (uint256)\n    {\n        return getNextCycleDate(cycle, cycleStart, cycleIndex);\n    }\n\n    function _computeDatesFromCycleSegment(\n        uint256 cycleStart,\n        uint256 cycleEnd,\n        IPS memory cycle,\n        EndOfMonthConvention eomc,\n        bool addEndTime,\n        uint256 segmentStart,\n        uint256 segmentEnd\n    )\n        public\n        pure\n        returns (uint256[MAX_CYCLE_SIZE] memory)\n    {\n        return computeDatesFromCycleSegment(cycleStart, cycleEnd, cycle, eomc, addEndTime, segmentStart, segmentEnd);\n    }\n}\n"
    },
    "contracts/ACTUS/Engines/PAM/PAMPOF.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\n\nimport \"../../Core/Core.sol\";\nimport \"../../Core/SignedMath.sol\";\n\n\n/**\n * @title POF\n * @notice Contains all payoff functions (POFs) currently used by all Engines\n */\ncontract PAMPOF is Core {\n\n    using SignedSafeMath for int;\n    using SignedMath for int;\n\n\n    /**\n     * Calculate the pay-off for PAM Fees. The method how to calculate the fee\n     * heavily depends on the selected Fee Basis.\n     * @return the fee amount for PAM contracts\n     */\n    function POF_PAM_FP (\n        PAMTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        if (terms.feeBasis == FeeBasis.A) {\n            return (\n                roleSign(terms.contractRole)\n                * terms.feeRate\n            );\n        }\n\n        int256 timeFromLastEvent;\n        {\n            timeFromLastEvent = yearFraction(\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                terms.dayCountConvention,\n                terms.maturityDate\n            );\n        }\n\n        return (\n            state.feeAccrued\n            .add(\n                timeFromLastEvent\n                .floatMult(terms.feeRate)\n                .floatMult(state.notionalPrincipal)\n            )\n        );\n    }\n\n    /**\n     * Calculate the payoff for the initial exchange\n     * @return the payoff at iniitial exchange for PAM contracts\n     */\n    function POF_PAM_IED (\n        PAMTerms memory terms,\n        State memory /* state */,\n        uint256 /* scheduleTime */,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        return (\n            roleSign(terms.contractRole)\n            * (-1)\n            * terms.notionalPrincipal\n                .add(terms.premiumDiscountAtIED)\n        );\n    }\n\n    /**\n     * Calculate the interest payment payoff\n     * @return the interest amount to pay for PAM contracts\n     */\n    function POF_PAM_IP (\n        PAMTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        int256 timeFromLastEvent;\n        {\n            timeFromLastEvent = yearFraction(\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                terms.dayCountConvention,\n                terms.maturityDate\n            );\n        }\n\n        return (\n            state.interestScalingMultiplier\n            .floatMult(\n                state.accruedInterest\n                .add(\n                    timeFromLastEvent\n                    .floatMult(state.nominalInterestRate)\n                    .floatMult(state.notionalPrincipal)\n                )\n            )\n        );\n    }\n\n    /**\n     * Calculate the principal prepayment payoff\n     * @return the principal prepayment amount for PAM contracts\n     */\n    function POF_PAM_PP (\n        PAMTerms memory terms,\n        State memory state,\n        uint256 /* scheduleTime */,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        return (\n            roleSign(terms.contractRole)\n            * state.notionalPrincipal\n        );\n    }\n\n    /**\n     * Calculate the payoff in case of maturity\n     * @return the maturity payoff for PAM contracts\n     */\n    function POF_PAM_MD (\n        PAMTerms memory /* terms */,\n        State memory state,\n        uint256 /* scheduleTime */,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        return (\n            state.notionalScalingMultiplier\n                .floatMult(state.notionalPrincipal)\n        );\n    }\n\n    /**\n     * Calculate the payoff in case of termination of a contract\n     * @return the termination payoff amount for PAM contracts\n     */\n    function POF_PAM_TD (\n        PAMTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        int256 timeFromLastEvent;\n        {\n            timeFromLastEvent = yearFraction(\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                terms.dayCountConvention,\n                terms.maturityDate\n            );\n        }\n\n        return (\n            roleSign(terms.contractRole)\n            * terms.priceAtTerminationDate\n            .add(state.accruedInterest)\n            .add(\n                timeFromLastEvent\n                .floatMult(state.nominalInterestRate)\n                .floatMult(state.notionalPrincipal)\n            )\n        );\n    }\n}\n"
    },
    "contracts/ACTUS/test/PAM/TestPAMPOF.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../Engines/PAM/PAMPOF.sol\";\n\n\n/**\n* These helper contracts expose internal functions for unit testing.\n*/\ncontract TestPAMPOF is PAMPOF {\n\n\n    function _POF_PAM_FP(\n        PAMTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (int256)\n    {\n        return POF_PAM_FP(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _POF_PAM_IED(\n        PAMTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (int256)\n    {\n        return POF_PAM_IED(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _POF_PAM_IP(\n        PAMTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (int256)\n    {\n        return POF_PAM_IP(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _POF_PAM_PP(\n        PAMTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (int256)\n    {\n        return POF_PAM_PP(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _POF_PAM_MD(\n        PAMTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (int256)\n    {\n        return POF_PAM_MD(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _POF_PAM_TD(\n        PAMTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (int256)\n    {\n        return POF_PAM_TD(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n}"
    },
    "contracts/ACTUS/Engines/PAM/PAMSTF.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\n\nimport \"../../Core/Core.sol\";\nimport \"../../Core/SignedMath.sol\";\n\n\n/**\n * @title STF\n * @notice Contains all state transition functions (STFs) currently used by all Engines\n */\ncontract PAMSTF is Core {\n\n    using SignedSafeMath for int;\n    using SignedMath for int;\n\n\n    /**\n     * State transition for PAM analysis events\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_NE (\n        PAMTerms memory /* terms */,\n        State memory state,\n        uint256 /* scheduleTime */,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        return state;\n    }\n\n    /**\n     * State transition for PAM analysis events\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_AD (\n        PAMTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent;\n        {\n            timeFromLastEvent = yearFraction(\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                terms.dayCountConvention,\n                terms.maturityDate\n            );\n        }\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM issue events\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_ISS (\n        PAMTerms memory /* terms */,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        state.statusDate = scheduleTime;\n        return state;\n    }\n\n    /**\n     * State transition for PAM fee payment events\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_FP (\n        PAMTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent;\n        {\n            timeFromLastEvent = yearFraction(\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                terms.dayCountConvention,\n                terms.maturityDate\n            );\n        }\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.feeAccrued = 0;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM initial exchange\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_IED (\n        PAMTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        state.notionalPrincipal = roleSign(terms.contractRole) * terms.notionalPrincipal;\n        state.nominalInterestRate = terms.nominalInterestRate;\n        state.statusDate = scheduleTime;\n        state.accruedInterest = terms.accruedInterest;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM interest capitalization\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_IPCI (\n        PAMTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent;\n        {\n            timeFromLastEvent = yearFraction(\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                terms.dayCountConvention,\n                terms.maturityDate\n            );\n        }\n        state.notionalPrincipal = state.notionalPrincipal\n        .add(\n            state.accruedInterest\n            .add(\n                state.nominalInterestRate\n                .floatMult(state.notionalPrincipal)\n                .floatMult(timeFromLastEvent)\n            )\n        );\n        state.accruedInterest = 0;\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM interest payment\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_IP (\n        PAMTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent;\n        {\n            timeFromLastEvent = yearFraction(\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                terms.dayCountConvention,\n                terms.maturityDate\n            );\n        }\n        state.accruedInterest = 0;\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM principal prepayment\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_PP (\n        PAMTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent;\n        {\n            timeFromLastEvent = yearFraction(\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                terms.dayCountConvention,\n                terms.maturityDate\n            );\n        }\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        // state.notionalPrincipal -= 0; // riskFactor not supported\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM principal redemption\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_PR (\n        PAMTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent;\n        {\n            timeFromLastEvent = yearFraction(\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                terms.dayCountConvention,\n                terms.maturityDate\n            );\n        }\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.notionalPrincipal = 0;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM fixed rate resets\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_RRF (\n        PAMTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent;\n        {\n            timeFromLastEvent = yearFraction(\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                terms.dayCountConvention,\n                terms.maturityDate\n            );\n        }\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.nominalInterestRate = terms.nextResetRate;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM variable rate resets\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_RR (\n        PAMTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        // apply external rate, multiply with rateMultiplier and add the spread\n        // riskFactor not supported\n        int256 rate = int256(uint256(externalData)).floatMult(terms.rateMultiplier).add(terms.rateSpread);\n\n        // deltaRate is the difference between the rate that includes external data, spread and multiplier and the currently active rate from the state\n        int256 deltaRate = rate.sub(state.nominalInterestRate);\n\n        // apply period cap/floor\n        // the deltaRate (the interest rate change) cannot be bigger than the period cap\n        // and not smaller than the period floor\n        // math: deltaRate = min(max(deltaRate, periodFloor),lifeCap)\n        deltaRate = deltaRate.max(terms.periodFloor).min(terms.periodCap);\n        rate = state.nominalInterestRate.add(deltaRate);\n\n        // apply life cap/floor\n        // the rate cannot be higher than the lifeCap\n        // and not smaller than the lifeFloor\n        // math: rate = min(max(rate,lifeFloor),lifeCap)\n        rate = rate.max(terms.lifeFloor).min(terms.lifeCap);\n\n        int256 timeFromLastEvent;\n        {\n            timeFromLastEvent = yearFraction(\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                terms.dayCountConvention,\n                terms.maturityDate\n            );\n        }\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.nominalInterestRate = rate;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM scaling index revision events\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_SC (\n        PAMTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent;\n        {\n            timeFromLastEvent = yearFraction(\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                terms.dayCountConvention,\n                terms.maturityDate\n            );\n        }\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n\n        if ((terms.scalingEffect == ScalingEffect.I00) || (terms.scalingEffect == ScalingEffect.IN0)) {\n            state.interestScalingMultiplier = 0; // riskFactor not supported\n        }\n        if ((terms.scalingEffect == ScalingEffect._0N0) || (terms.scalingEffect == ScalingEffect.IN0)) {\n            state.notionalScalingMultiplier = 0; // riskFactor not supported\n        }\n\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM principal redemption\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_MD (\n        PAMTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent;\n        {\n            timeFromLastEvent = yearFraction(\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                terms.dayCountConvention,\n                terms.maturityDate\n            );\n        }\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.notionalPrincipal = 0;\n        state.contractPerformance = ContractPerformance.MD;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM termination events\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_TD (\n        PAMTerms memory /* terms */,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        state.notionalPrincipal = 0;\n        state.accruedInterest = 0;\n        state.feeAccrued = 0;\n        state.contractPerformance = ContractPerformance.TD;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM credit events\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_CE (\n        PAMTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns(State memory)\n    {\n        // handle maturity date\n        uint256 nonPerformingDate = (state.nonPerformingDate == 0)\n            ? shiftEventTime(\n                scheduleTime,\n                terms.businessDayConvention,\n                terms.calendar,\n                terms.maturityDate\n            ) : state.nonPerformingDate;\n\n        uint256 currentTimestamp = uint256(externalData);\n\n        bool isInGracePeriod = false;\n        if (terms.gracePeriod.isSet) {\n            uint256 graceDate = getTimestampPlusPeriod(terms.gracePeriod, nonPerformingDate);\n            if (currentTimestamp <= graceDate) {\n                state.contractPerformance = ContractPerformance.DL;\n                isInGracePeriod = true;\n            }\n        }\n\n        if (terms.delinquencyPeriod.isSet && !isInGracePeriod) {\n            uint256 delinquencyDate = getTimestampPlusPeriod(terms.delinquencyPeriod, nonPerformingDate);\n            if (currentTimestamp <= delinquencyDate) {\n                state.contractPerformance = ContractPerformance.DQ;\n            } else {\n                state.contractPerformance = ContractPerformance.DF;\n            }\n        }\n\n        if (state.nonPerformingDate == 0) {\n            // handle maturity date\n            state.nonPerformingDate = shiftEventTime(\n                scheduleTime,\n                terms.businessDayConvention,\n                terms.calendar,\n                terms.maturityDate\n            );\n        }\n\n        return state;\n    }\n}\n"
    },
    "contracts/ACTUS/test/PAM/TestPAMSTF.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../Engines/PAM/PAMSTF.sol\";\n\n/**\n* These helper contracts expose internal functions for unit testing.\n*/\ncontract TestPAMSTF is PAMSTF {\n\n\n    function _STF_PAM_NE(\n        PAMTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_PAM_NE(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_PAM_AD(\n        PAMTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_PAM_AD(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_PAM_FP(\n        PAMTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_PAM_FP(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_PAM_IED(\n        PAMTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_PAM_IED(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_PAM_IPCI(\n        PAMTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_PAM_IPCI(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_PAM_IP(\n        PAMTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_PAM_IP(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_PAM_PP(\n        PAMTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_PAM_PP(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_PAM_PR(\n        PAMTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_PAM_PR(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_PAM_RRF(\n        PAMTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_PAM_RRF(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_PAM_RR(\n        PAMTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_PAM_RR(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_PAM_SC(\n        PAMTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_PAM_SC(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_PAM_MD(\n        PAMTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_PAM_MD(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_PAM_TD(\n        PAMTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_PAM_TD(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_PAM_CE(\n        PAMTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_PAM_CE(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n}"
    },
    "contracts/ACTUS/Engines/PAM/PAMEngine.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\n\nimport \"../../Core/Core.sol\";\nimport \"../../Core/SignedMath.sol\";\nimport \"./IPAMEngine.sol\";\nimport \"./PAMSTF.sol\";\nimport \"./PAMPOF.sol\";\n\n\n/**\n * @title PAMEngine\n * @notice Inherits from BaseEngine by implementing STFs, POFs according to the ACTUS standard for a PAM contract\n * @dev All numbers except unix timestamp are represented as multiple of 10 ** 18\n */\ncontract PAMEngine is Core, PAMSTF, PAMPOF, IPAMEngine {\n\n    using SignedSafeMath for int;\n    using SignedMath for int;\n\n\n    function contractType() external pure override returns (ContractType) {\n        return ContractType.PAM;\n    }\n\n    /**\n     * Applys an event to the current state of a contract and returns the resulting contract state.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event to be applied to the contract state\n     * @param externalData external data needed for STF evaluation (e.g. rate for RR events)\n     * @return the resulting contract state\n     */\n    function computeStateForEvent(\n        PAMTerms calldata terms,\n        State calldata state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        external\n        pure\n        override\n        returns (State memory)\n    {\n        return stateTransitionFunction(\n            terms,\n            state,\n            _event,\n            externalData\n        );\n    }\n\n    /**\n     * Evaluates the payoff for an event under the current state of the contract.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which the payoff should be evaluated\n     * @param externalData external data needed for POF evaluation (e.g. fxRate)\n     * @return the payoff of the event\n     */\n    function computePayoffForEvent(\n        PAMTerms calldata terms,\n        State calldata state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        external\n        pure\n        override\n        returns (int256)\n    {\n        // if alternative settlementCurrency is set then apply fxRate to payoff\n        if (terms.settlementCurrency != address(0) && terms.currency != terms.settlementCurrency) {\n            return payoffFunction(\n                terms,\n                state,\n                _event,\n                externalData\n            ).floatMult(int256(externalData));\n        }\n\n        return payoffFunction(\n            terms,\n            state,\n            _event,\n            externalData\n        );\n    }\n\n    /**\n     * @notice Initialize contract state space based on the contract terms.\n     * @param terms terms of the contract\n     * @return the initial state of the contract\n     */\n    function computeInitialState(PAMTerms calldata terms)\n        external\n        pure\n        override\n        returns (State memory)\n    {\n        State memory state;\n\n        state.contractPerformance = ContractPerformance.PF;\n        state.notionalScalingMultiplier = ONE_POINT_ZERO;\n        state.interestScalingMultiplier = ONE_POINT_ZERO;\n        state.statusDate = terms.statusDate;\n        state.maturityDate = terms.maturityDate;\n        state.notionalPrincipal = terms.notionalPrincipal;\n        state.nominalInterestRate = terms.nominalInterestRate;\n        state.accruedInterest = terms.accruedInterest;\n        state.feeAccrued = terms.feeAccrued;\n\n        return state;\n    }\n\n    /**\n     * @notice Computes a schedule segment of non-cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @return segment of the non-cyclic schedule\n     */\n    function computeNonCyclicScheduleSegment(\n        PAMTerms calldata terms,\n        uint256 segmentStart,\n        uint256 segmentEnd\n    )\n        external\n        pure\n        override\n        returns (bytes32[] memory)\n    {\n        bytes32[MAX_EVENT_SCHEDULE_SIZE] memory events;\n        uint16 index;\n\n        // issuance\n        if (terms.issueDate != 0) {\n            if (isInSegment(terms.issueDate, segmentStart, segmentEnd)) {\n                events[index] = encodeEvent(EventType.ISS, terms.issueDate);\n                index++;\n            }\n        }\n\n        // initial exchange\n        if (terms.initialExchangeDate != 0) {\n            if (terms.purchaseDate == 0 && isInSegment(terms.initialExchangeDate, segmentStart, segmentEnd)) {\n                events[index] = encodeEvent(EventType.IED, terms.initialExchangeDate);\n                index++;\n            }\n        }\n\n        // purchase\n        if (terms.purchaseDate != 0) {\n            if (isInSegment(terms.purchaseDate, segmentStart, segmentEnd)) {\n                events[index] = encodeEvent(EventType.PRD, terms.purchaseDate);\n                index++;\n            }\n        }\n\n        // principal redemption\n        if (terms.maturityDate != 0) {\n            if (isInSegment(terms.maturityDate, segmentStart, segmentEnd)) {\n                events[index] = encodeEvent(EventType.MD, terms.maturityDate);\n                index++;\n            }\n        }\n\n        // remove null entries from returned array\n        bytes32[] memory schedule = new bytes32[](index);\n        for (uint256 i = 0; i < index; i++) {\n            schedule[i] = events[i];\n        }\n\n        return schedule;\n    }\n\n    /**\n     * @notice Computes a schedule segment of cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @param eventType eventType of the cyclic schedule\n     * @return event schedule segment\n     */\n    function computeCyclicScheduleSegment(\n        PAMTerms calldata terms,\n        uint256 segmentStart,\n        uint256 segmentEnd,\n        EventType eventType\n    )\n        external\n        pure\n        override\n        returns(bytes32[] memory)\n    {\n        bytes32[MAX_EVENT_SCHEDULE_SIZE] memory events;\n        uint256 index;\n\n        // IP\n        // interest payment related (starting with PRANX interest is paid following the PR schedule)\n        if (eventType == EventType.IP) {\n            if (terms.cycleAnchorDateOfInterestPayment != 0) {\n                uint256[MAX_CYCLE_SIZE] memory interestPaymentSchedule = computeDatesFromCycleSegment(\n                    terms.cycleAnchorDateOfInterestPayment,\n                    terms.maturityDate,\n                    terms.cycleOfInterestPayment,\n                    terms.endOfMonthConvention,\n                    true,\n                    segmentStart,\n                    segmentEnd\n                );\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\n                    if (interestPaymentSchedule[i] == 0) break;\n                    if (interestPaymentSchedule[i] <= terms.capitalizationEndDate) continue;\n                    if (isInSegment(interestPaymentSchedule[i], segmentStart, segmentEnd) == false) continue;\n                    events[index] = encodeEvent(EventType.IP, interestPaymentSchedule[i]);\n                    index++;\n                }\n            }\n        }\n\n        // IPCI\n        if (eventType == EventType.IPCI) {\n            if (terms.cycleAnchorDateOfInterestPayment != 0 && terms.capitalizationEndDate != 0) {\n                IPS memory cycleOfInterestCapitalization = terms.cycleOfInterestPayment;\n                cycleOfInterestCapitalization.s = S.SHORT;\n                uint256[MAX_CYCLE_SIZE] memory interestPaymentSchedule = computeDatesFromCycleSegment(\n                    terms.cycleAnchorDateOfInterestPayment,\n                    terms.capitalizationEndDate,\n                    cycleOfInterestCapitalization,\n                    terms.endOfMonthConvention,\n                    true,\n                    segmentStart,\n                    segmentEnd\n                );\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\n                    if (interestPaymentSchedule[i] == 0) break;\n                    if (isInSegment(interestPaymentSchedule[i], segmentStart, segmentEnd) == false) continue;\n                    events[index] = encodeEvent(EventType.IPCI, interestPaymentSchedule[i]);\n                    index++;\n                }\n            }\n        }\n\n        // rate reset\n        if (eventType == EventType.RR) {\n            if (terms.cycleAnchorDateOfRateReset != 0) {\n                uint256[MAX_CYCLE_SIZE] memory rateResetSchedule = computeDatesFromCycleSegment(\n                    terms.cycleAnchorDateOfRateReset,\n                    terms.maturityDate,\n                    terms.cycleOfRateReset,\n                    terms.endOfMonthConvention,\n                    false,\n                    segmentStart,\n                    segmentEnd\n                );\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\n                    if (rateResetSchedule[i] == 0) break;\n                    if (isInSegment(rateResetSchedule[i], segmentStart, segmentEnd) == false) continue;\n                    events[index] = encodeEvent(EventType.RR, rateResetSchedule[i]);\n                    index++;\n                }\n            }\n            // ... nextRateReset\n        }\n\n        // fees\n        if (eventType == EventType.FP) {\n            if (terms.cycleAnchorDateOfFee != 0) {\n                uint256[MAX_CYCLE_SIZE] memory feeSchedule = computeDatesFromCycleSegment(\n                    terms.cycleAnchorDateOfFee,\n                    terms.maturityDate,\n                    terms.cycleOfFee,\n                    terms.endOfMonthConvention,\n                    true,\n                    segmentStart,\n                    segmentEnd\n                );\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\n                    if (feeSchedule[i] == 0) break;\n                    if (isInSegment(feeSchedule[i], segmentStart, segmentEnd) == false) continue;\n                    events[index] = encodeEvent(EventType.FP, feeSchedule[i]);\n                    index++;\n                }\n            }\n        }\n\n        // scaling\n        if (eventType == EventType.SC) {\n            if ((terms.scalingEffect != ScalingEffect._000) && terms.cycleAnchorDateOfScalingIndex != 0) {\n                uint256[MAX_CYCLE_SIZE] memory scalingSchedule = computeDatesFromCycleSegment(\n                    terms.cycleAnchorDateOfScalingIndex,\n                    terms.maturityDate,\n                    terms.cycleOfScalingIndex,\n                    terms.endOfMonthConvention,\n                    true,\n                    segmentStart,\n                    segmentEnd\n                );\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\n                    if (scalingSchedule[i] == 0) break;\n                    if (isInSegment(scalingSchedule[i], segmentStart, segmentEnd) == false) continue;\n                    events[index] = encodeEvent(EventType.SC, scalingSchedule[i]);\n                    index++;\n                }\n            }\n        }\n\n        // remove null entries from returned array\n        bytes32[] memory schedule = new bytes32[](index);\n        for (uint256 i = 0; i < index; i++) {\n            schedule[i] = events[i];\n        }\n\n        return schedule;\n    }\n\n    /**\n     * @notice Computes the next non-cyclic contract events based on the contract terms\n     * and the timestamp on which the prev. event occured.\n     * @dev Assumes that non-cyclic events of the same event type have a unique schedule time\n     * @param terms terms of the contract\n     * @param lastNonCyclicEvent last non-cyclic event\n     * @return next non-cyclic event\n     */\n    function computeNextNonCyclicEvent(\n        PAMTerms calldata terms,\n        bytes32 lastNonCyclicEvent\n    )\n        external\n        pure\n        override\n        returns (bytes32)\n    {\n        (EventType lastEventType, uint256 lastScheduleTime) = decodeEvent(lastNonCyclicEvent);\n\n        EventType eventTypeNextEvent;\n        uint256 scheduleTimeNextEvent;\n\n        // EventTypes ordered after epoch offset - so we don't have make an additional epochOffset check\n\n        // issuance\n        if (\n            // date for event has to be set in terms and date of event can be in the past\n            (terms.issueDate != 0 && (lastScheduleTime <= terms.issueDate))\n            // date for event has to come before previous candidate for the next event\n            && (scheduleTimeNextEvent == 0 || terms.issueDate < scheduleTimeNextEvent)\n            // avoid endless loop by requiring that the event is not the lastNonCyclicEvent\n            && (lastScheduleTime != terms.issueDate || lastEventType != EventType.ISS)\n        ) {\n            eventTypeNextEvent = EventType.ISS;\n            scheduleTimeNextEvent = terms.issueDate;\n        }\n        \n        // initial exchange\n        if (\n            // date for event has to be set in terms and date of event can be in the past\n            (terms.initialExchangeDate != 0 && (lastScheduleTime <= terms.initialExchangeDate))\n            && (scheduleTimeNextEvent == 0 || terms.initialExchangeDate < scheduleTimeNextEvent)\n            && (lastScheduleTime != terms.initialExchangeDate || lastEventType != EventType.IED)\n        ) {\n            eventTypeNextEvent = EventType.IED;\n            scheduleTimeNextEvent = terms.initialExchangeDate;\n        }\n\n        // purchase\n        if (\n            (terms.purchaseDate != 0 && (lastScheduleTime <= terms.purchaseDate))\n            && (scheduleTimeNextEvent == 0 || terms.purchaseDate < scheduleTimeNextEvent)\n            && (lastScheduleTime != terms.purchaseDate || lastEventType != EventType.PRD)\n        ) {\n            eventTypeNextEvent = EventType.PRD;\n            scheduleTimeNextEvent = terms.purchaseDate;\n        }\n\n        // principal redemption at maturity\n        if (\n            (terms.maturityDate != 0 && (lastScheduleTime <= terms.maturityDate))\n            && (scheduleTimeNextEvent == 0 || terms.maturityDate < scheduleTimeNextEvent)\n            && (lastScheduleTime != terms.maturityDate || lastEventType != EventType.MD)\n        ) {\n            eventTypeNextEvent = EventType.MD;\n            scheduleTimeNextEvent = terms.maturityDate;\n        }\n\n        return encodeEvent(eventTypeNextEvent, scheduleTimeNextEvent);\n    }\n\n    /**\n     * @notice Computes a schedule segment of cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param lastScheduleTime last occurrence of cyclic event\n     * @param eventType eventType of the cyclic schedule\n     * @return event schedule segment\n     */\n    function computeNextCyclicEvent(\n        PAMTerms calldata terms,\n        uint256 lastScheduleTime,\n        EventType eventType\n    )\n        external\n        pure\n        override\n        returns(bytes32)\n    {\n        // IP\n        // interest payment related (starting with PRANX interest is paid following the PR schedule)\n        if (eventType == EventType.IP) {\n            if (terms.cycleOfInterestPayment.isSet == true && terms.cycleAnchorDateOfInterestPayment != 0) {\n                uint256 nextInterestPaymentDate = computeNextCycleDateFromPrecedingDate(\n                    terms.cycleOfInterestPayment,\n                    terms.endOfMonthConvention,\n                    terms.cycleAnchorDateOfInterestPayment,\n                    lastScheduleTime,\n                    true,\n                    terms.maturityDate\n                );\n                if (nextInterestPaymentDate == 0) return bytes32(0);\n                if (nextInterestPaymentDate <= terms.capitalizationEndDate) return bytes32(0);\n                return encodeEvent(EventType.IP, nextInterestPaymentDate);\n            }\n        }\n\n        // IPCI\n        if (eventType == EventType.IPCI) {\n            if (terms.cycleAnchorDateOfInterestPayment != 0 && terms.capitalizationEndDate != 0) {\n                IPS memory cycleOfInterestCapitalization = terms.cycleOfInterestPayment;\n                cycleOfInterestCapitalization.s = S.SHORT;\n                uint256 nextInterestCapitalizationDate = computeNextCycleDateFromPrecedingDate(\n                    cycleOfInterestCapitalization,\n                    terms.endOfMonthConvention,\n                    terms.cycleAnchorDateOfInterestPayment,\n                    lastScheduleTime,\n                    true,\n                    terms.maturityDate\n                );\n                if (nextInterestCapitalizationDate == 0) return bytes32(0);\n                return encodeEvent(EventType.IPCI, nextInterestCapitalizationDate);\n            }\n        }\n\n        // rate reset\n        if (eventType == EventType.RR) {\n            if (terms.cycleAnchorDateOfRateReset != 0) {\n                uint256 nextRateResetDate = computeNextCycleDateFromPrecedingDate(\n                    terms.cycleOfRateReset,\n                    terms.endOfMonthConvention,\n                    terms.cycleAnchorDateOfRateReset,\n                    lastScheduleTime,\n                    true,\n                    terms.maturityDate\n                );\n                if (nextRateResetDate == 0) return bytes32(0);\n                return encodeEvent(EventType.RR, nextRateResetDate);\n            }\n            // ... nextRateReset\n        }\n\n        // fees\n        if (eventType == EventType.FP) {\n            if (terms.cycleAnchorDateOfFee != 0) {\n                uint256 nextFeeDate = computeNextCycleDateFromPrecedingDate(\n                    terms.cycleOfFee,\n                    terms.endOfMonthConvention,\n                    terms.cycleAnchorDateOfFee,\n                    lastScheduleTime,\n                    true,\n                    terms.maturityDate\n                );\n                if (nextFeeDate == 0) return bytes32(0);\n                return encodeEvent(EventType.FP, nextFeeDate);\n            }\n        }\n\n        // scaling\n        if (eventType == EventType.SC) {\n            if ((terms.scalingEffect != ScalingEffect._000) && terms.cycleAnchorDateOfScalingIndex != 0) {\n                uint256 nextScalingDate = computeNextCycleDateFromPrecedingDate(\n                    terms.cycleOfScalingIndex,\n                    terms.endOfMonthConvention,\n                    terms.cycleAnchorDateOfScalingIndex,\n                    lastScheduleTime,\n                    true,\n                    terms.maturityDate\n                );\n                if (nextScalingDate == 0) return bytes32(0);\n                return encodeEvent(EventType.SC, nextScalingDate);\n            }\n        }\n\n        return bytes32(0);\n    }\n\n    /**\n     * @notice Verifies that the provided event is still scheduled under the terms, the current state of the\n     * contract and the current state of the underlying.\n     * param _event event for which to check if its still scheduled\n     * param terms terms of the contract\n     * param state current state of the contract\n     * param hasUnderlying boolean indicating whether the contract has an underlying contract\n     * param underlyingState state of the underlying (empty state object if non-existing)\n     * @return boolean indicating whether event is still scheduled\n     */\n    function isEventScheduled(\n        bytes32 /* _event */,\n        PAMTerms calldata /* terms */,\n        State calldata /* state */,\n        bool /* hasUnderlying */,\n        State calldata /* underlyingState */\n    )\n        external\n        pure\n        override\n        returns (bool)\n    {\n        return true;\n    }\n\n    /**\n     * @notice Implements abstract method which is defined in BaseEngine.\n     * Applies an event to the current state of the contract and returns the resulting state.\n     * The inheriting Engine contract has to map the events type to the designated STF.\n     * todo Annuity calculator for RR/RRF events, IPCB events and ICB state variable\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which to evaluate the next state for\n     * @param externalData external data needed for STF evaluation (e.g. rate for RR events)\n     * @return the resulting contract state\n     */\n    function stateTransitionFunction(\n        PAMTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n\n        /*\n         * Note:\n         * Not supported: PRD (Purchase) events\n         */\n\n        if (eventType == EventType.AD) return STF_PAM_AD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.ISS) return STF_PAM_ISS(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.IED) return STF_PAM_IED(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.IPCI) return STF_PAM_IPCI(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.IP) return STF_PAM_IP(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.FP) return STF_PAM_FP(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.PP) return STF_PAM_PP(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.MD) return STF_PAM_MD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.RRF) return STF_PAM_RRF(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.RR) return STF_PAM_RR(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.SC) return STF_PAM_SC(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.TD) return STF_PAM_TD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.CE)  return STF_PAM_CE(terms, state, scheduleTime, externalData);\n\n        revert(\"PAMEngine.stateTransitionFunction: ATTRIBUTE_NOT_FOUND\");\n    }\n\n    /**\n     * @notice Implements abstract method which is defined in BaseEngine.\n     * Computes the payoff for an event under the current state of the contract.\n     * The inheriting Engine contract has to map the events type to the designated POF.\n     * todo IPCB events and Icb state variable, Icb state variable updates in IP-paying events\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which the payoff should be evaluated\n     * @param externalData external data needed for POF evaluation (e.g. fxRate)\n     * @return the payoff of the event\n     */\n    function payoffFunction(\n        PAMTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (int256)\n    {\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n\n        /*\n         * Note: PAM contracts don't have IPCB and PR events.\n         * Not supported: PRD (Purchase) events\n         */\n\n        if (eventType == EventType.AD) return 0;\n        if (eventType == EventType.ISS) return 0;\n        if (eventType == EventType.IPCI) return 0;\n        if (eventType == EventType.RRF) return 0;\n        if (eventType == EventType.RR) return 0;\n        if (eventType == EventType.SC) return 0;\n        if (eventType == EventType.CE) return 0;\n        if (eventType == EventType.FP) return POF_PAM_FP(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.IED) return POF_PAM_IED(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.IP) return POF_PAM_IP(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.PP) return POF_PAM_PP(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.MD) return POF_PAM_MD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.TD) return POF_PAM_TD(terms, state, scheduleTime, externalData);\n\n        revert(\"PAMEngine.payoffFunction: ATTRIBUTE_NOT_FOUND\");\n    }\n}\n"
    },
    "contracts/Core/CERTF/CERTFActor.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../ACTUS/Engines/CERTF/ICERTFEngine.sol\";\n\nimport \"../Base/AssetActor/BaseActor.sol\";\nimport \"./ICERTFRegistry.sol\";\n\n\n/**\n * @title CERTFActor\n * @notice TODO\n */\ncontract CERTFActor is BaseActor {\n\n    using SignedMath for int;\n\n\n    constructor(IAssetRegistry assetRegistry, IOracleProxy defaultOracleProxy) BaseActor(assetRegistry, defaultOracleProxy) {}\n\n    /**\n     * @notice Derives initial state of the asset terms and stores together with\n     * terms, schedule, ownership, engine, admin of the asset in the contract types specific AssetRegistry.\n     * @param terms asset specific terms\n     * @param schedule schedule of the asset\n     * @param ownership ownership of the asset\n     * @param engine address of the ACTUS engine used for the spec. ContractType\n     * @param admin address of the admin of the asset (optional)\n     */\n    function initialize(\n        CERTFTerms calldata terms,\n        bytes32[] calldata schedule,\n        AssetOwnership calldata ownership,\n        address engine,\n        address admin\n    )\n        external\n    {\n        require(\n            engine != address(0) && IEngine(engine).contractType() == ContractType.CERTF,\n            \"CERTFActor.initialize: CONTRACT_TYPE_OF_ENGINE_UNSUPPORTED\"\n        );\n\n        // solium-disable-next-line\n        bytes32 assetId = keccak256(abi.encode(terms, block.timestamp));\n\n        // compute the initial state of the asset\n        State memory initialState = ICERTFEngine(engine).computeInitialState(terms);\n\n        // register the asset in the AssetRegistry\n        ICERTFRegistry(address(assetRegistry)).registerAsset(\n            assetId,\n            terms,\n            initialState,\n            schedule,\n            ownership,\n            engine,\n            address(this),\n            admin\n        );\n\n        emit InitializedAsset(assetId, ContractType.CEG, ownership.creatorObligor, ownership.counterpartyObligor);\n    }\n\n    function computeStateAndPayoffForEvent(bytes32 assetId, State memory state, bytes32 _event)\n        internal\n        view\n        override\n        returns (State memory, int256)\n    {\n        address engine = assetRegistry.getEngine(assetId);\n        CERTFTerms memory terms = ICERTFRegistry(address(assetRegistry)).getTerms(assetId);\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n\n        int256 payoff = ICERTFEngine(engine).computePayoffForEvent(\n            terms,\n            state,\n            _event,\n            getExternalDataForPOF(\n                assetId,\n                eventType,\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate)\n            )\n        );\n        state = ICERTFEngine(engine).computeStateForEvent(\n            terms,\n            state,\n            _event,\n            getExternalDataForSTF(\n                assetId,\n                eventType,\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate)\n            )\n        );\n\n        return (state, payoff);\n    }\n\n    /**\n     * @notice Retrieves external data (such as market object data, block time, underlying asset state)\n     * used for evaluating the STF for a given event.\n     */\n    function getExternalDataForSTF(\n        bytes32 assetId,\n        EventType eventType,\n        uint256 timestamp\n    )\n        internal\n        view\n        override\n        returns (bytes32)\n    {\n        if (eventType == EventType.CE) {\n            // get current timestamp\n            // solium-disable-next-line\n            return bytes32(block.timestamp);\n        } else if (eventType == EventType.EXE) {\n            // get quantity\n            ContractReference memory contractReference_2 = assetRegistry.getContractReferenceValueForTermsAttribute(\n                assetId,\n                \"contractReference_2\"\n            );\n            if (\n                contractReference_2._type == ContractReferenceType.MOC\n                && contractReference_2.role == ContractReferenceRole.UDL\n            ) {\n                (int256 quantity, bool isSet) = defaultOracleProxy.getDataPoint(\n                    contractReference_2.object,\n                    timestamp\n                );\n                if (isSet) return bytes32(quantity);\n            }\n        } else if (eventType == EventType.REF) {\n            ContractReference memory contractReference_1 = assetRegistry.getContractReferenceValueForTermsAttribute(\n                assetId,\n                \"contractReference_1\"\n            );\n            if (\n                contractReference_1._type == ContractReferenceType.MOC\n                && contractReference_1.role == ContractReferenceRole.UDL\n            ) {\n                (int256 marketValueScheduleTime, bool isSetScheduleTime) = defaultOracleProxy.getDataPoint(\n                    contractReference_1.object,\n                    timestamp\n                );\n                (int256 marketValueAnchorDate, bool isSetAnchorDate) = defaultOracleProxy.getDataPoint(\n                    contractReference_1.object,\n                    assetRegistry.getUIntValueForTermsAttribute(assetId, \"issueDate\")\n                );\n                if (isSetScheduleTime && isSetAnchorDate) {\n                    return bytes32(marketValueScheduleTime.floatDiv(marketValueAnchorDate));\n                }\n            }\n            return bytes32(0);\n        }\n\n        return bytes32(0);\n    }\n}"
    },
    "contracts/ACTUS/Engines/CERTF/CERTFEngine.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.4;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\n\nimport \"../../Core/Core.sol\";\nimport \"../../Core/SignedMath.sol\";\nimport \"./ICERTFEngine.sol\";\nimport \"./CERTFSTF.sol\";\nimport \"./CERTFPOF.sol\";\n\n\n/**\n * @title CERTFEngine\n * @notice Inherits from BaseEngine by implementing STFs, POFs according to the ACTUS standard for a CERTF contract\n * @dev All numbers except unix timestamp are represented as multiple of 10 ** 18\n */\ncontract CERTFEngine is Core, CERTFSTF, CERTFPOF, ICERTFEngine {\n\n    using SignedSafeMath for int;\n    using SignedMath for int;\n\n\n    function contractType() external pure override returns (ContractType) {\n        return ContractType.CERTF;\n    }\n\n    /**\n     * Applys an event to the current state of a contract and returns the resulting contract state.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event to be applied to the contract state\n     * @param externalData external data needed for STF evaluation (e.g. rate for RR events)\n     * @return the resulting contract state\n     */\n    function computeStateForEvent(\n        CERTFTerms calldata terms,\n        State calldata state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        external\n        pure\n        override\n        returns (State memory)\n    {\n        return stateTransitionFunction(\n            terms,\n            state,\n            _event,\n            externalData\n        );\n    }\n\n    /**\n     * Evaluates the payoff for an event under the current state of the contract.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which the payoff should be evaluated\n     * @param externalData external data needed for POF evaluation (e.g. fxRate)\n     * @return the payoff of the event\n     */\n    function computePayoffForEvent(\n        CERTFTerms calldata terms,\n        State calldata state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        external\n        pure\n        override\n        returns (int256)\n    {\n        // if alternative settlementCurrency is set then apply fxRate to payoff\n        if (terms.settlementCurrency != address(0) && terms.currency != terms.settlementCurrency) {\n            return payoffFunction(\n                terms,\n                state,\n                _event,\n                externalData\n            ).floatMult(int256(externalData));\n        }\n\n        return payoffFunction(\n            terms,\n            state,\n            _event,\n            externalData\n        );\n    }\n\n    /**\n     * @notice Initialize contract state space based on the contract terms.\n     * @param terms terms of the contract\n     * @return the initial state of the contract\n     */\n    function computeInitialState(CERTFTerms calldata terms)\n        external\n        pure\n        override\n        returns (State memory)\n    {\n        State memory state;\n\n        state.quantity = 0;\n        state.exerciseQuantity = 0;\n        state.marginFactor = ONE_POINT_ZERO;\n        state.adjustmentFactor = ONE_POINT_ZERO;\n        state.lastCouponFixingDate = terms.issueDate;\n        state.couponAmountFixed = 0;\n\n        state.contractPerformance = ContractPerformance.PF;\n        state.statusDate = terms.statusDate;\n\n        return state;\n    }\n\n    /**\n     * @notice Computes a schedule segment of non-cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @return segment of the non-cyclic schedule\n     */\n    function computeNonCyclicScheduleSegment(\n        CERTFTerms calldata terms,\n        uint256 segmentStart,\n        uint256 segmentEnd\n    )\n        external\n        pure\n        override\n        returns (bytes32[] memory)\n    {\n        bytes32[MAX_EVENT_SCHEDULE_SIZE] memory events;\n        uint16 index;\n\n        // issue date\n        if (terms.issueDate != 0) {\n            if (isInSegment(terms.issueDate, segmentStart, segmentEnd)) {\n                events[index] = encodeEvent(EventType.ISS, terms.issueDate);\n                index++;\n            }\n        }\n\n        // initial exchange\n        if (terms.initialExchangeDate != 0) {\n            if (isInSegment(terms.initialExchangeDate, segmentStart, segmentEnd)) {\n                events[index] = encodeEvent(EventType.IED, terms.initialExchangeDate);\n                index++;\n            }\n        }\n\n        // maturity event\n        if (terms.maturityDate != 0) {\n            if (isInSegment(terms.maturityDate, segmentStart, segmentEnd) == true) {\n                events[index] = encodeEvent(EventType.MD, terms.maturityDate);\n                index++;\n            }\n        }\n\n        // remove null entries from returned array\n        bytes32[] memory schedule = new bytes32[](index);\n        for (uint256 i = 0; i < index; i++) {\n            schedule[i] = events[i];\n        }\n\n        return schedule;\n    }\n\n    /**\n     * @notice Computes a schedule segment of cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @param eventType eventType of the cyclic schedule\n     * @return event schedule segment\n     */\n    function computeCyclicScheduleSegment(\n        CERTFTerms calldata terms,\n        uint256 segmentStart,\n        uint256 segmentEnd,\n        EventType eventType\n    )\n        external\n        pure\n        override\n        returns(bytes32[] memory)\n    {\n        bytes32[MAX_EVENT_SCHEDULE_SIZE] memory events;\n        uint256 index;\n\n        if (eventType == EventType.COF) {\n            if (terms.cycleAnchorDateOfCoupon != 0) {\n                uint256[MAX_CYCLE_SIZE] memory couponSchedule = computeDatesFromCycleSegment(\n                    terms.cycleAnchorDateOfCoupon,\n                    (terms.maturityDate > 0) ? terms.maturityDate : segmentEnd,\n                    terms.cycleOfCoupon,\n                    terms.endOfMonthConvention,\n                    (terms.maturityDate > 0) ? true : false,\n                    segmentStart,\n                    segmentEnd\n                );\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\n                    if (couponSchedule[i] == 0) break;\n                    if (isInSegment(couponSchedule[i], segmentStart, segmentEnd) == false) continue;\n                    events[index] = encodeEvent(EventType.COF, couponSchedule[i]);\n                    index++;\n                }\n            }\n        }\n\n         if (eventType == EventType.COP) {\n            if (terms.cycleAnchorDateOfCoupon != 0) {\n                uint256[MAX_CYCLE_SIZE] memory couponSchedule = computeDatesFromCycleSegment(\n                    terms.cycleAnchorDateOfCoupon,\n                    (terms.maturityDate > 0) ? terms.maturityDate : segmentEnd,\n                    terms.cycleOfCoupon,\n                    terms.endOfMonthConvention,\n                    (terms.maturityDate > 0) ? true : false,\n                    segmentStart,\n                    segmentEnd\n                );\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\n                    if (couponSchedule[i] == 0) break;\n                    uint256 couponPaymentDayScheduleTime = getTimestampPlusPeriod(terms.settlementPeriod, couponSchedule[i]);\n                    if (isInSegment(couponPaymentDayScheduleTime, segmentStart, segmentEnd) == false) continue;\n                    events[index] = encodeEvent(EventType.COF, couponPaymentDayScheduleTime);\n                    index++;\n                }\n            }\n        }\n\n        if (eventType == EventType.REF) {\n            if (terms.cycleAnchorDateOfRedemption != 0) {\n                uint256[MAX_CYCLE_SIZE] memory redemptionSchedule = computeDatesFromCycleSegment(\n                    terms.cycleAnchorDateOfRedemption,\n                    (terms.maturityDate > 0) ? terms.maturityDate : segmentEnd,\n                    terms.cycleOfRedemption,\n                    terms.endOfMonthConvention,\n                    (terms.maturityDate > 0) ? true : false,\n                    segmentStart,\n                    segmentEnd\n                );\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\n                    if (redemptionSchedule[i] == 0) break;\n                    if (isInSegment(redemptionSchedule[i], segmentStart, segmentEnd) == false) continue;\n                    events[index] = encodeEvent(EventType.REF, redemptionSchedule[i]);\n                    index++;\n                }\n            }\n        }\n\n        if (eventType == EventType.REP) {\n            if (terms.cycleAnchorDateOfRedemption != 0) {\n                uint256[MAX_CYCLE_SIZE] memory redemptionSchedule = computeDatesFromCycleSegment(\n                    terms.cycleAnchorDateOfRedemption,\n                    (terms.maturityDate > 0) ? terms.maturityDate : segmentEnd,\n                    terms.cycleOfRedemption,\n                    terms.endOfMonthConvention,\n                    (terms.maturityDate > 0) ? true : false,\n                    segmentStart,\n                    segmentEnd\n                );\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\n                    if (redemptionSchedule[i] == 0) break;\n                    uint256 redemptionPaymentDayScheduleTime = getTimestampPlusPeriod(terms.settlementPeriod, redemptionSchedule[i]);\n                    if (isInSegment(redemptionPaymentDayScheduleTime, segmentStart, segmentEnd) == false) continue;\n                    events[index] = encodeEvent(EventType.REP, redemptionPaymentDayScheduleTime);\n                    index++;\n                }\n            }\n        }\n\n        if (eventType == EventType.EXE) {\n            if (terms.cycleAnchorDateOfRedemption != 0) {\n                uint256[MAX_CYCLE_SIZE] memory redemptionSchedule = computeDatesFromCycleSegment(\n                    terms.cycleAnchorDateOfRedemption,\n                    (terms.maturityDate > 0) ? terms.maturityDate : segmentEnd,\n                    terms.cycleOfRedemption,\n                    terms.endOfMonthConvention,\n                    (terms.maturityDate > 0) ? true : false,\n                    segmentStart,\n                    segmentEnd\n                );\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\n                    if (redemptionSchedule[i] == 0) break;\n                    if (redemptionSchedule[i] == terms.maturityDate) continue;\n                    uint256 executionDateScheduleTime = getTimestampPlusPeriod(terms.redemptionRecordPeriod, redemptionSchedule[i]);\n                    if (isInSegment(executionDateScheduleTime, segmentStart, segmentEnd) == false) continue;\n                    events[index] = encodeEvent(EventType.EXE, executionDateScheduleTime);\n                    index++;\n                }\n            }\n        }\n\n        // remove null entries from returned array\n        bytes32[] memory schedule = new bytes32[](index);\n        for (uint256 i = 0; i < index; i++) {\n            schedule[i] = events[i];\n        }\n\n        return schedule;\n    }\n\n    /**\n     * @notice Computes the next non-cyclic contract events based on the contract terms\n     * and the timestamp on which the prev. event occured.\n     * @dev Assumes that non-cyclic events of the same event type have a unique schedule time\n     * @param terms terms of the contract\n     * @param lastNonCyclicEvent last non-cyclic event\n     * @return next non-cyclic event\n     */\n    function computeNextNonCyclicEvent(\n        CERTFTerms calldata terms,\n        bytes32 lastNonCyclicEvent\n    )\n        external\n        pure\n        override\n        returns (bytes32)\n    {\n        (EventType lastEventType, uint256 lastScheduleTime) = decodeEvent(lastNonCyclicEvent);\n\n        EventType eventTypeNextEvent;\n        uint256 scheduleTimeNextEvent;\n\n        // EventTypes ordered after epoch offset - so we don't have make an additional epochOffset check\n\n        // issue date\n        if (\n            // date for event has to be set in terms and date of event can be in the past\n            (terms.issueDate != 0 && (lastScheduleTime <= terms.issueDate))\n            // date for event has to come before previous candidate for the next event\n            && (scheduleTimeNextEvent == 0 || terms.issueDate < scheduleTimeNextEvent)\n            // avoid endless loop by requiring that the event is not the lastNonCyclicEvent\n            && (lastScheduleTime != terms.issueDate || lastEventType != EventType.ISS)\n        ) {\n            eventTypeNextEvent = EventType.ISS;\n            scheduleTimeNextEvent = terms.issueDate;\n        }\n\n        // initial exchange\n        if (\n            (terms.initialExchangeDate != 0 && (lastScheduleTime <= terms.initialExchangeDate))\n            && (scheduleTimeNextEvent == 0 || terms.initialExchangeDate < scheduleTimeNextEvent)\n            && (lastScheduleTime != terms.initialExchangeDate || lastEventType != EventType.IED)\n        ) {\n            eventTypeNextEvent = EventType.IED;\n            scheduleTimeNextEvent = terms.initialExchangeDate;\n        }\n\n        // maturity event\n        if (\n            (terms.maturityDate != 0 && (lastScheduleTime <= terms.maturityDate))\n            && (scheduleTimeNextEvent == 0 || terms.maturityDate < scheduleTimeNextEvent)\n            && (lastScheduleTime != terms.maturityDate || lastEventType != EventType.MD)\n        ) {\n            eventTypeNextEvent = EventType.MD;\n            scheduleTimeNextEvent = terms.maturityDate;\n        }\n\n        return encodeEvent(eventTypeNextEvent, scheduleTimeNextEvent);\n    }\n\n    /**\n     * @notice Computes a schedule segment of cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param lastScheduleTime last occurrence of cyclic event\n     * @param eventType eventType of the cyclic schedule\n     * @return event schedule segment\n     */\n    function computeNextCyclicEvent(\n        CERTFTerms calldata terms,\n        uint256 lastScheduleTime,\n        EventType eventType\n    )\n        external\n        pure\n        override\n        returns(bytes32)\n    {\n        if (eventType == EventType.COF) {\n            if (terms.cycleAnchorDateOfCoupon != 0) {\n                uint256 nextCouponDate = computeNextCycleDateFromPrecedingDate(\n                    terms.cycleOfCoupon,\n                    terms.endOfMonthConvention,\n                    terms.cycleAnchorDateOfCoupon,\n                    lastScheduleTime,\n                    true,\n                    terms.maturityDate\n                );\n                if (nextCouponDate == uint256(0)) return bytes32(0);\n                return encodeEvent(EventType.COF, nextCouponDate);\n            }\n        }\n\n         if (eventType == EventType.COP) {\n            if (terms.cycleAnchorDateOfCoupon != 0) {\n                uint256 nextCouponDate = computeNextCycleDateFromPrecedingDate(\n                    terms.cycleOfCoupon,\n                    terms.endOfMonthConvention,\n                    terms.cycleAnchorDateOfCoupon,\n                    lastScheduleTime,\n                    true,\n                    terms.maturityDate\n                );\n                if (nextCouponDate == uint256(0)) return bytes32(0);\n                uint256 couponPaymentDayScheduleTime = getTimestampPlusPeriod(terms.settlementPeriod, nextCouponDate);\n                return encodeEvent(EventType.COF, couponPaymentDayScheduleTime);\n            }\n        }\n\n        if (eventType == EventType.REF) {\n            if (terms.cycleAnchorDateOfRedemption != 0) {\n                uint256 nextRedemptionDate = computeNextCycleDateFromPrecedingDate(\n                    terms.cycleOfRedemption,\n                    terms.endOfMonthConvention,\n                    terms.cycleAnchorDateOfRedemption,\n                    lastScheduleTime,\n                    true,\n                    terms.maturityDate\n                );\n                if (nextRedemptionDate == uint256(0)) return bytes32(0);\n                return encodeEvent(EventType.REF, nextRedemptionDate);\n            }\n        }\n\n        if (eventType == EventType.REP) {\n            if (terms.cycleAnchorDateOfRedemption != 0) {\n                uint256 nextRedemptionDate = computeNextCycleDateFromPrecedingDate(\n                    terms.cycleOfRedemption,\n                    terms.endOfMonthConvention,\n                    terms.cycleAnchorDateOfRedemption,\n                    lastScheduleTime,\n                    true,\n                    terms.maturityDate\n                );\n                if (nextRedemptionDate == uint256(0)) return bytes32(0);\n                uint256 redemptionPaymentDayScheduleTime = getTimestampPlusPeriod(terms.settlementPeriod, nextRedemptionDate);\n                return encodeEvent(EventType.REP, redemptionPaymentDayScheduleTime);\n            }\n        }\n\n        if (eventType == EventType.EXE) {\n            if (terms.cycleAnchorDateOfRedemption != 0) {\n                uint256 nextRedemptionDate = computeNextCycleDateFromPrecedingDate(\n                    terms.cycleOfRedemption,\n                    terms.endOfMonthConvention,\n                    terms.cycleAnchorDateOfRedemption,\n                    lastScheduleTime,\n                    true,\n                    terms.maturityDate\n                );\n                if (nextRedemptionDate == uint256(0)) return bytes32(0);\n                if (nextRedemptionDate == terms.maturityDate) return bytes32(0);\n                uint256 executionDateScheduleTime = getTimestampPlusPeriod(terms.redemptionRecordPeriod, nextRedemptionDate);\n                return encodeEvent(EventType.EXE, executionDateScheduleTime);\n            }\n        }\n\n       return bytes32(0);\n    }\n\n    /**\n     * @notice Verifies that the provided event is still scheduled under the terms, the current state of the\n     * contract and the current state of the underlying.\n     * param _event event for which to check if its still scheduled\n     * param terms terms of the contract\n     * @param state current state of the contract\n     * param hasUnderlying boolean indicating whether the contract has an underlying contract\n     * param underlyingState state of the underlying (empty state object if non-existing)\n     * @return boolean indicating whether event is still scheduled\n     */\n    function isEventScheduled(\n        bytes32 /* _event */,\n        CERTFTerms calldata /* terms */,\n        State calldata state,\n        bool /* hasUnderlying */,\n        State calldata /* underlyingState */\n    )\n        external\n        pure\n        override\n        returns (bool)\n    {\n        if (\n            state.contractPerformance == ContractPerformance.DF\n            || state.contractPerformance == ContractPerformance.MD\n            || state.contractPerformance == ContractPerformance.TD\n        ) { return false; }\n\n        return true;\n    }\n\n    /**\n     * @notice Implements abstract method which is defined in BaseEngine.\n     * Applies an event to the current state of the contract and returns the resulting state.\n     * The inheriting Engine contract has to map the events type to the designated STF.\n     * todo Annuity calculator for RR/RRF events, IPCB events and ICB state variable\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which to evaluate the next state for\n     * @param externalData external data needed for STF evaluation (e.g. rate for RR events)\n     * @return the resulting contract state\n     */\n    function stateTransitionFunction(\n        CERTFTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n\n        if (eventType == EventType.ISS) return STF_CERTF_ISS(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.IED) return STF_CERTF_IED(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.COF) return STF_CERTF_COF(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.COP) return STF_CERTF_COP(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.REF) return STF_CERTF_REF(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.EXE) return STF_CERTF_EXE(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.REP) return STF_CERTF_REP(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.TD) return STF_CERTF_TD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.MD) return STF_CERTF_MD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.CE) return STF_CERTF_CE(terms, state, scheduleTime, externalData);\n\n        revert(\"CERTFEngine.stateTransitionFunction: ATTRIBUTE_NOT_FOUND\");\n    }\n\n    /**\n     * @notice Implements abstract method which is defined in BaseEngine.\n     * Computes the payoff for an event under the current state of the contract.\n     * The inheriting Engine contract has to map the events type to the designated POF.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which the payoff should be evaluated\n     * @param externalData external data needed for POF evaluation\n     * @return the payoff of the event\n     */\n    function payoffFunction(\n        CERTFTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (int256)\n    {\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n\n        if (eventType == EventType.ISS) return 0;\n        if (eventType == EventType.COF) return 0;\n        if (eventType == EventType.REF) return 0;\n        if (eventType == EventType.EXE) return 0;\n        if (eventType == EventType.MD) return 0;\n        if (eventType == EventType.CE) return 0;\n        if (eventType == EventType.IED) return POF_CERTF_IED(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.COP) return POF_CERTF_COP(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.REP) return POF_CERTF_REP(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.TD) return POF_CERTF_TD(terms, state, scheduleTime, externalData);\n\n        revert(\"CERTFEngine.payoffFunction: ATTRIBUTE_NOT_FOUND\");\n    }\n}\n"
    },
    "contracts/ACTUS/Engines/CERTF/CERTFSTF.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\n\nimport \"../../Core/Core.sol\";\nimport \"../../Core/SignedMath.sol\";\n\n\n/**\n * @title STF\n * @notice Contains all state transition functions (STFs) for CERTF contracts\n */\ncontract CERTFSTF is Core {\n\n    using SignedSafeMath for int;\n    using SignedMath for int;\n\n\n    /**\n     * State transition for CERTF issue events\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_CERTF_ISS (\n        CERTFTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        state.quantity = terms.quantity;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for CERTF initial exchange\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_CERTF_IED (\n        CERTFTerms memory /* terms */,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        state.statusDate = scheduleTime;\n        return state;\n    }\n\n    /**\n     * State transition for CERTF coupon fixing day\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_CERTF_COF (\n        CERTFTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        if (terms.couponType == CouponType.FIX) {\n            state.couponAmountFixed = yearFraction(\n                shiftCalcTime(state.lastCouponFixingDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                terms.dayCountConvention,\n                terms.maturityDate\n            ).floatMult(terms.nominalPrice).floatMult(terms.couponRate);\n        }\n\n        state.lastCouponFixingDate = scheduleTime;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n\n    /**\n     * State transition for CERTF coupon payment day\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_CERTF_COP (\n        CERTFTerms memory /* terms */,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        state.couponAmountFixed = 0;\n        state.statusDate = scheduleTime;\n        return state;\n    }\n\n\n    /**\n     * State transition for CERTF redemption fixing day\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_CERTF_REF (\n        CERTFTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        state.exerciseAmount = int256(externalData)\n        .floatMult(terms.nominalPrice)\n        .floatMult(state.marginFactor)\n        .floatMult(state.adjustmentFactor);\n\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for CERTF exercise day\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_CERTF_EXE (\n        CERTFTerms memory /* terms */,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        state.exerciseQuantity = int256(externalData);\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for CERTF Redemption Payment Day\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_CERTF_REP (\n        CERTFTerms memory /* terms */,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        state.quantity = state.quantity.sub(state.exerciseQuantity);\n        state.exerciseQuantity = 0;\n        state.exerciseAmount = 0;\n        state.statusDate = scheduleTime;\n\n        if (scheduleTime == state.maturityDate) {\n            state.contractPerformance = ContractPerformance.MD;\n        } else if (scheduleTime == state.terminationDate) {\n            state.contractPerformance = ContractPerformance.TD;\n        }\n\n        return state;\n    }\n\n    /**\n     * State transition for CERTF termination events\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_CERTF_TD (\n        CERTFTerms memory /* terms */,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        state.quantity = 0;\n        state.terminationDate = scheduleTime;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for CERTF maturity\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_CERTF_MD (\n        CERTFTerms memory /* terms */,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        state.maturityDate = scheduleTime;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for CERTF settlement\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_CERTF_CE (\n        CERTFTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        // handle maturity date\n        uint256 nonPerformingDate = (state.nonPerformingDate == 0)\n            ? shiftEventTime(\n                scheduleTime,\n                terms.businessDayConvention,\n                terms.calendar,\n                terms.maturityDate\n            ) : state.nonPerformingDate;\n\n        uint256 currentTimestamp = uint256(externalData);\n\n        bool isInGracePeriod = false;\n        if (terms.gracePeriod.isSet) {\n            uint256 graceDate = getTimestampPlusPeriod(terms.gracePeriod, nonPerformingDate);\n            if (currentTimestamp <= graceDate) {\n                state.contractPerformance = ContractPerformance.DL;\n                isInGracePeriod = true;\n            }\n        }\n\n        if (terms.delinquencyPeriod.isSet && !isInGracePeriod) {\n            uint256 delinquencyDate = getTimestampPlusPeriod(terms.delinquencyPeriod, nonPerformingDate);\n            if (currentTimestamp <= delinquencyDate) {\n                state.contractPerformance = ContractPerformance.DQ;\n            } else {\n                state.contractPerformance = ContractPerformance.DF;\n            }\n        }\n\n        if (state.nonPerformingDate == 0) {\n            // handle maturity date\n            state.nonPerformingDate = shiftEventTime(\n                scheduleTime,\n                terms.businessDayConvention,\n                terms.calendar,\n                terms.maturityDate\n            );\n        }\n\n        return state;\n    }\n}\n"
    },
    "contracts/ACTUS/Engines/CERTF/CERTFPOF.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\n\nimport \"../../Core/Core.sol\";\nimport \"../../Core/SignedMath.sol\";\n\n\n/**\n * @title POF\n * @notice Contains all Payoff Functions (POFs) for CERTF contracts\n */\ncontract CERTFPOF is Core {\n\n    using SignedSafeMath for int;\n    using SignedMath for int;\n\n\n    /**\n     * Payoff Function for CERTF initial exchange\n     * @return the new state\n     */\n    function POF_CERTF_IED (\n        CERTFTerms memory terms,\n        State memory state,\n        uint256 /* scheduleTime */,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        return (\n            roleSign(terms.contractRole) * state.quantity.floatMult(terms.issuePrice)\n        );\n    }\n\n    /**\n     * Payoff Function for CERTF coupon payment day\n     * @return the new state\n     */\n    function POF_CERTF_COP (\n        CERTFTerms memory terms,\n        State memory state,\n        uint256 /* scheduleTime */,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        return (\n            roleSign(terms.contractRole) * state.quantity.floatMult(state.couponAmountFixed)\n        );\n    }\n\n    /**\n     * Payoff Function for CERTF Redemption Payment Day\n     * @return the new state\n     */\n    function POF_CERTF_REP (\n        CERTFTerms memory terms,\n        State memory state,\n        uint256 /* scheduleTime */,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        return (\n            roleSign(terms.contractRole) * state.exerciseQuantity.floatMult(state.exerciseAmount)\n        );\n    }\n\n     /**\n     * Payoff Function for CERTF termination events\n     * @return the new state\n     */\n    function POF_CERTF_TD (\n        CERTFTerms memory terms,\n        State memory state,\n        uint256 /* scheduleTime */,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        return (\n            roleSign(terms.contractRole) * state.quantity.floatMult(state.exerciseAmount)\n        );\n    }\n}\n"
    },
    "contracts/ACTUS/Engines/CEC/ICECEngine.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../Core/ACTUSTypes.sol\";\nimport \"../IEngine.sol\";\n\n\n/**\n * @title IEngine\n * @notice Interface which all Engines have to implement\n */\ninterface ICECEngine is IEngine {\n\n    /**\n     * @notice Initialize contract state space based on the contract terms.\n     * @param terms terms of the contract\n     * @return initial state of the contract\n     */\n    function computeInitialState(CECTerms calldata terms)\n        external\n        pure\n        returns (State memory);\n\n    /**\n     * Applys an event to the current state of a contract and returns the resulting contract state.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event to be applied to the contract state\n     * @param externalData external data needed for STF evaluation (e.g. rate for RR events)\n     * @return the resulting contract state\n     */\n    function computeStateForEvent(\n        CECTerms calldata terms,\n        State calldata state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        external\n        pure\n        returns (State memory);\n\n    /**\n     * Evaluates the payoff for an event under the current state of the contract.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which the payoff should be evaluated\n     * @param externalData external data needed for POF evaluation (e.g. fxRate)\n     * @return the payoff of the event\n     */\n    function computePayoffForEvent(\n        CECTerms calldata terms,\n        State calldata state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        external\n        pure\n        returns (int256);\n\n    /**\n     * @notice Computes a schedule segment of non-cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @return segment of the non-cyclic schedule\n     */\n    function computeNonCyclicScheduleSegment(\n        CECTerms calldata terms,\n        uint256 segmentStart,\n        uint256 segmentEnd\n    )\n        external\n        pure\n        returns (bytes32[] memory);\n\n    /**\n     * @notice Computes a schedule segment of cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @param eventType eventType of the cyclic schedule\n     * @return event schedule segment\n     */\n    function computeCyclicScheduleSegment(\n        CECTerms calldata terms,\n        uint256 segmentStart,\n        uint256 segmentEnd,\n        EventType eventType\n    )\n        external\n        pure\n        returns (bytes32[] memory);\n\n    /**\n     * @notice Computes the next non-cyclic contract events based on the contract terms\n     * and the timestamp on which the prev. event occured.\n     * @dev Assumes that non-cyclic events of the same event type have a unique schedule time\n     * @param terms terms of the contract\n     * @param lastNonCyclicEvent last non-cyclic event\n     * @return next non-cyclic event\n     */\n    function computeNextNonCyclicEvent(\n        CECTerms calldata terms,\n        bytes32 lastNonCyclicEvent\n    )\n        external\n        pure\n        returns (bytes32);\n\n    /**\n     * @notice Computes a schedule segment of cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param lastScheduleTime last occurrence of cyclic event\n     * @param eventType eventType of the cyclic schedule\n     * @return event schedule segment\n     */\n    function computeNextCyclicEvent(\n        CECTerms calldata terms,\n        uint256 lastScheduleTime,\n        EventType eventType\n    )\n        external\n        pure\n        returns(bytes32);\n\n    /**\n     * @notice Verifies that the provided event is still scheduled under the terms, the current state of the\n     * contract and the current state of the underlying.\n     * @param _event event for which to check if its still scheduled\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param hasUnderlying boolean indicating whether the contract has an underlying contract\n     * @param underlyingState state of the underlying (empty state object if non-existing)\n     * @return boolean indicating whether event is still scheduled\n     */\n    function isEventScheduled(\n        bytes32 _event,\n        CECTerms calldata terms,\n        State calldata state,\n        bool hasUnderlying,\n        State calldata underlyingState\n    )\n        external\n        pure\n        returns (bool);\n}\n"
    },
    "contracts/Core/CEC/CECRegistry.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../ACTUS/Engines/CEC/ICECEngine.sol\";\n\nimport \"../Base/SharedTypes.sol\";\nimport \"../Base/AssetRegistry/BaseRegistry.sol\";\nimport \"./CECEncoder.sol\";\nimport \"./ICECRegistry.sol\";\n\n\n/**\n * @title CECRegistry\n * @notice Registry for ACTUS Protocol assets\n */\ncontract CECRegistry is BaseRegistry, ICECRegistry {\n\n    using CECEncoder for Asset;\n\n    \n    constructor() BaseRegistry() {}\n\n    /**\n     * @notice\n     * @param assetId id of the asset\n     * @param terms asset specific terms (CECTerms)\n     * @param state initial state of the asset\n     * @param schedule schedule of the asset\n     * @param ownership ownership of the asset\n     * @param engine ACTUS Engine of the asset\n     * @param actor account which is allowed to update the asset state\n     * @param admin account which as admin rights (optional)\n     */\n    function registerAsset(\n        bytes32 assetId,\n        CECTerms calldata terms,\n        State calldata state,\n        bytes32[] calldata schedule,\n        AssetOwnership calldata ownership,\n        address engine,\n        address actor,\n        address admin\n    )\n        external\n        override\n        onlyApprovedActors\n    {\n        setAsset(assetId, state, schedule, ownership, engine, actor, admin);\n        assets[assetId].encodeAndSetCECTerms(terms);\n    }\n\n    /**\n     * @notice Returns the terms of an asset.\n     * @param assetId id of the asset\n     * @return terms of the asset\n     */\n    function getTerms(bytes32 assetId)\n        external\n        view\n        override\n        returns (CECTerms memory)\n    {\n        return assets[assetId].decodeAndGetCECTerms();\n    }\n\n    /**\n     * @notice Set the terms of the asset\n     * @dev Can only be set by authorized account.\n     * @param assetId id of the asset\n     * @param terms new terms\n     */\n    function setTerms(bytes32 assetId, CECTerms calldata terms)\n        external\n        override\n        isAuthorized (assetId)\n    {\n        assets[assetId].encodeAndSetCECTerms(terms);\n        emit UpdatedTerms(assetId);\n    }\n\n    function getEnumValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (uint8)\n    {\n        return assets[assetId].decodeAndGetEnumValueForCECAttribute(attribute);\n    }\n\n    function getAddressValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (address)\n    {\n        return assets[assetId].decodeAndGetAddressValueForForCECAttribute(attribute);\n    }\n\n    function getBytes32ValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (bytes32)\n    {\n        return assets[assetId].decodeAndGetBytes32ValueForForCECAttribute(attribute);\n    }\n\n    function getUIntValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (uint256)\n    {\n        return assets[assetId].decodeAndGetUIntValueForForCECAttribute(attribute);\n    }\n\n    function getIntValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (int256)\n    {\n        return assets[assetId].decodeAndGetIntValueForForCECAttribute(attribute);\n    }\n\n    function getPeriodValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (IP memory)\n    {\n        return assets[assetId].decodeAndGetPeriodValueForForCECAttribute(attribute);\n    }\n\n    function getCycleValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (IPS memory)\n    {\n        return assets[assetId].decodeAndGetCycleValueForForCECAttribute(attribute);\n    }\n\n    function getContractReferenceValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (ContractReference memory)\n    {\n        return assets[assetId].decodeAndGetContractReferenceValueForCECAttribute(attribute);\n    }\n\n    function getNextComputedEvent(bytes32 assetId)\n        internal\n        view\n        override(TermsRegistry)\n        returns (bytes32, bool)\n    {\n        Asset storage asset = assets[assetId];\n        CECTerms memory terms = asset.decodeAndGetCECTerms();\n\n        EventType nextEventType;\n        uint256 nextScheduleTime;\n        bool isCyclicEvent = true;\n\n        // Non-Cyclic\n        {\n            (EventType eventType, uint256 scheduleTime) = decodeEvent(ICECEngine(asset.engine).computeNextNonCyclicEvent(\n                terms,\n                asset.schedule.lastNonCyclicEvent\n            ));\n\n            if (\n                (nextScheduleTime == 0)\n                || (scheduleTime != 0 && scheduleTime < nextScheduleTime)\n                || (scheduleTime != 0 && nextScheduleTime == scheduleTime && getEpochOffset(eventType) < getEpochOffset(nextEventType))\n            ) {\n                nextScheduleTime = scheduleTime;\n                nextEventType = eventType;\n                isCyclicEvent = false;\n            }        \n        }\n\n        return (encodeEvent(nextEventType, nextScheduleTime), isCyclicEvent);\n    }\n}\n"
    },
    "contracts/Core/CEC/CECEncoder.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../Base/SharedTypes.sol\";\nimport \"../Base/AssetRegistry/BaseRegistryStorage.sol\";\n\n\nlibrary CECEncoder {\n\n    function storeInPackedTerms(Asset storage asset, bytes32 attributeKey, bytes32 value) private {\n        // skip if value did not change\n        if (asset.packedTerms[attributeKey] == value) return;\n        asset.packedTerms[attributeKey] = value;\n    }\n    \n    /**\n     * @dev Tightly pack and store only non-zero overwritten terms (LifecycleTerms)\n     * @notice All non zero values of the overwrittenTerms object are stored.\n     * It does not check if overwrittenAttributesMap actually marks attribute as overwritten.\n     */\n    function encodeAndSetCECTerms(Asset storage asset, CECTerms memory terms) external {\n        storeInPackedTerms(\n            asset,\n            \"enums\",\n            bytes32(uint256(uint8(terms.contractType))) << 248 |\n            bytes32(uint256(uint8(terms.calendar))) << 240 |\n            bytes32(uint256(uint8(terms.contractRole))) << 232 |\n            bytes32(uint256(uint8(terms.dayCountConvention))) << 224 |\n            bytes32(uint256(uint8(terms.businessDayConvention))) << 216 |\n            bytes32(uint256(uint8(terms.endOfMonthConvention))) << 208 |\n            bytes32(uint256(uint8(terms.creditEventTypeCovered))) << 200 |\n            bytes32(uint256(uint8(terms.feeBasis))) << 192\n        );\n\n        storeInPackedTerms(asset, \"statusDate\", bytes32(terms.statusDate));\n        storeInPackedTerms(asset, \"maturityDate\", bytes32(terms.maturityDate));\n\n        storeInPackedTerms(asset, \"notionalPrincipal\", bytes32(terms.notionalPrincipal));\n        \n        storeInPackedTerms(asset, \"feeRate\", bytes32(terms.feeRate));\n        storeInPackedTerms(asset, \"coverageOfCreditEnhancement\", bytes32(terms.coverageOfCreditEnhancement));\n\n        storeInPackedTerms(\n            asset,\n            \"contractReference_1_type_role\",\n            bytes32(uint256(terms.contractReference_1._type)) << 16 |\n            bytes32(uint256(terms.contractReference_1.role)) << 8\n        );\n\n        storeInPackedTerms(\n            asset,\n            \"contractReference_1_object\",\n            terms.contractReference_1.object\n        );\n        storeInPackedTerms(\n            asset,\n            \"contractReference_1_object2\",\n            terms.contractReference_1.object2\n        );\n\n        storeInPackedTerms(\n            asset,\n            \"contractReference_2_type_role\",\n            bytes32(uint256(terms.contractReference_2._type)) << 16 |\n            bytes32(uint256(terms.contractReference_2.role)) << 8\n        );\n\n        storeInPackedTerms(\n            asset,\n            \"contractReference_2_object\",\n            terms.contractReference_2.object\n        );\n        storeInPackedTerms(\n            asset,\n            \"contractReference_2_object2\",\n            terms.contractReference_2.object2\n        );\n    }\n\n    /**\n     * @dev Decode and loads CECTerms\n     */\n    function decodeAndGetCECTerms(Asset storage asset) external view returns (CECTerms memory) {\n        return CECTerms(\n            ContractType(uint8(uint256(asset.packedTerms[\"enums\"] >> 248))),\n            Calendar(uint8(uint256(asset.packedTerms[\"enums\"] >> 240))),\n            ContractRole(uint8(uint256(asset.packedTerms[\"enums\"] >> 232))),\n            DayCountConvention(uint8(uint256(asset.packedTerms[\"enums\"] >> 224))),\n            BusinessDayConvention(uint8(uint256(asset.packedTerms[\"enums\"] >> 216))),\n            EndOfMonthConvention(uint8(uint256(asset.packedTerms[\"enums\"] >> 208))),\n            ContractPerformance(uint8(uint256(asset.packedTerms[\"enums\"] >> 200))),\n            FeeBasis(uint8(uint256(asset.packedTerms[\"enums\"] >> 192))),\n\n            uint256(asset.packedTerms[\"statusDate\"]),\n            uint256(asset.packedTerms[\"maturityDate\"]),\n\n            int256(asset.packedTerms[\"notionalPrincipal\"]),\n            int256(asset.packedTerms[\"feeRate\"]),\n            int256(asset.packedTerms[\"coverageOfCreditEnhancement\"]),\n\n            ContractReference(\n                asset.packedTerms[\"contractReference_1_object\"],\n                asset.packedTerms[\"contractReference_1_object2\"],\n                ContractReferenceType(uint8(uint256(asset.packedTerms[\"contractReference_1_type_role\"] >> 16))),\n                ContractReferenceRole(uint8(uint256(asset.packedTerms[\"contractReference_1_type_role\"] >> 8)))\n            ),\n            ContractReference(\n                asset.packedTerms[\"contractReference_2_object\"],\n                asset.packedTerms[\"contractReference_2_object2\"],\n                ContractReferenceType(uint8(uint256(asset.packedTerms[\"contractReference_2_type_role\"] >> 16))),\n                ContractReferenceRole(uint8(uint256(asset.packedTerms[\"contractReference_2_type_role\"] >> 8)))\n            )\n        );\n    }\n\n    function decodeAndGetEnumValueForCECAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (uint8)\n    {\n        if (attributeKey == \"contractType\") {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 248));\n        } else if (attributeKey == bytes32(\"calendar\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 240));\n        } else if (attributeKey == bytes32(\"contractRole\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 232));\n        } else if (attributeKey == bytes32(\"dayCountConvention\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 224));\n        } else if (attributeKey == bytes32(\"businessDayConvention\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 216));\n        } else if (attributeKey == bytes32(\"endOfMonthConvention\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 208));\n        } else if (attributeKey == bytes32(\"creditEventTypeCovered\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 200));\n        } else if (attributeKey == bytes32(\"feeBasis\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 192));\n        } else {\n            return uint8(0);\n        }\n    }\n\n    function decodeAndGetAddressValueForForCECAttribute(Asset storage /* asset */, bytes32 /* attributeKey */)\n        external\n        pure\n        returns (address)\n    {\n        return address(0);\n    }\n\n    function decodeAndGetBytes32ValueForForCECAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (bytes32)\n    {\n        return asset.packedTerms[attributeKey];\n    }\n\n    function decodeAndGetUIntValueForForCECAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (uint256)\n    {\n        return uint256(asset.packedTerms[attributeKey]);\n    }\n\n    function decodeAndGetIntValueForForCECAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (int256)\n    {\n        return int256(asset.packedTerms[attributeKey]);\n    }\n\n    function decodeAndGetPeriodValueForForCECAttribute(Asset storage /* asset */, bytes32 /* attributeKey */)\n        external\n        pure\n        returns (IP memory)\n    {\n        return IP(0, P(0), false);\n    }\n\n    function decodeAndGetCycleValueForForCECAttribute(Asset storage /* asset */, bytes32 /* attributeKey */)\n        external\n        pure\n        returns (IPS memory)\n    {\n        return IPS(0, P(0), S(0), false);\n    }\n\n    function decodeAndGetContractReferenceValueForCECAttribute(Asset storage asset , bytes32 attributeKey )\n        external\n        view\n        returns (ContractReference memory)\n    {\n        if (attributeKey == bytes32(\"contractReference_1\")) {\n            return ContractReference(\n                asset.packedTerms[\"contractReference_1_object\"],\n                asset.packedTerms[\"contractReference_1_object2\"],\n                ContractReferenceType(uint8(uint256(asset.packedTerms[\"contractReference_1_type_role\"] >> 16))),\n                ContractReferenceRole(uint8(uint256(asset.packedTerms[\"contractReference_1_type_role\"] >> 8)))\n            );\n        } else if (attributeKey == bytes32(\"contractReference_2\")) {\n            return ContractReference(\n                asset.packedTerms[\"contractReference_2_object\"],\n                asset.packedTerms[\"contractReference_2_object2\"],\n                ContractReferenceType(uint8(uint256(asset.packedTerms[\"contractReference_2_type_role\"] >> 16))),\n                ContractReferenceRole(uint8(uint256(asset.packedTerms[\"contractReference_2_type_role\"] >> 8)))\n            );\n        } else {\n            return ContractReference(\n                bytes32(0),\n                bytes32(0),\n                ContractReferenceType(0),\n                ContractReferenceRole(0)\n            );\n        }\n    }\n}"
    },
    "contracts/Core/CEC/ICECRegistry.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../Base/SharedTypes.sol\";\nimport \"../Base/AssetRegistry/IAssetRegistry.sol\";\n\n\ninterface ICECRegistry is IAssetRegistry {\n\n    function registerAsset(\n        bytes32 assetId,\n        CECTerms calldata terms,\n        State calldata state,\n        bytes32[] calldata schedule,\n        AssetOwnership calldata ownership,\n        address engine,\n        address actor,\n        address admin\n    )\n        external;\n\n    function getTerms(bytes32 assetId)\n        external\n        view\n        returns (CECTerms memory);\n\n    function setTerms(bytes32 assetId, CECTerms calldata terms)\n        external;\n}\n"
    },
    "contracts/Core/CEC/CECActor.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../ACTUS/Engines/CEC/ICECEngine.sol\";\n\nimport \"../Base/AssetActor/BaseActor.sol\";\nimport \"../Base/Custodian/ICustodian.sol\";\nimport \"./ICECRegistry.sol\";\n\n\n/**\n * @title CECActor\n * @notice TODO\n */\ncontract CECActor is BaseActor {\n\n    using SignedMath for int;\n\n\n    constructor(IAssetRegistry assetRegistry, IOracleProxy defaultOracleProxy) BaseActor(assetRegistry, defaultOracleProxy) {}\n\n    /**\n     * @notice Derives initial state of the asset terms and stores together with\n     * terms, schedule, ownership, engine, admin of the asset in the contract types specific AssetRegistry.\n     * @param terms asset specific terms\n     * @param schedule schedule of the asset\n     * @param engine address of the ACTUS engine used for the spec. ContractType\n     * @param admin address of the admin of the asset (optional)\n     * @param custodian address of the custodian of the collateral\n     * @param underlyingRegistry address of the asset registry where the underlying asset is stored\n     */\n    function initialize(\n        CECTerms calldata terms,\n        bytes32[] calldata schedule,\n        address engine,\n        address admin,\n        address custodian,\n        address underlyingRegistry\n    )\n        external\n    {\n        require(\n            engine != address(0) && IEngine(engine).contractType() == ContractType.CEC,\n            \"ANNActor.initialize: CONTRACT_TYPE_OF_ENGINE_UNSUPPORTED\"\n        );\n\n        // solium-disable-next-line\n        bytes32 assetId = keccak256(abi.encode(terms, block.timestamp));\n        AssetOwnership memory ownership;\n\n        // check if first contract reference in terms references an underlying asset\n        if (terms.contractReference_1.role == ContractReferenceRole.COVE) {\n            require(\n                terms.contractReference_1.object != bytes32(0),\n                \"CECActor.initialize: INVALID_CONTRACT_REFERENCE_1_OBJECT\"\n            );\n        }\n\n        // check if second contract reference in terms contains a reference to collateral\n        if (terms.contractReference_2.role == ContractReferenceRole.COVI) {\n            require(\n                terms.contractReference_2.object != bytes32(0),\n                \"CECActor.initialize: INVALID_CONTRACT_REFERENCE_2_OBJECT\"\n            );\n\n            // derive assetId\n            // solium-disable-next-line\n            assetId = keccak256(abi.encode(terms, address(custodian), block.timestamp));\n\n            // derive underlying assetId\n            bytes32 underlyingAssetId = terms.contractReference_1.object;\n            // get contract role and ownership of referenced underlying asset\n            ContractRole underlyingContractRole = ContractRole(assetRegistry.getEnumValueForTermsAttribute(underlyingAssetId, \"contractRole\"));\n            AssetOwnership memory underlyingAssetOwnership = IAssetRegistry(underlyingRegistry).getOwnership(underlyingAssetId);\n\n            // set ownership of draft according to contract role of underlying\n            if (terms.contractRole == ContractRole.BUY && underlyingContractRole == ContractRole.RPA) {\n                ownership = AssetOwnership(\n                    underlyingAssetOwnership.creatorObligor,\n                    underlyingAssetOwnership.creatorBeneficiary,\n                    address(custodian),\n                    underlyingAssetOwnership.counterpartyBeneficiary\n                );\n            } else if (terms.contractRole == ContractRole.SEL && underlyingContractRole == ContractRole.RPL) {\n                ownership = AssetOwnership(\n                    address(custodian),\n                    underlyingAssetOwnership.creatorBeneficiary,\n                    underlyingAssetOwnership.counterpartyObligor,\n                    underlyingAssetOwnership.counterpartyBeneficiary\n                );\n            } else {\n                // only BUY, RPA and SEL, RPL allowed for CEC\n                revert(\"CECActor.initialize: INVALID_CONTRACT_ROLES\");\n            }\n\n            // execute contractual conditions\n            // try transferring collateral to the custodian\n            ICustodian(custodian).lockCollateral(assetId, terms, ownership);\n        }\n\n        // compute the initial state of the asset\n        State memory initialState = ICECEngine(engine).computeInitialState(terms);\n\n        // register the asset in the AssetRegistry\n        ICECRegistry(address(assetRegistry)).registerAsset(\n            assetId,\n            terms,\n            initialState,\n            schedule,\n            ownership,\n            engine,\n            address(this),\n            admin\n        );\n\n        emit InitializedAsset(assetId, ContractType.CEC, ownership.creatorObligor, ownership.counterpartyObligor);\n    }\n\n    function computeStateAndPayoffForEvent(bytes32 assetId, State memory state, bytes32 _event)\n        internal\n        view\n        override\n        returns (State memory, int256)\n    {\n        address engine = assetRegistry.getEngine(assetId);\n        CECTerms memory terms = ICECRegistry(address(assetRegistry)).getTerms(assetId);\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n\n        int256 payoff = ICECEngine(engine).computePayoffForEvent(\n            terms,\n            state,\n            _event,\n            getExternalDataForPOF(\n                assetId,\n                eventType,\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate)\n            )\n        );\n        state = ICECEngine(engine).computeStateForEvent(\n            terms,\n            state,\n            _event,\n            getExternalDataForSTF(\n                assetId,\n                eventType,\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate)\n            )\n        );\n\n        return (state, payoff);\n    }\n\n    /**\n     * @notice Retrieves external data (such as market object data, block time, underlying asset state)\n     * used for evaluating the STF for a given event.\n     */\n    function getExternalDataForSTF(\n        bytes32 assetId,\n        EventType eventType,\n        uint256 /* timestamp */\n    )\n        internal\n        view\n        override\n        returns (bytes32)\n    {\n        if (eventType == EventType.EXE) {\n            // get the remaining notionalPrincipal from the underlying\n            ContractReference memory contractReference_1 = assetRegistry.getContractReferenceValueForTermsAttribute(\n                assetId,\n                \"contractReference_1\"\n            );\n            if (contractReference_1.role == ContractReferenceRole.COVE) {\n                bytes32 underlyingAssetId = contractReference_1.object;\n                address underlyingRegistry = address(uint160(uint256(contractReference_1.object2)));\n                require(\n                    IAssetRegistry(underlyingRegistry).isRegistered(underlyingAssetId) == true,\n                    \"BaseActor.getExternalDataForSTF: ASSET_DOES_NOT_EXIST\"\n                );\n                return bytes32(\n                    IAssetRegistry(underlyingRegistry).getIntValueForStateAttribute(underlyingAssetId, \"notionalPrincipal\")\n                );\n            }\n        }\n\n        return bytes32(0);\n    }\n}"
    },
    "contracts/Core/Base/Custodian/ICustodian.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../SharedTypes.sol\";\n\n\ninterface ICustodian {\n\n    function lockCollateral(\n        bytes32 assetId,\n        CECTerms calldata terms,\n        AssetOwnership calldata ownership\n    )\n        external\n        returns (bool);\n\n    function returnCollateral(\n        bytes32 assetId\n    )\n        external\n        returns (bool);\n}"
    },
    "contracts/Core/Base/Custodian/Custodian.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"../Conversions.sol\";\nimport \"../../CEC/ICECRegistry.sol\";\nimport \"./ICustodian.sol\";\n\n\n/**\n * @title Custodian\n * @notice Contract which holds the collateral of CEC (Credit Enhancement Collateral) assets.\n */\ncontract Custodian is ICustodian, ReentrancyGuard, Conversions {\n\n    using SafeMath for uint256;\n\n    event LockedCollateral(bytes32 indexed assetId, address collateralizer, uint256 collateralAmount);\n    event ReturnedCollateral(bytes32 indexed assetId, address collateralizer, uint256 returnedAmount);\n\n    address public cecActor;\n    ICECRegistry public cecRegistry;\n    mapping(bytes32 => bool) internal collateral;\n\n\n    constructor(address _cecActor, ICECRegistry _cecRegistry) {\n        cecActor = _cecActor;\n        cecRegistry = _cecRegistry;\n    }\n\n    /**\n     * @notice Locks the required collateral amount encoded in the second contract\n     * reference in the terms.\n     * @dev The collateralizer has to set allowance beforehand. The custodian increases\n     * allowance for the AssetActor by amount of collateral\n     * @param assetId id of the asset with collateral requirements\n     * @param terms terms of the asset containing the collateral requirements\n     * @param ownership ownership of the asset\n     * @return true if the collateral was locked by the Custodian\n     */\n    function lockCollateral(\n        bytes32 assetId,\n        CECTerms calldata terms,\n        AssetOwnership calldata ownership\n    )\n        external\n        override\n        returns (bool)\n    {\n        require(\n            terms.contractRole == ContractRole.BUY || terms.contractRole == ContractRole.SEL,\n            \"Custodian.lockCollateral: INVALID_CONTRACT_ROLE\"\n        );\n\n        require(\n            (terms.contractRole == ContractRole.BUY)\n                ? ownership.counterpartyObligor == address(this)\n                : ownership.creatorObligor == address(this),\n            \"Custodian.lockCollateral: INVALID_OWNERSHIP\"\n        );\n\n        // derive address of collateralizer\n        address collateralizer = (terms.contractRole == ContractRole.BUY)\n            ? ownership.counterpartyBeneficiary\n            : ownership.creatorBeneficiary;\n\n        // decode token address and amount of collateral\n        (address collateralToken, uint256 collateralAmount) = decodeCollateralObject(terms.contractReference_2.object);\n\n        require(\n            IERC20(collateralToken).allowance(collateralizer, address(this)) >= collateralAmount,\n            \"Custodian.lockCollateral: INSUFFICIENT_ALLOWANCE\"\n        );\n\n        // try transferring collateral from collateralizer to the custodian\n        require(\n            IERC20(collateralToken).transferFrom(collateralizer, address(this), collateralAmount),\n            \"Custodian.lockCollateral: TRANSFER_FAILED\"\n        );\n\n        // set allowance for AssetActor to later transfer collateral when EXE is triggered\n        uint256 allowance = IERC20(collateralToken).allowance(address(this), cecActor);\n        require(\n            IERC20(collateralToken).approve(cecActor, allowance.add(collateralAmount)),\n            \"Custodian.lockCollateral: INCREASING_ALLOWANCE_FAILED\"\n        );\n\n        // register collateral for assetId\n        collateral[assetId] = true;\n\n        emit LockedCollateral(assetId, collateralizer, collateralAmount);\n\n        return true;\n    }\n\n    /**\n     * @notice Returns the entire collateral back to the collateralizer if collateral\n     * was not executed before the asset reached maturity or it returns the remaining\n     * collateral (not executed amount) after collateral was executed and settled\n     * @dev resets allowance for the Asset Actor,\n     * reverts if state of the asset does not allow unlocking the collateral\n     * @param assetId id of the asset for which to return the collateral,\n     * @return true if the collateral was returned to the collateralizer\n     */\n    function returnCollateral(\n        bytes32 assetId\n    )\n        external\n        override\n        returns (bool)\n    {\n        require(\n            collateral[assetId] == true,\n            \"Custodian.returnCollateral: ENTRY_DOES_NOT_EXIST\"\n        );\n\n        ContractRole contractRole = ContractRole(cecRegistry.getEnumValueForTermsAttribute(assetId, \"contractRole\"));\n        ContractReference memory contractReference_2 = cecRegistry.getContractReferenceValueForTermsAttribute(assetId, \"contractReference_2\");\n        State memory state = cecRegistry.getState(assetId);\n        AssetOwnership memory ownership = cecRegistry.getOwnership(assetId);\n\n        // derive address of collateralizer\n        address collateralizer = (contractRole == ContractRole.BUY)\n            ? ownership.counterpartyBeneficiary\n            : ownership.creatorBeneficiary;\n\n        // decode token address and amount of collateral\n        (address collateralToken, uint256 collateralAmount) = decodeCollateralObject(contractReference_2.object);\n\n        // calculate amount to return\n        uint256 notExecutedAmount;\n        // if EXE was triggerd\n        if (state.exerciseDate != uint256(0)) {\n            notExecutedAmount = collateralAmount.sub(\n                (state.exerciseAmount >= 0) ? uint256(state.exerciseAmount) : uint256(-1 * state.exerciseAmount)\n            );\n        // if EXE was not triggered and (reached maturity or was terminated)\n        } else if (\n            state.exerciseDate == uint256(0)\n            && (state.contractPerformance == ContractPerformance.MD || state.contractPerformance == ContractPerformance.TD)\n        ) {\n            notExecutedAmount = collateralAmount;\n        // throw if EXE was not triggered and maturity is not reached\n        } else {\n            revert(\"Custodian.returnCollateral: COLLATERAL_CAN_NOT_BE_RETURNED\");\n        }\n\n        // reset allowance for AssetActor\n        uint256 allowance = IERC20(collateralToken).allowance(address(this), cecActor);\n        require(\n            IERC20(collateralToken).approve(cecActor, allowance.sub(notExecutedAmount)),\n            \"Custodian.returnCollateral: DECREASING_ALLOWANCE_FAILD\"\n        );\n\n        // try transferring amount back to the collateralizer\n        require(\n            IERC20(collateralToken).transfer(collateralizer, notExecutedAmount),\n            \"Custodian.returnCollateral: TRANSFER_FAILED\"\n        );\n\n        emit ReturnedCollateral(assetId, collateralizer, notExecutedAmount);\n\n        return true;\n    }\n}\n"
    },
    "contracts/ACTUS/Engines/CEC/CECEngine.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\n\nimport \"../../Core/Core.sol\";\nimport \"../../Core/SignedMath.sol\";\nimport \"./ICECEngine.sol\";\nimport \"./CECSTF.sol\";\nimport \"./CECPOF.sol\";\n\n\n/**\n * @title CECEngine\n * @notice Inherits from BaseEngine by implementing STFs, POFs according to the ACTUS standard for a CEC contract\n * @dev All numbers except unix timestamp are represented as multiple of 10 ** 18\n * inputs have to be multiplied by 10 ** 18, outputs have to multplied by 10 ** -18\n */\ncontract CECEngine is Core, CECSTF, CECPOF, ICECEngine {\n\n    using SignedSafeMath for int;\n    using SignedMath for int;\n\n\n    function contractType() external pure override returns (ContractType) {\n        return ContractType.CEC;\n    }\n\n    /**\n     * Applys an event to the current state of a contract and returns the resulting contract state.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event to be applied to the contract state\n     * @param externalData external data needed for STF evaluation (e.g. rate for RR events)\n     * @return the resulting contract state\n     */\n    function computeStateForEvent(\n        CECTerms calldata terms,\n        State calldata state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        external\n        pure\n        override\n        returns (State memory)\n    {\n        return stateTransitionFunction(\n            terms,\n            state,\n            _event,\n            externalData\n        );\n    }\n\n    /**\n     * Evaluates the payoff for an event under the current state of the contract.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which the payoff should be evaluated\n     * @param externalData external data needed for POF evaluation (e.g. fxRate)\n     * @return the payoff of the event\n     */\n    function computePayoffForEvent(\n        CECTerms calldata terms,\n        State calldata state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        external\n        pure\n        override\n        returns (int256)\n    {\n        // // if alternative settlementCurrency is set then apply fxRate to payoff\n        // if (terms.settlementCurrency != address(0) && terms.currency != terms.settlementCurrency) {\n        //     return payoffFunction(\n        //         terms,\n        //         state,\n        //         _event,\n        //         externalData\n        //     ).floatMult(int256(externalData));\n        // }\n\n        return payoffFunction(\n            terms,\n            state,\n            _event,\n            externalData\n        );\n    }\n\n    /**\n     * @notice Initialize contract state space based on the contract terms.\n     * @param terms terms of the contract\n     * @return initial state of the contract\n     */\n    function computeInitialState(CECTerms calldata terms)\n        external\n        pure\n        override\n        returns (State memory)\n    {\n        State memory state;\n\n        state.contractPerformance = ContractPerformance.PF;\n        state.statusDate = terms.statusDate;\n        state.maturityDate = terms.maturityDate;\n        state.notionalPrincipal = roleSign(terms.contractRole) * terms.notionalPrincipal;\n\n        return state;\n    }\n\n    /**\n     * @notice Computes a schedule segment of non-cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @return segment of the non-cyclic schedule\n     */\n    function computeNonCyclicScheduleSegment(\n        CECTerms calldata terms,\n        uint256 segmentStart,\n        uint256 segmentEnd\n    )\n        external\n        pure\n        override\n        returns (bytes32[] memory)\n    {\n        bytes32[MAX_EVENT_SCHEDULE_SIZE] memory events;\n        uint16 index;\n\n        // maturity event\n        if (isInSegment(terms.maturityDate, segmentStart, segmentEnd) == true) {\n            events[index] = encodeEvent(EventType.MD, terms.maturityDate);\n            index++;\n        }\n\n        // remove null entries from returned array\n        bytes32[] memory schedule = new bytes32[](index);\n        for (uint256 i = 0; i < index; i++) {\n            schedule[i] = events[i];\n        }\n\n        return schedule;\n    }\n\n    /**\n     * @notice Computes a schedule segment of cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * param terms terms of the contract\n     * param segmentStart start timestamp of the segment\n     * param segmentEnd end timestamp of the segement\n     * param eventType eventType of the cyclic schedule\n     * @return event schedule segment\n     */\n    function computeCyclicScheduleSegment(\n        CECTerms calldata /* terms */,\n        uint256 /* segmentStart */,\n        uint256 /* segmentEnd */,\n        EventType /* eventType */\n    )\n        external\n        pure\n        override\n        returns (bytes32[] memory)\n    {\n        bytes32[] memory schedule = new bytes32[](0);\n\n        return schedule;\n    }\n\n    /**\n     * @notice Computes the next non-cyclic contract events based on the contract terms\n     * and the timestamp on which the prev. event occured.\n     * @dev Assumes that non-cyclic events of the same event type have a unique schedule time\n     * @param terms terms of the contract\n     * @param lastNonCyclicEvent last non-cyclic event\n     * @return next non-cyclic event\n     */\n    function computeNextNonCyclicEvent(\n        CECTerms calldata terms,\n        bytes32 lastNonCyclicEvent\n    )\n        external\n        pure\n        override\n        returns (bytes32)\n    {\n        (EventType lastEventType, uint256 lastScheduleTime) = decodeEvent(lastNonCyclicEvent);\n\n        EventType eventTypeNextEvent;\n        uint256 scheduleTimeNextEvent;\n\n        // EventTypes ordered after epoch offset - so we don't have make an additional epochOffset check\n\n        // maturity event\n        if (\n            // date for event has to be set in terms and date of event can be in the past\n            (terms.maturityDate != 0 && (lastScheduleTime <= terms.maturityDate))\n            // date for event has to come before previous candidate for the next event\n            // && (scheduleTimeNextEvent == 0 || terms.maturityDate < scheduleTimeNextEvent)\n            // avoid endless loop by requiring that the event is not the lastNonCyclicEvent\n            && (lastScheduleTime != terms.maturityDate || lastEventType != EventType.MD)\n        ) {\n            eventTypeNextEvent = EventType.MD;\n            scheduleTimeNextEvent = terms.maturityDate;\n        }\n\n        return encodeEvent(eventTypeNextEvent, scheduleTimeNextEvent);\n    }\n\n    /**\n     * @notice Computes a schedule segment of cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * param terms terms of the contract\n     * param lastScheduleTime last occurrence of cyclic event\n     * param eventType eventType of the cyclic schedule\n     * @return event schedule segment\n     */\n    function computeNextCyclicEvent(\n        CECTerms calldata /* terms */,\n        uint256 /* lastScheduleTime */,\n        EventType /* eventType */\n    )\n        external\n        pure\n        override\n        returns(bytes32)\n    {\n        return bytes32(0);\n    }\n\n    /**\n     * @notice Verifies that the provided event is still scheduled under the terms, the current state of the\n     * contract and the current state of the underlying.\n     * param _event event for which to check if its still scheduled\n     * param terms terms of the contract\n     * param state current state of the contract\n     * param hasUnderlying boolean indicating whether the contract has an underlying contract\n     * param underlyingState state of the underlying (empty state object if non-existing)\n     * @return boolean indicating whether event is still scheduled\n     */\n    function isEventScheduled(\n        bytes32 /* _event */,\n        CECTerms calldata /* terms */,\n        State calldata /* state */,\n        bool /* hasUnderlying */,\n        State calldata /* underlyingState */\n    )\n        external\n        pure\n        override\n        returns (bool)\n    {\n        // no contract performance for CEC\n        return true;\n    }\n\n    /**\n     * @notice Implements abstract method which is defined in BaseEngine.\n     * Applies an event to the current state of the contract and returns the resulting state.\n     * The inheriting Engine contract has to map the events type to the designated STF.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which to evaluate the next state for\n     * @param externalData external data needed for STF evaluation (e.g. rate for RR events)\n     * @return the resulting contract state\n     */\n    function stateTransitionFunction(\n        CECTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n\n        if (eventType == EventType.EXE) return STF_CEC_EXE(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.MD) return STF_CEC_MD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.ST) return STF_CEC_ST(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.CE) return STF_CEC_CE(terms, state, scheduleTime, externalData);\n\n        revert(\"CECEngine.stateTransitionFunction: ATTRIBUTE_NOT_FOUND\");\n    }\n\n    /**\n     * @notice Implements abstract method which is defined in BaseEngine.\n     * Computes the payoff for an event under the current state of the contract.\n     * The inheriting Engine contract has to map the events type to the designated POF.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which the payoff should be evaluated\n     * @param externalData external data needed for POF evaluation (e.g. fxRate)\n     * @return the payoff of the event\n     */\n    function payoffFunction(\n        CECTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (int256)\n    {\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n\n        if (eventType == EventType.CE) return 0;\n        if (eventType == EventType.EXE) return 0;\n        if (eventType == EventType.ST) return POF_CEC_ST(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.MD) return 0;\n\n        revert(\"CECEngine.payoffFunction: ATTRIBUTE_NOT_FOUND\");\n    }\n}\n"
    },
    "contracts/ACTUS/Engines/CEC/CECSTF.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\n\nimport \"../../Core/Core.sol\";\nimport \"../../Core/SignedMath.sol\";\n\n\n/**\n * @title STF\n * @notice Contains all state transition functions (STFs) currently used by all Engines\n */\ncontract CECSTF is Core {\n\n    using SignedSafeMath for int;\n    using SignedMath for int;\n\n\n    /**\n     * State transition for PAM credit events\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_CEC_CE (\n        CECTerms memory /* terms */,\n        State memory state,\n        uint256 /* scheduleTime */,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns(State memory)\n    {\n        return state;\n    }\n\n    function STF_CEC_MD (\n        CECTerms memory /* terms */,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        state.notionalPrincipal = 0;\n        state.contractPerformance = ContractPerformance.MD;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    function STF_CEC_EXE (\n        CECTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent;\n        {\n            timeFromLastEvent = yearFraction(\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                terms.dayCountConvention,\n                terms.maturityDate\n            );\n        }\n        state.statusDate = scheduleTime;\n        // decode state.notionalPrincipal of underlying from externalData\n        state.exerciseAmount = terms.coverageOfCreditEnhancement.floatMult(int256(externalData));\n        state.exerciseDate = scheduleTime;\n\n        if (terms.feeBasis == FeeBasis.A) {\n            state.feeAccrued = roleSign(terms.contractRole) * terms.feeRate;\n        } else {\n            state.feeAccrued = state.feeAccrued\n            .add(\n                timeFromLastEvent\n                .floatMult(terms.feeRate)\n                .floatMult(state.notionalPrincipal)\n            );\n        }\n\n        return state;\n    }\n\n    function STF_CEC_ST (\n        CECTerms memory /* terms */,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        state.notionalPrincipal = 0;\n        state.feeAccrued = 0;\n        state.contractPerformance = ContractPerformance.MD;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n}\n"
    },
    "contracts/ACTUS/Engines/CEC/CECPOF.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\n\nimport \"../../Core/Core.sol\";\n\n\n/**\n * @title POF\n * @notice Contains all payoff functions (POFs) currently used by all Engines\n */\ncontract CECPOF is Core {\n\n    using SignedSafeMath for int;\n\n\n    /**\n     * Calculate the payoff in case of settlement\n     * @return the settlement payoff amount for CEG contracts\n     */\n    function POF_CEC_ST (\n        CECTerms memory /* terms */,\n        State memory state,\n        uint256 /* scheduleTime */,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        return state.exerciseAmount.add(state.feeAccrued);\n    }\n}\n"
    },
    "contracts/ACTUS/test/CEC/TestCECPOF.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../Engines/CEC/CECPOF.sol\";\n\n/**\n* These helper contracts expose internal functions for unit testing.\n*/\ncontract TestCECPOF is CECPOF {\n\n    function _POF_CEC_ST (\n        CECTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns(int256)\n    {\n         return POF_CEC_ST(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n}\n"
    },
    "contracts/ACTUS/test/CEC/TestCECSTF.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../Engines/CEC/CECSTF.sol\";\n\n\n/**\n* These helper contracts expose internal functions for unit testing.\n*/\ncontract TestCECSTF is CECSTF {\n\n    function _STF_CEC_CE(\n        CECTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_CEC_CE(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_CEC_MD(\n        CECTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_CEC_MD(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_CEC_EXE(\n        CECTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_CEC_EXE(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_CEC_ST(\n        CECTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_CEC_ST(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n\n}\n"
    },
    "contracts/ACTUS/Engines/ANN/IANNEngine.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../Core/ACTUSTypes.sol\";\nimport \"../IEngine.sol\";\n\n\n/**\n * @title IEngine\n * @notice Interface which all Engines have to implement\n */\ninterface IANNEngine is IEngine {\n\n    /**\n     * @notice Initialize contract state space based on the contract terms.\n     * @param terms terms of the contract\n     * @return initial state of the contract\n     */\n    function computeInitialState(ANNTerms calldata terms)\n        external\n        pure\n        returns (State memory);\n\n    /**\n     * Applys an event to the current state of a contract and returns the resulting contract state.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event to be applied to the contract state\n     * @param externalData external data needed for STF evaluation (e.g. rate for RR events)\n     * @return the resulting contract state\n     */\n    function computeStateForEvent(\n        ANNTerms calldata terms,\n        State calldata state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        external\n        pure\n        returns (State memory);\n\n    /**\n     * Evaluates the payoff for an event under the current state of the contract.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which the payoff should be evaluated\n     * @param externalData external data needed for POF evaluation (e.g. fxRate)\n     * @return the payoff of the event\n     */\n    function computePayoffForEvent(\n        ANNTerms calldata terms,\n        State calldata state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        external\n        pure\n        returns (int256);\n\n    /**\n     * @notice Computes a schedule segment of non-cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @return segment of the non-cyclic schedule\n     */\n    function computeNonCyclicScheduleSegment(\n        ANNTerms calldata terms,\n        uint256 segmentStart,\n        uint256 segmentEnd\n    )\n        external\n        pure\n        returns (bytes32[] memory);\n\n    /**\n     * @notice Computes a schedule segment of cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @param eventType eventType of the cyclic schedule\n     * @return event schedule segment\n     */\n    function computeCyclicScheduleSegment(\n        ANNTerms calldata terms,\n        uint256 segmentStart,\n        uint256 segmentEnd,\n        EventType eventType\n    )\n        external\n        pure\n        returns (bytes32[] memory);\n\n    /**\n     * @notice Computes the next non-cyclic contract events based on the contract terms\n     * and the timestamp on which the prev. event occured.\n     * @dev Assumes that non-cyclic events of the same event type have a unique schedule time\n     * @param terms terms of the contract\n     * @param lastNonCyclicEvent last non-cyclic event\n     * @return next non-cyclic event\n     */\n    function computeNextNonCyclicEvent(\n        ANNTerms calldata terms,\n        bytes32 lastNonCyclicEvent\n    )\n        external\n        pure\n        returns (bytes32);\n\n    /**\n     * @notice Computes a schedule segment of cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param lastScheduleTime last occurrence of cyclic event\n     * @param eventType eventType of the cyclic schedule\n     * @return event schedule segment\n     */\n    function computeNextCyclicEvent(\n        ANNTerms calldata terms,\n        uint256 lastScheduleTime,\n        EventType eventType\n    )\n        external\n        pure\n        returns(bytes32);\n\n    /**\n     * @notice Verifies that the provided event is still scheduled under the terms, the current state of the\n     * contract and the current state of the underlying.\n     * @param _event event for which to check if its still scheduled\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param hasUnderlying boolean indicating whether the contract has an underlying contract\n     * @param underlyingState state of the underlying (empty state object if non-existing)\n     * @return boolean indicating whether event is still scheduled\n     */\n    function isEventScheduled(\n        bytes32 _event,\n        ANNTerms calldata terms,\n        State calldata state,\n        bool hasUnderlying,\n        State calldata underlyingState\n    )\n        external\n        pure\n        returns (bool);\n}\n"
    },
    "contracts/Core/ANN/ANNRegistry.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../ACTUS/Engines/ANN/IANNEngine.sol\";\n\nimport \"../Base/SharedTypes.sol\";\nimport \"../Base/AssetRegistry/BaseRegistry.sol\";\nimport \"./ANNEncoder.sol\";\nimport \"./IANNRegistry.sol\";\n\n\n/**\n * @title ANNRegistry\n * @notice Registry for ACTUS Protocol assets\n */\ncontract ANNRegistry is BaseRegistry, IANNRegistry {\n\n    using ANNEncoder for Asset;\n\n\n    constructor() BaseRegistry() {}\n\n    /**\n     * @notice\n     * @param assetId id of the asset\n     * @param terms asset specific terms (ANNTerms)\n     * @param state initial state of the asset\n     * @param schedule schedule of the asset\n     * @param ownership ownership of the asset\n     * @param engine ACTUS Engine of the asset\n     * @param actor account which is allowed to update the asset state\n     * @param admin account which as admin rights (optional)\n     */\n    function registerAsset(\n        bytes32 assetId,\n        ANNTerms calldata terms,\n        State calldata state,\n        bytes32[] calldata schedule,\n        AssetOwnership calldata ownership,\n        address engine,\n        address actor,\n        address admin\n    )\n        external\n        override\n        onlyApprovedActors\n    {\n        setAsset(assetId, state, schedule, ownership, engine, actor, admin);\n        assets[assetId].encodeAndSetANNTerms(terms);\n    }\n\n    /**\n     * @notice Returns the terms of an asset.\n     * @param assetId id of the asset\n     * @return terms of the asset\n     */\n    function getTerms(bytes32 assetId)\n        external\n        view\n        override\n        returns (ANNTerms memory)\n    {\n        return assets[assetId].decodeAndGetANNTerms();\n    }\n\n    /**\n     * @notice Set the terms of the asset\n     * @dev Can only be set by authorized account.\n     * @param assetId id of the asset\n     * @param terms new terms\n     */\n    function setTerms(bytes32 assetId, ANNTerms calldata terms)\n        external\n        override\n        isAuthorized (assetId)\n    {\n        assets[assetId].encodeAndSetANNTerms(terms);\n        emit UpdatedTerms(assetId);\n    }\n\n    function getEnumValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (uint8)\n    {\n        return assets[assetId].decodeAndGetEnumValueForANNAttribute(attribute);\n    }\n\n    function getAddressValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (address)\n    {\n        return assets[assetId].decodeAndGetAddressValueForForANNAttribute(attribute);\n    }\n\n    function getBytes32ValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (bytes32)\n    {\n        return assets[assetId].decodeAndGetBytes32ValueForForANNAttribute(attribute);\n    }\n\n    function getUIntValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (uint256)\n    {\n        return assets[assetId].decodeAndGetUIntValueForForANNAttribute(attribute);\n    }\n\n    function getIntValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (int256)\n    {\n        return assets[assetId].decodeAndGetIntValueForForANNAttribute(attribute);\n    }\n\n    function getPeriodValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (IP memory)\n    {\n        return assets[assetId].decodeAndGetPeriodValueForForANNAttribute(attribute);\n    }\n\n    function getCycleValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (IPS memory)\n    {\n        return assets[assetId].decodeAndGetCycleValueForForANNAttribute(attribute);\n    }\n\n    function getContractReferenceValueForTermsAttribute(bytes32 assetId, bytes32 attribute)\n        public\n        view\n        override(ITermsRegistry, TermsRegistry)\n        returns (ContractReference memory)\n    {\n        return assets[assetId].decodeAndGetContractReferenceValueForANNAttribute(attribute);\n    } \n\n    function getNextComputedEvent(bytes32 assetId)\n        internal\n        view\n        override(TermsRegistry)\n        returns (bytes32, bool)\n    {\n        Asset storage asset = assets[assetId];\n        ANNTerms memory terms = asset.decodeAndGetANNTerms();\n\n        EventType nextEventType;\n        uint256 nextScheduleTime;\n        bool isCyclicEvent = true;\n\n        // IP\n        {\n            (EventType eventType, uint256 scheduleTime) = decodeEvent(IANNEngine(asset.engine).computeNextCyclicEvent(\n                terms,\n                asset.schedule.lastScheduleTimeOfCyclicEvent[EventType.IP],\n                EventType.IP\n            ));\n\n            if (\n                (nextScheduleTime == 0)\n                || (scheduleTime < nextScheduleTime)\n                || (nextScheduleTime == scheduleTime && getEpochOffset(eventType) < getEpochOffset(nextEventType))\n            ) {\n                nextScheduleTime = scheduleTime;\n                nextEventType = eventType;\n            }        \n        }\n\n        // IPCI\n        {\n            (EventType eventType, uint256 scheduleTime) = decodeEvent(IANNEngine(asset.engine).computeNextCyclicEvent(\n                terms,\n                asset.schedule.lastScheduleTimeOfCyclicEvent[EventType.IPCI],\n                EventType.IPCI\n            ));\n\n            if (\n                (nextScheduleTime == 0)\n                || (scheduleTime != 0 && scheduleTime < nextScheduleTime)\n                || (scheduleTime != 0 && nextScheduleTime == scheduleTime && getEpochOffset(eventType) < getEpochOffset(nextEventType))\n            ) {\n                nextScheduleTime = scheduleTime;\n                nextEventType = eventType;\n            }        \n        }\n\n        // FP\n        {\n            (EventType eventType, uint256 scheduleTime) = decodeEvent(IANNEngine(asset.engine).computeNextCyclicEvent(\n                terms,\n                asset.schedule.lastScheduleTimeOfCyclicEvent[EventType.FP],\n                EventType.FP\n            ));\n\n            if (\n                (nextScheduleTime == 0)\n                || (scheduleTime != 0 && scheduleTime < nextScheduleTime)\n                || (scheduleTime != 0 && nextScheduleTime == scheduleTime && getEpochOffset(eventType) < getEpochOffset(nextEventType))\n            ) {\n                nextScheduleTime = scheduleTime;\n                nextEventType = eventType;\n            }        \n        }\n\n        // PR\n        {\n            (EventType eventType, uint256 scheduleTime) = decodeEvent(IANNEngine(asset.engine).computeNextCyclicEvent(\n                terms,\n                asset.schedule.lastScheduleTimeOfCyclicEvent[EventType.PR],\n                EventType.PR\n            ));\n\n            if (\n                (nextScheduleTime == 0)\n                || (scheduleTime != 0 && scheduleTime < nextScheduleTime)\n                || (scheduleTime != 0 && nextScheduleTime == scheduleTime && getEpochOffset(eventType) < getEpochOffset(nextEventType))\n            ) {\n                nextScheduleTime = scheduleTime;\n                nextEventType = eventType;\n            }        \n        }\n\n        // Non-Cyclic\n        {\n            (EventType eventType, uint256 scheduleTime) = decodeEvent(IANNEngine(asset.engine).computeNextNonCyclicEvent(\n                terms,\n                asset.schedule.lastNonCyclicEvent\n            ));\n\n            if (\n                (nextScheduleTime == 0)\n                || (scheduleTime != 0 && scheduleTime < nextScheduleTime)\n                || (scheduleTime != 0 && nextScheduleTime == scheduleTime && getEpochOffset(eventType) < getEpochOffset(nextEventType))\n            ) {\n                nextScheduleTime = scheduleTime;\n                nextEventType = eventType;\n                isCyclicEvent = false;\n            }        \n        }\n\n        return (encodeEvent(nextEventType, nextScheduleTime), isCyclicEvent);\n    }\n}\n"
    },
    "contracts/Core/ANN/ANNEncoder.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../Base/SharedTypes.sol\";\nimport \"../Base/AssetRegistry/BaseRegistryStorage.sol\";\n\n\nlibrary ANNEncoder {\n\n    function storeInPackedTerms(Asset storage asset, bytes32 attributeKey, bytes32 value) private {\n        // skip if value did not change\n        if (asset.packedTerms[attributeKey] == value) return;\n        asset.packedTerms[attributeKey] = value;\n    }\n    \n    /**\n     * @dev Tightly pack and store only non-zero overwritten terms (LifecycleTerms)\n     * @notice All non zero values of the overwrittenTerms object are stored.\n     * It does not check if overwrittenAttributesMap actually marks attribute as overwritten.\n     */\n    function encodeAndSetANNTerms(Asset storage asset, ANNTerms memory terms) external {\n        storeInPackedTerms(\n            asset,\n            \"enums\",\n            bytes32(uint256(uint8(terms.contractType))) << 248 |\n            bytes32(uint256(uint8(terms.calendar))) << 240 |\n            bytes32(uint256(uint8(terms.contractRole))) << 232 |\n            bytes32(uint256(uint8(terms.dayCountConvention))) << 224 |\n            bytes32(uint256(uint8(terms.businessDayConvention))) << 216 |\n            bytes32(uint256(uint8(terms.endOfMonthConvention))) << 208 |\n            bytes32(uint256(uint8(terms.scalingEffect))) << 200 |\n            bytes32(uint256(uint8(terms.feeBasis))) << 192\n        );\n\n        storeInPackedTerms(asset, \"currency\", bytes32(uint256(terms.currency) << 96));\n        storeInPackedTerms(asset, \"settlementCurrency\", bytes32(uint256(terms.settlementCurrency) << 96));\n\n        storeInPackedTerms(asset, \"marketObjectCodeRateReset\", bytes32(terms.marketObjectCodeRateReset));\n\n        storeInPackedTerms(asset, \"statusDate\", bytes32(terms.statusDate));\n        storeInPackedTerms(asset, \"initialExchangeDate\", bytes32(terms.initialExchangeDate));\n        storeInPackedTerms(asset, \"maturityDate\", bytes32(terms.maturityDate));\n        storeInPackedTerms(asset, \"issueDate\", bytes32(terms.issueDate));\n        storeInPackedTerms(asset, \"purchaseDate\", bytes32(terms.purchaseDate));\n        storeInPackedTerms(asset, \"capitalizationEndDate\", bytes32(terms.capitalizationEndDate));\n        storeInPackedTerms(asset, \"cycleAnchorDateOfInterestPayment\", bytes32(terms.cycleAnchorDateOfInterestPayment));\n        storeInPackedTerms(asset, \"cycleAnchorDateOfRateReset\", bytes32(terms.cycleAnchorDateOfRateReset));\n        storeInPackedTerms(asset, \"cycleAnchorDateOfScalingIndex\", bytes32(terms.cycleAnchorDateOfScalingIndex));\n        storeInPackedTerms(asset, \"cycleAnchorDateOfFee\", bytes32(terms.cycleAnchorDateOfFee));\n        storeInPackedTerms(asset, \"cycleAnchorDateOfPrincipalRedemp\", bytes32(terms.cycleAnchorDateOfPrincipalRedemption));\n\n        storeInPackedTerms(asset, \"notionalPrincipal\", bytes32(terms.notionalPrincipal));\n        storeInPackedTerms(asset, \"nominalInterestRate\", bytes32(terms.nominalInterestRate));\n        storeInPackedTerms(asset, \"accruedInterest\", bytes32(terms.accruedInterest));\n        storeInPackedTerms(asset, \"rateMultiplier\", bytes32(terms.rateMultiplier));\n        storeInPackedTerms(asset, \"rateSpread\", bytes32(terms.rateSpread));\n        storeInPackedTerms(asset, \"nextResetRate\", bytes32(terms.nextResetRate));\n        storeInPackedTerms(asset, \"feeRate\", bytes32(terms.feeRate));\n        storeInPackedTerms(asset, \"feeAccrued\", bytes32(terms.feeAccrued));\n        storeInPackedTerms(asset, \"premiumDiscountAtIED\", bytes32(terms.premiumDiscountAtIED));\n        storeInPackedTerms(asset, \"priceAtPurchaseDate\", bytes32(terms.priceAtPurchaseDate));\n        storeInPackedTerms(asset, \"priceAtTerminationDate\", bytes32(terms.priceAtTerminationDate));\n        storeInPackedTerms(asset, \"nextPrincipalRedemptionPayment\", bytes32(terms.nextPrincipalRedemptionPayment));\n        storeInPackedTerms(asset, \"lifeCap\", bytes32(terms.lifeCap));\n        storeInPackedTerms(asset, \"lifeFloor\", bytes32(terms.lifeFloor));\n        storeInPackedTerms(asset, \"periodCap\", bytes32(terms.periodCap));\n        storeInPackedTerms(asset, \"periodFloor\", bytes32(terms.periodFloor));\n\n        storeInPackedTerms(\n            asset,\n            \"gracePeriod\",\n            bytes32(uint256(terms.gracePeriod.i)) << 24 |\n            bytes32(uint256(terms.gracePeriod.p)) << 16 |\n            bytes32(uint256((terms.gracePeriod.isSet) ? 1 : 0)) << 8\n        );\n        storeInPackedTerms(\n            asset,\n            \"delinquencyPeriod\",\n            bytes32(uint256(terms.delinquencyPeriod.i)) << 24 |\n            bytes32(uint256(terms.delinquencyPeriod.p)) << 16 |\n            bytes32(uint256((terms.delinquencyPeriod.isSet) ? 1 : 0)) << 8\n        );\n\n        storeInPackedTerms(\n            asset,\n            \"cycleOfInterestPayment\",\n            bytes32(uint256(terms.cycleOfInterestPayment.i)) << 24 |\n            bytes32(uint256(terms.cycleOfInterestPayment.p)) << 16 |\n            bytes32(uint256(terms.cycleOfInterestPayment.s)) << 8 |\n            bytes32(uint256((terms.cycleOfInterestPayment.isSet) ? 1 : 0))\n        );\n        storeInPackedTerms(\n            asset,\n            \"cycleOfRateReset\",\n            bytes32(uint256(terms.cycleOfRateReset.i)) << 24 |\n            bytes32(uint256(terms.cycleOfRateReset.p)) << 16 |\n            bytes32(uint256(terms.cycleOfRateReset.s)) << 8 |\n            bytes32(uint256((terms.cycleOfRateReset.isSet) ? 1 : 0))\n        );\n        storeInPackedTerms(\n            asset,\n            \"cycleOfScalingIndex\",\n            bytes32(uint256(terms.cycleOfScalingIndex.i)) << 24 |\n            bytes32(uint256(terms.cycleOfScalingIndex.p)) << 16 |\n            bytes32(uint256(terms.cycleOfScalingIndex.s)) << 8 |\n            bytes32(uint256((terms.cycleOfScalingIndex.isSet) ? 1 : 0))\n        );\n        storeInPackedTerms(\n            asset,\n            \"cycleOfFee\",\n            bytes32(uint256(terms.cycleOfFee.i)) << 24 |\n            bytes32(uint256(terms.cycleOfFee.p)) << 16 |\n            bytes32(uint256(terms.cycleOfFee.s)) << 8 |\n            bytes32(uint256((terms.cycleOfFee.isSet) ? 1 : 0))\n        );\n        storeInPackedTerms(\n            asset,\n            \"cycleOfPrincipalRedemption\",\n            bytes32(uint256(terms.cycleOfPrincipalRedemption.i)) << 24 |\n            bytes32(uint256(terms.cycleOfPrincipalRedemption.p)) << 16 |\n            bytes32(uint256(terms.cycleOfPrincipalRedemption.s)) << 8 |\n            bytes32(uint256((terms.cycleOfPrincipalRedemption.isSet) ? 1 : 0))\n        );\n    }\n\n    /**\n     * @dev Decode and loads ANNTerms\n     */\n    function decodeAndGetANNTerms(Asset storage asset) external view returns (ANNTerms memory) {\n        return ANNTerms(\n            ContractType(uint8(uint256(asset.packedTerms[\"enums\"] >> 248))),\n            Calendar(uint8(uint256(asset.packedTerms[\"enums\"] >> 240))),\n            ContractRole(uint8(uint256(asset.packedTerms[\"enums\"] >> 232))),\n            DayCountConvention(uint8(uint256(asset.packedTerms[\"enums\"] >> 224))),\n            BusinessDayConvention(uint8(uint256(asset.packedTerms[\"enums\"] >> 216))),\n            EndOfMonthConvention(uint8(uint256(asset.packedTerms[\"enums\"] >> 208))),\n            ScalingEffect(uint8(uint256(asset.packedTerms[\"enums\"] >> 200))),\n            FeeBasis(uint8(uint256(asset.packedTerms[\"enums\"] >> 192))),\n\n            address(uint160(uint256(asset.packedTerms[\"currency\"]) >> 96)),\n            address(uint160(uint256(asset.packedTerms[\"settlementCurrency\"]) >> 96)),\n\n            asset.packedTerms[\"marketObjectCodeRateReset\"],\n\n            uint256(asset.packedTerms[\"statusDate\"]),\n            uint256(asset.packedTerms[\"initialExchangeDate\"]),\n            uint256(asset.packedTerms[\"maturityDate\"]),\n            uint256(asset.packedTerms[\"issueDate\"]),\n            uint256(asset.packedTerms[\"purchaseDate\"]),\n            uint256(asset.packedTerms[\"capitalizationEndDate\"]),\n            uint256(asset.packedTerms[\"cycleAnchorDateOfInterestPayment\"]),\n            uint256(asset.packedTerms[\"cycleAnchorDateOfRateReset\"]),\n            uint256(asset.packedTerms[\"cycleAnchorDateOfScalingIndex\"]),\n            uint256(asset.packedTerms[\"cycleAnchorDateOfFee\"]),\n            uint256(asset.packedTerms[\"cycleAnchorDateOfPrincipalRedemp\"]),\n\n            int256(asset.packedTerms[\"notionalPrincipal\"]),\n            int256(asset.packedTerms[\"nominalInterestRate\"]),\n            int256(asset.packedTerms[\"accruedInterest\"]),\n            int256(asset.packedTerms[\"rateMultiplier\"]),\n            int256(asset.packedTerms[\"rateSpread\"]),\n            int256(asset.packedTerms[\"nextResetRate\"]),\n            int256(asset.packedTerms[\"feeRate\"]),\n            int256(asset.packedTerms[\"feeAccrued\"]),\n            int256(asset.packedTerms[\"premiumDiscountAtIED\"]),\n            int256(asset.packedTerms[\"priceAtPurchaseDate\"]),\n            int256(asset.packedTerms[\"priceAtTerminationDate\"]),\n            int256(asset.packedTerms[\"nextPrincipalRedemptionPayment\"]),\n            int256(asset.packedTerms[\"lifeCap\"]),\n            int256(asset.packedTerms[\"lifeFloor\"]),\n            int256(asset.packedTerms[\"periodCap\"]),\n            int256(asset.packedTerms[\"periodFloor\"]),\n            \n            IP(\n                uint256(asset.packedTerms[\"gracePeriod\"] >> 24),\n                P(uint8(uint256(asset.packedTerms[\"gracePeriod\"] >> 16))),\n                (asset.packedTerms[\"gracePeriod\"] >> 8 & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            ),\n            IP(\n                uint256(asset.packedTerms[\"delinquencyPeriod\"] >> 24),\n                P(uint8(uint256(asset.packedTerms[\"delinquencyPeriod\"] >> 16))),\n                (asset.packedTerms[\"delinquencyPeriod\"] >> 8 & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            ),\n\n            IPS(\n                uint256(asset.packedTerms[\"cycleOfInterestPayment\"] >> 24),\n                P(uint8(uint256(asset.packedTerms[\"cycleOfInterestPayment\"] >> 16))),\n                S(uint8(uint256(asset.packedTerms[\"cycleOfInterestPayment\"] >> 8))),\n                (asset.packedTerms[\"cycleOfInterestPayment\"] & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            ),\n            IPS(\n                uint256(asset.packedTerms[\"cycleOfRateReset\"] >> 24),\n                P(uint8(uint256(asset.packedTerms[\"cycleOfRateReset\"] >> 16))),\n                S(uint8(uint256(asset.packedTerms[\"cycleOfRateReset\"] >> 8))),\n                (asset.packedTerms[\"cycleOfRateReset\"] & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            ),\n            IPS(\n                uint256(asset.packedTerms[\"cycleOfScalingIndex\"] >> 24),\n                P(uint8(uint256(asset.packedTerms[\"cycleOfScalingIndex\"] >> 16))),\n                S(uint8(uint256(asset.packedTerms[\"cycleOfScalingIndex\"] >> 8))),\n                (asset.packedTerms[\"cycleOfScalingIndex\"] & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            ),\n            IPS(\n                uint256(asset.packedTerms[\"cycleOfFee\"] >> 24),\n                P(uint8(uint256(asset.packedTerms[\"cycleOfFee\"] >> 16))),\n                S(uint8(uint256(asset.packedTerms[\"cycleOfFee\"] >> 8))),\n                (asset.packedTerms[\"cycleOfFee\"] & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            ),\n            IPS(\n                uint256(asset.packedTerms[\"cycleOfPrincipalRedemption\"] >> 24),\n                P(uint8(uint256(asset.packedTerms[\"cycleOfPrincipalRedemption\"] >> 16))),\n                S(uint8(uint256(asset.packedTerms[\"cycleOfPrincipalRedemption\"] >> 8))),\n                (asset.packedTerms[\"cycleOfPrincipalRedemption\"] & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            )\n        );\n    }\n\n    function decodeAndGetEnumValueForANNAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (uint8)\n    {\n        if (attributeKey == \"contractType\") {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 248));\n        } else if (attributeKey == bytes32(\"calendar\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 240));\n        } else if (attributeKey == bytes32(\"contractRole\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 232));\n        } else if (attributeKey == bytes32(\"dayCountConvention\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 224));\n        } else if (attributeKey == bytes32(\"businessDayConvention\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 216));\n        } else if (attributeKey == bytes32(\"endOfMonthConvention\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 208));\n        } else if (attributeKey == bytes32(\"scalingEffect\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 200));\n        } else if (attributeKey == bytes32(\"feeBasis\")) {\n            return uint8(uint256(asset.packedTerms[\"enums\"] >> 192));\n        } else {\n            return uint8(0);\n        }\n    }\n\n    function decodeAndGetAddressValueForForANNAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (address)\n    {\n        if (attributeKey == bytes32(\"currency\")) {\n            return address(uint160(uint256(asset.packedTerms[\"currency\"]) >> 96));\n        } else if (attributeKey == bytes32(\"settlementCurrency\")) {\n            return address(uint160(uint256(asset.packedTerms[\"settlementCurrency\"]) >> 96));\n        } else {\n            return address(0);\n        }   \n    }\n\n    function decodeAndGetBytes32ValueForForANNAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (bytes32)\n    {\n        return asset.packedTerms[attributeKey];\n    }\n\n    function decodeAndGetUIntValueForForANNAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (uint256)\n    {\n        return uint256(asset.packedTerms[attributeKey]);\n    }\n\n    function decodeAndGetIntValueForForANNAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (int256)\n    {\n        return int256(asset.packedTerms[attributeKey]);\n    }\n\n    function decodeAndGetPeriodValueForForANNAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (IP memory)\n    {\n        if (\n            attributeKey == bytes32(\"gracePeriod\")\n            || attributeKey == bytes32(\"delinquencyPeriod\")\n        ) {\n            return IP(\n                uint256(asset.packedTerms[attributeKey] >> 24),\n                P(uint8(uint256(asset.packedTerms[attributeKey] >> 16))),\n                (asset.packedTerms[attributeKey] >> 8 & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            );\n        } else {\n            return IP(0, P(0), false);\n        }\n    }\n\n    function decodeAndGetCycleValueForForANNAttribute(Asset storage asset, bytes32 attributeKey)\n        external\n        view\n        returns (IPS memory)\n    {\n        if (\n            attributeKey == bytes32(\"cycleOfInterestPayment\")\n            || attributeKey == bytes32(\"cycleRateReset\")\n            || attributeKey == bytes32(\"cycleScalingIndex\")\n            || attributeKey == bytes32(\"cycleFee\")\n            || attributeKey == bytes32(\"cycleOfPrincipalRedemption\")\n        ) {\n            return IPS(\n                uint256(asset.packedTerms[attributeKey] >> 24),\n                P(uint8(uint256(asset.packedTerms[attributeKey] >> 16))),\n                S(uint8(uint256(asset.packedTerms[attributeKey] >> 8))),\n                (asset.packedTerms[attributeKey] & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            );\n        } else {\n            return IPS(0, P(0), S(0), false);\n        }\n    }\n\n    function decodeAndGetContractReferenceValueForANNAttribute(Asset storage /* asset */, bytes32 /* attributeKey */)\n        external\n        pure\n        returns (ContractReference memory)\n    {\n        return ContractReference(\n            bytes32(0),\n            bytes32(0),\n            ContractReferenceType(0),\n            ContractReferenceRole(0)\n        );\n    }\n}"
    },
    "contracts/Core/ANN/IANNRegistry.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../Base/SharedTypes.sol\";\nimport \"../Base/AssetRegistry/IAssetRegistry.sol\";\n\n\ninterface IANNRegistry is IAssetRegistry {\n\n    function registerAsset(\n        bytes32 assetId,\n        ANNTerms calldata terms,\n        State calldata state,\n        bytes32[] calldata schedule,\n        AssetOwnership calldata ownership,\n        address engine,\n        address actor,\n        address admin\n    )\n        external;\n\n    function getTerms(bytes32 assetId)\n        external\n        view\n        returns (ANNTerms memory);\n\n    function setTerms(bytes32 assetId, ANNTerms calldata terms)\n        external;\n}\n"
    },
    "contracts/Core/ANN/ANNActor.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../ACTUS/Engines/ANN/IANNEngine.sol\";\n\nimport \"../Base/AssetActor/BaseActor.sol\";\nimport \"./IANNRegistry.sol\";\n\n\n/**\n * @title ANNActor\n * @notice TODO\n */\ncontract ANNActor is BaseActor {\n\n    constructor(IAssetRegistry assetRegistry, IOracleProxy defaultOracleProxy) BaseActor(assetRegistry, defaultOracleProxy) {}\n\n    /**\n     * @notice Derives initial state of the asset terms and stores together with\n     * terms, schedule, ownership, engine, admin of the asset in the contract types specific AssetRegistry.\n     * @param terms asset specific terms\n     * @param schedule schedule of the asset\n     * @param ownership ownership of the asset\n     * @param engine address of the ACTUS engine used for the spec. ContractType\n     * @param admin address of the admin of the asset (optional)\n     */\n    function initialize(\n        ANNTerms calldata terms,\n        bytes32[] calldata schedule,\n        AssetOwnership calldata ownership,\n        address engine,\n        address admin\n    )\n        external\n    {\n        require(\n            engine != address(0) && IEngine(engine).contractType() == ContractType.ANN,\n            \"ANNActor.initialize: CONTRACT_TYPE_OF_ENGINE_UNSUPPORTED\"\n        );\n\n        // solium-disable-next-line\n        bytes32 assetId = keccak256(abi.encode(terms, block.timestamp));\n\n        // compute the initial state of the asset\n        State memory initialState = IANNEngine(engine).computeInitialState(terms);\n\n        // register the asset in the AssetRegistry\n        IANNRegistry(address(assetRegistry)).registerAsset(\n            assetId,\n            terms,\n            initialState,\n            schedule,\n            ownership,\n            engine,\n            address(this),\n            admin\n        );\n\n        emit InitializedAsset(assetId, ContractType.ANN, ownership.creatorObligor, ownership.counterpartyObligor);\n    }\n\n    function computeStateAndPayoffForEvent(bytes32 assetId, State memory state, bytes32 _event)\n        internal\n        view\n        override\n        returns (State memory, int256)\n    {\n        // ContractType contractType = ContractType(assetRegistry.getEnumValueForTermsAttribute(assetId, \"contractType\"));        \n        // revert(\"ANNActor.computePayoffAndStateForEvent: UNSUPPORTED_CONTRACT_TYPE\");\n\n        address engine = assetRegistry.getEngine(assetId);\n        ANNTerms memory terms = IANNRegistry(address(assetRegistry)).getTerms(assetId);\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n\n        int256 payoff = IANNEngine(engine).computePayoffForEvent(\n            terms,\n            state,\n            _event,\n            getExternalDataForPOF(\n                assetId,\n                eventType,\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate)\n            )\n        );\n        state = IANNEngine(engine).computeStateForEvent(\n            terms,\n            state,\n            _event,\n            getExternalDataForSTF(\n                assetId,\n                eventType,\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate)\n            )\n        );\n\n        return (state, payoff);\n    }\n\n    /**\n     * @notice Retrieves external data (such as market object data, block time, underlying asset state)\n     * used for evaluating the STF for a given event.\n     */\n    function getExternalDataForSTF(\n        bytes32 assetId,\n        EventType eventType,\n        uint256 timestamp\n    )\n        internal\n        view\n        override\n        returns (bytes32)\n    {\n        if (eventType == EventType.RR) {\n            // get rate from DataRegistry\n            (int256 resetRate, bool isSet) = defaultOracleProxy.getDataPoint(\n                assetRegistry.getBytes32ValueForTermsAttribute(assetId, \"marketObjectCodeRateReset\"),\n                timestamp\n            );\n            if (isSet) return bytes32(resetRate);\n        } else if (eventType == EventType.CE) {\n            // get current timestamp\n            // solium-disable-next-line\n            return bytes32(block.timestamp);\n        }\n\n        return bytes32(0);\n    }\n}"
    },
    "contracts/ACTUS/Engines/ANN/ANNEngine.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\n\nimport \"../../Core/Core.sol\";\nimport \"../../Core/SignedMath.sol\";\nimport \"./IANNEngine.sol\";\nimport \"./ANNSTF.sol\";\nimport \"./ANNPOF.sol\";\n\n\n/**\n * @title ANNEngine\n * @notice Inherits from BaseEngine by implementing STFs, POFs according to the ACTUS standard for a ANN contract\n * @dev All numbers except unix timestamp are represented as multiple of 10 ** 18\n */\ncontract ANNEngine is Core, ANNSTF, ANNPOF, IANNEngine {\n\n    using SignedSafeMath for int;\n    using SignedMath for int;\n\n\n    function contractType() external pure override returns (ContractType) {\n        return ContractType.ANN;\n    }\n\n    /**\n     * Applys an event to the current state of a contract and returns the resulting contract state.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event to be applied to the contract state\n     * @param externalData external data needed for STF evaluation (e.g. rate for RR events)\n     * @return the resulting contract state\n     */\n    function computeStateForEvent(\n        ANNTerms calldata terms,\n        State calldata state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        external\n        pure\n        override\n        returns (State memory)\n    {\n        return stateTransitionFunction(\n            terms,\n            state,\n            _event,\n            externalData\n        );\n    }\n\n    /**\n     * Evaluates the payoff for an event under the current state of the contract.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which the payoff should be evaluated\n     * @param externalData external data needed for POF evaluation (e.g. fxRate)\n     * @return the payoff of the event\n     */\n    function computePayoffForEvent(\n        ANNTerms calldata terms,\n        State calldata state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        external\n        pure\n        override\n        returns (int256)\n    {\n        // if alternative settlementCurrency is set then apply fxRate to payoff\n        if (terms.settlementCurrency != address(0) && terms.currency != terms.settlementCurrency) {\n            return payoffFunction(\n                terms,\n                state,\n                _event,\n                externalData\n            ).floatMult(int256(externalData));\n        }\n\n        return payoffFunction(\n            terms,\n            state,\n            _event,\n            externalData\n        );\n    }\n\n    /**\n     * @notice Initialize contract state space based on the contract terms.\n     * todo implement annuity calculator\n     * @param terms terms of the contract\n     * @return initial state of the contract\n     */\n    function computeInitialState(ANNTerms calldata terms)\n        external\n        pure\n        override\n        returns (State memory)\n    {\n        State memory state;\n\n        state.contractPerformance = ContractPerformance.PF;\n        state.notionalScalingMultiplier = ONE_POINT_ZERO;\n        state.interestScalingMultiplier = ONE_POINT_ZERO;\n        state.statusDate = terms.statusDate;\n        state.maturityDate = terms.maturityDate;\n        state.notionalPrincipal = roleSign(terms.contractRole) * terms.notionalPrincipal;\n        state.nominalInterestRate = terms.nominalInterestRate;\n        state.accruedInterest = roleSign(terms.contractRole) * terms.accruedInterest;\n        state.feeAccrued = terms.feeAccrued;\n        // annuity calculator to be implemented\n        state.nextPrincipalRedemptionPayment = roleSign(terms.contractRole) * terms.nextPrincipalRedemptionPayment;\n\n        return state;\n    }\n\n    /**\n     * @notice Computes a schedule segment of non-cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * todo rate reset, scaling, interest calculation base\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @return segment of the non-cyclic schedule\n     */\n    function computeNonCyclicScheduleSegment(\n        ANNTerms calldata terms,\n        uint256 segmentStart,\n        uint256 segmentEnd\n    )\n        external\n        pure\n        override\n        returns (bytes32[] memory)\n    {\n        bytes32[MAX_EVENT_SCHEDULE_SIZE] memory events;\n        uint16 index;\n\n        // issuance\n        if (terms.issueDate != 0) {\n            if (isInSegment(terms.issueDate, segmentStart, segmentEnd)) {\n                events[index] = encodeEvent(EventType.ISS, terms.issueDate);\n                index++;\n            }\n        }\n        \n        // initial exchange\n        if (isInSegment(terms.initialExchangeDate, segmentStart, segmentEnd)) {\n            events[index] = encodeEvent(EventType.IED, terms.initialExchangeDate);\n            index++;\n        }\n\n        // purchase\n        if (terms.purchaseDate != 0) {\n            if (isInSegment(terms.purchaseDate, segmentStart, segmentEnd)) {\n                events[index] = encodeEvent(EventType.PRD, terms.purchaseDate);\n                index++;\n            }\n        }\n\n        // principal redemption at maturity\n        if (isInSegment(terms.maturityDate, segmentStart, segmentEnd) == true)  {\n            events[index] = encodeEvent(EventType.MD, terms.maturityDate);\n            index++;\n        }\n\n        // remove null entries from returned array\n        bytes32[] memory schedule = new bytes32[](index);\n        for (uint256 i = 0; i < index; i++) {\n            schedule[i] = events[i];\n        }\n\n        return schedule;\n    }\n\n    /**\n     * @notice Computes a schedule segment of cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @param eventType eventType of the cyclic schedule\n     * @return event schedule segment\n     */\n    function computeCyclicScheduleSegment(\n        ANNTerms calldata terms,\n        uint256 segmentStart,\n        uint256 segmentEnd,\n        EventType eventType\n    )\n        external\n        pure\n        override\n        returns (bytes32[] memory)\n    {\n        bytes32[MAX_EVENT_SCHEDULE_SIZE] memory events;\n        uint256 index;\n\n        // interest payment related (covers pre-repayment period only,\n        // starting with PRANX interest is paid following the PR schedule)\n        if (eventType == EventType.IP) {\n            if (terms.cycleAnchorDateOfInterestPayment != 0) {\n                uint256[MAX_CYCLE_SIZE] memory interestPaymentSchedule = computeDatesFromCycleSegment(\n                    terms.cycleAnchorDateOfInterestPayment,\n                    terms.maturityDate,\n                    terms.cycleOfInterestPayment,\n                    terms.endOfMonthConvention,\n                    true,\n                    segmentStart,\n                    segmentEnd\n                );\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\n                    if (interestPaymentSchedule[i] == 0) break;\n                    if (interestPaymentSchedule[i] <= terms.capitalizationEndDate) continue;\n                    if (isInSegment(interestPaymentSchedule[i], segmentStart, segmentEnd) == false) continue;\n                    events[index] = encodeEvent(EventType.IP, interestPaymentSchedule[i]);\n                    index++;\n                }\n            }\n        }\n\n        // IPCI\n        if (eventType == EventType.IPCI) {\n            if (\n                terms.cycleAnchorDateOfInterestPayment != 0\n                && terms.capitalizationEndDate != 0\n                && terms.capitalizationEndDate < terms.cycleAnchorDateOfPrincipalRedemption\n            ) {\n                IPS memory cycleOfInterestCapitalization = terms.cycleOfInterestPayment;\n                cycleOfInterestCapitalization.s = S.SHORT;\n\n                uint256[MAX_CYCLE_SIZE] memory interestPaymentSchedule = computeDatesFromCycleSegment(\n                    terms.cycleAnchorDateOfInterestPayment,\n                    terms.capitalizationEndDate,\n                    cycleOfInterestCapitalization,\n                    terms.endOfMonthConvention,\n                    true,\n                    segmentStart,\n                    segmentEnd\n                );\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\n                    if (interestPaymentSchedule[i] == 0) break;\n                    if (isInSegment(interestPaymentSchedule[i], segmentStart, segmentEnd) == false) continue;\n                    events[index] = encodeEvent(EventType.IPCI, interestPaymentSchedule[i]);\n                    index++;\n                }\n            }\n        }\n\n        // rate reset\n        if (eventType == EventType.RR) {\n            if (terms.cycleAnchorDateOfRateReset != 0) {\n                uint256[MAX_CYCLE_SIZE] memory rateResetSchedule = computeDatesFromCycleSegment(\n                    terms.cycleAnchorDateOfRateReset,\n                    terms.maturityDate,\n                    terms.cycleOfRateReset,\n                    terms.endOfMonthConvention,\n                    false,\n                    segmentStart,\n                    segmentEnd\n                );\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\n                    if (rateResetSchedule[i] == 0) break;\n                    if (isInSegment(rateResetSchedule[i], segmentStart, segmentEnd) == false) continue;\n                    events[index] = encodeEvent(EventType.RR, rateResetSchedule[i]);\n                    index++;\n                }\n            }\n            // ... nextRateReset\n        }\n\n        // fees\n        if (eventType == EventType.FP) {\n            if (terms.cycleAnchorDateOfFee != 0) {\n                uint256[MAX_CYCLE_SIZE] memory feeSchedule = computeDatesFromCycleSegment(\n                    terms.cycleAnchorDateOfFee,\n                    terms.maturityDate,\n                    terms.cycleOfFee,\n                    terms.endOfMonthConvention,\n                    true,\n                    segmentStart,\n                    segmentEnd\n                );\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\n                    if (feeSchedule[i] == 0) break;\n                    if (isInSegment(feeSchedule[i], segmentStart, segmentEnd) == false) continue;\n                    events[index] = encodeEvent(EventType.FP, feeSchedule[i]);\n                    index++;\n                }\n            }\n        }\n\n        // scaling\n        if (eventType == EventType.SC) {\n            if ((terms.scalingEffect != ScalingEffect._000) && terms.cycleAnchorDateOfScalingIndex != 0) {\n                uint256[MAX_CYCLE_SIZE] memory scalingSchedule = computeDatesFromCycleSegment(\n                    terms.cycleAnchorDateOfScalingIndex,\n                    terms.maturityDate,\n                    terms.cycleOfScalingIndex,\n                    terms.endOfMonthConvention,\n                    true,\n                    segmentStart,\n                    segmentEnd\n                );\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\n                    if (scalingSchedule[i] == 0) break;\n                    if (isInSegment(scalingSchedule[i], segmentStart, segmentEnd) == false) continue;\n                    events[index] = encodeEvent(EventType.SC, scalingSchedule[i]);\n                    index++;\n                }\n            }\n        }\n\n        // principal redemption\n        if (eventType == EventType.PR) {\n            if (terms.cycleAnchorDateOfPrincipalRedemption != 0) {\n                uint256[MAX_CYCLE_SIZE] memory principalRedemptionSchedule = computeDatesFromCycleSegment(\n                    terms.cycleAnchorDateOfPrincipalRedemption,\n                    terms.maturityDate,\n                    terms.cycleOfPrincipalRedemption,\n                    terms.endOfMonthConvention,\n                    false,\n                    segmentStart,\n                    segmentEnd\n                );\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\n                    if (principalRedemptionSchedule[i] == 0) break;\n                    if (isInSegment(principalRedemptionSchedule[i], segmentStart, segmentEnd) == false) continue;\n                    events[index] = encodeEvent(EventType.PR, principalRedemptionSchedule[i]);\n                    index++;\n                }\n            }\n        }\n\n        // remove null entries from returned array\n        bytes32[] memory schedule = new bytes32[](index);\n        for (uint256 i = 0; i < index; i++) {\n            schedule[i] = events[i];\n        }\n\n        return schedule;\n    }\n\n    /**\n     * @notice Computes the next non-cyclic contract events based on the contract terms\n     * and the timestamp on which the prev. event occured.\n     * @dev Assumes that non-cyclic events of the same event type have a unique schedule time\n     * @param terms terms of the contract\n     * @param lastNonCyclicEvent last non-cyclic event\n     * @return next non-cyclic event\n     */\n    function computeNextNonCyclicEvent(\n        ANNTerms calldata terms,\n        bytes32 lastNonCyclicEvent\n    )\n        external\n        pure\n        override\n        returns (bytes32)\n    {\n        (EventType lastEventType, uint256 lastScheduleTime) = decodeEvent(lastNonCyclicEvent);\n\n        EventType eventTypeNextEvent;\n        uint256 scheduleTimeNextEvent;\n\n        // EventTypes ordered after epoch offset - so we don't have make an additional epochOffset check\n\n        // issuance\n        if (\n            // date for event has to be set in terms and date of event can be in the past\n            (terms.issueDate != 0 && (lastScheduleTime <= terms.issueDate))\n            // date for event has to come before previous candidate for the next event\n            && (scheduleTimeNextEvent == 0 || terms.issueDate < scheduleTimeNextEvent)\n            // avoid endless loop by requiring that the event is not the lastNonCyclicEvent\n            && (lastScheduleTime != terms.issueDate || lastEventType != EventType.ISS)\n        ) {\n            eventTypeNextEvent = EventType.ISS;\n            scheduleTimeNextEvent = terms.issueDate;\n        }\n        \n        // initial exchange\n        if (\n            // date for event has to be set in terms and date of event can be in the past\n            (terms.initialExchangeDate != 0 && (lastScheduleTime <= terms.initialExchangeDate))\n            && (scheduleTimeNextEvent == 0 || terms.initialExchangeDate < scheduleTimeNextEvent)\n            && (lastScheduleTime != terms.initialExchangeDate || lastEventType != EventType.IED)\n        ) {\n            eventTypeNextEvent = EventType.IED;\n            scheduleTimeNextEvent = terms.initialExchangeDate;\n        }\n\n        // purchase\n        if (\n            (terms.purchaseDate != 0 && (lastScheduleTime <= terms.purchaseDate))\n            && (scheduleTimeNextEvent == 0 || terms.purchaseDate < scheduleTimeNextEvent)\n            && (lastScheduleTime != terms.purchaseDate || lastEventType != EventType.PRD)\n        ) {\n            eventTypeNextEvent = EventType.PRD;\n            scheduleTimeNextEvent = terms.purchaseDate;\n        }\n\n        // principal redemption at maturity\n        if (\n            (terms.maturityDate != 0 && (lastScheduleTime <= terms.maturityDate))\n            && (scheduleTimeNextEvent == 0 || terms.maturityDate < scheduleTimeNextEvent)\n            && (lastScheduleTime != terms.maturityDate || lastEventType != EventType.MD)\n        ) {\n            eventTypeNextEvent = EventType.MD;\n            scheduleTimeNextEvent = terms.maturityDate;\n        }\n\n        return encodeEvent(eventTypeNextEvent, scheduleTimeNextEvent);\n    }\n\n    /**\n     * @notice Computes a schedule segment of cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param lastScheduleTime last occurrence of cyclic event\n     * @param eventType eventType of the cyclic schedule\n     * @return event schedule segment\n     */\n    function computeNextCyclicEvent(\n        ANNTerms calldata terms,\n        uint256 lastScheduleTime,\n        EventType eventType\n    )\n        external\n        pure\n        override\n        returns(bytes32)\n    {\n        // IP\n        // interest payment related (starting with PRANX interest is paid following the PR schedule)\n        if (eventType == EventType.IP) {\n            if (terms.cycleAnchorDateOfInterestPayment != 0) {\n                uint256 nextInterestPaymentDate = computeNextCycleDateFromPrecedingDate(\n                    terms.cycleOfInterestPayment,\n                    terms.endOfMonthConvention,\n                    terms.cycleAnchorDateOfInterestPayment,\n                    lastScheduleTime,\n                    true,\n                    terms.maturityDate\n                );\n                if (nextInterestPaymentDate == 0) return bytes32(0);\n                if (nextInterestPaymentDate <= terms.capitalizationEndDate) return bytes32(0);\n                return encodeEvent(EventType.IP, nextInterestPaymentDate);\n            }\n        }\n\n        // IPCI\n        if (eventType == EventType.IPCI) {\n            if (terms.cycleAnchorDateOfInterestPayment != 0 && terms.capitalizationEndDate != 0) {\n                IPS memory cycleOfInterestCapitalization = terms.cycleOfInterestPayment;\n                cycleOfInterestCapitalization.s = S.SHORT;\n                uint256 nextInterestCapitalizationDate = computeNextCycleDateFromPrecedingDate(\n                    cycleOfInterestCapitalization,\n                    terms.endOfMonthConvention,\n                    terms.cycleAnchorDateOfInterestPayment,\n                    lastScheduleTime,\n                    true,\n                    terms.maturityDate\n                );\n                if (nextInterestCapitalizationDate == 0) return bytes32(0);\n                return encodeEvent(EventType.IPCI, nextInterestCapitalizationDate);\n            }\n        }\n\n        // rate reset\n        if (eventType == EventType.RR) {\n            if (terms.cycleAnchorDateOfRateReset != 0) {\n                uint256 nextRateResetDate = computeNextCycleDateFromPrecedingDate(\n                    terms.cycleOfRateReset,\n                    terms.endOfMonthConvention,\n                    terms.cycleAnchorDateOfRateReset,\n                    lastScheduleTime,\n                    true,\n                    terms.maturityDate\n                );\n                if (nextRateResetDate == 0) return bytes32(0);\n                return encodeEvent(EventType.RR, nextRateResetDate);\n            }\n            // ... nextRateReset\n        }\n\n        // fees\n        if (eventType == EventType.FP) {\n            if (terms.cycleAnchorDateOfFee != 0) {\n                uint256 nextFeeDate = computeNextCycleDateFromPrecedingDate(\n                    terms.cycleOfFee,\n                    terms.endOfMonthConvention,\n                    terms.cycleAnchorDateOfFee,\n                    lastScheduleTime,\n                    true,\n                    terms.maturityDate\n                );\n                if (nextFeeDate == 0) return bytes32(0);\n                return encodeEvent(EventType.FP, nextFeeDate);\n            }\n        }\n\n        // scaling\n        if (eventType == EventType.SC) {\n            if ((terms.scalingEffect != ScalingEffect._000) && terms.cycleAnchorDateOfScalingIndex != 0) {\n                uint256 nextScalingDate = computeNextCycleDateFromPrecedingDate(\n                    terms.cycleOfScalingIndex,\n                    terms.endOfMonthConvention,\n                    terms.cycleAnchorDateOfScalingIndex,\n                    lastScheduleTime,\n                    true,\n                    terms.maturityDate\n                );\n                if (nextScalingDate == 0) return bytes32(0);\n                return encodeEvent(EventType.SC, nextScalingDate);\n            }\n        }\n\n        // principal redemption\n        if (eventType == EventType.PR) {\n            if (terms.cycleAnchorDateOfPrincipalRedemption != 0) {\n                uint256 nextPrincipalRedemptionDate = computeNextCycleDateFromPrecedingDate(\n                    terms.cycleOfPrincipalRedemption,\n                    terms.endOfMonthConvention,\n                    terms.cycleAnchorDateOfPrincipalRedemption,\n                    lastScheduleTime,\n                    false,\n                    terms.maturityDate\n                );\n                if (nextPrincipalRedemptionDate == 0) return bytes32(0);\n                return encodeEvent(EventType.PR, nextPrincipalRedemptionDate);\n            }\n        }\n\n        return bytes32(0);\n    }\n\n    /**\n     * @notice Verifies that the provided event is still scheduled under the terms, the current state of the\n     * contract and the current state of the underlying.\n     * param _event event for which to check if its still scheduled\n     * param terms terms of the contract\n     * @param state current state of the contract\n     * param hasUnderlying boolean indicating whether the contract has an underlying contract\n     * param underlyingState state of the underlying (empty state object if non-existing)\n     * @return boolean indicating whether event is still scheduled\n     */\n    function isEventScheduled(\n        bytes32 /* _event */,\n        ANNTerms calldata /* terms */,\n        State calldata state,\n        bool /* hasUnderlying */,\n        State calldata /* underlyingState */\n    )\n        external\n        pure\n        override\n        returns (bool)\n    {\n        if (\n            state.contractPerformance == ContractPerformance.DF\n            || state.contractPerformance == ContractPerformance.MD\n            || state.contractPerformance == ContractPerformance.TD\n        ) { return false; }\n\n        return true;\n    }\n\n    /**\n     * @notice Implements abstract method which is defined in BaseEngine.\n     * Applies an event to the current state of the contract and returns the resulting state.\n     * The inheriting Engine contract has to map the events type to the designated STF.\n     * todo Annuity calculator for RR/RRF events, IPCB events and ICB state variable\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which to evaluate the next state for\n     * @param externalData external data needed for STF evaluation (e.g. rate for RR events)\n     * @return the resulting contract state\n     */\n    function stateTransitionFunction(\n        ANNTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n\n        /*\n         * Note:\n         * not supported: IPCB events, PRD (Purchase) events\n         */\n\n        if (eventType == EventType.AD) return STF_ANN_AD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.ISS) return STF_ANN_ISS(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.IED) return STF_ANN_IED(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.IPCI) return STF_ANN_IPCI(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.IP) return STF_ANN_IP(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.FP) return STF_ANN_FP(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.PP) return STF_ANN_PP(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.PR) return STF_ANN_PR(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.MD) return STF_ANN_MD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.RRF) return STF_ANN_RRF(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.RR) return STF_ANN_RR(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.SC) return STF_ANN_SC(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.TD) return STF_ANN_TD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.CE) return STF_ANN_CE(terms, state, scheduleTime, externalData);\n\n        revert(\"ANNEngine.stateTransitionFunction: ATTRIBUTE_NOT_FOUND\");\n    }\n\n    /**\n     * @notice Implements abstract method which is defined in BaseEngine.\n     * Computes the payoff for an event under the current state of the contract.\n     * The inheriting Engine contract has to map the events type to the designated POF.\n     * todo IPCB events and Icb state variable, Icb state variable updates in IP-paying events\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which the payoff should be evaluated\n     * @param externalData external data needed for POF evaluation (e.g. fxRate)\n     * @return the payoff of the event\n     */\n    function payoffFunction(\n        ANNTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (int256)\n    {\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n\n        /*\n         * Note: all ANN payoff functions that rely on NAM/LAM have been replaced by PAM\n         * actus-solidity currently doesn't support interestCalculationBase, thus we can use PAM\n         *\n         * There is a reference to a POF_ANN_PR function which was added because PAM doesn't have PR Events in ACTUS 1.0\n         * and NAM, which ANN refers to in the specification, is not yet supported\n         *\n         * not supported: IPCB events, PRD (Purchase) events\n         */\n\n        if (eventType == EventType.AD) return 0;\n        if (eventType == EventType.ISS) return 0;\n        if (eventType == EventType.IPCI) return 0;\n        if (eventType == EventType.RRF) return 0;\n        if (eventType == EventType.RR) return 0;\n        if (eventType == EventType.SC) return 0;\n        if (eventType == EventType.CE) return 0;\n        if (eventType == EventType.FP) return POF_ANN_FP(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.IED) return POF_ANN_IED(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.IP) return POF_ANN_IP(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.PP) return POF_ANN_PP(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.PR) return POF_ANN_PR(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.MD) return POF_ANN_MD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.TD) return POF_ANN_TD(terms, state, scheduleTime, externalData);\n\n        revert(\"ANNEngine.payoffFunction: ATTRIBUTE_NOT_FOUND\");\n    }\n}\n"
    },
    "contracts/ACTUS/Engines/ANN/ANNSTF.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\n\nimport \"../../Core/Core.sol\";\nimport \"../../Core/SignedMath.sol\";\n\n\n/**\n * @title STF\n * @notice Contains all state transition functions (STFs) currently used by all Engines\n */\ncontract ANNSTF is Core {\n\n    using SignedSafeMath for int;\n    using SignedMath for int;\n\n\n    /**\n     * State transition for PAM analysis events\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_ANN_NE (\n        ANNTerms memory /* terms */,\n        State memory state,\n        uint256 /* scheduleTime */,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        return state;\n    }\n\n    /**\n     * State transition for PAM analysis events\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_ANN_AD (\n        ANNTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent;\n        {\n            timeFromLastEvent = yearFraction(\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                terms.dayCountConvention,\n                terms.maturityDate\n            );\n        }\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for ANN issue events\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_ANN_ISS (\n        ANNTerms memory /* terms */,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        state.statusDate = scheduleTime;\n        return state;\n    }\n\n    /**\n     * State transition for PAM fee payment events\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_ANN_FP (\n        ANNTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent;\n        {\n            timeFromLastEvent = yearFraction(\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                terms.dayCountConvention,\n                terms.maturityDate\n            );\n        }\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.feeAccrued = 0;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM principal prepayment\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_ANN_PP (\n        ANNTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent;\n        {\n            timeFromLastEvent = yearFraction(\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                terms.dayCountConvention,\n                terms.maturityDate\n            );\n        }\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        // state.notionalPrincipal -= 0; // riskFactor not supported\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM fixed rate resets\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_ANN_RRF (\n        ANNTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent;\n        {\n            timeFromLastEvent = yearFraction(\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                terms.dayCountConvention,\n                terms.maturityDate\n            );\n        }\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.nominalInterestRate = terms.nextResetRate;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM termination events\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_ANN_TD (\n        ANNTerms memory /* terms */,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        state.notionalPrincipal = 0;\n        state.accruedInterest = 0;\n        state.feeAccrued = 0;\n        state.contractPerformance = ContractPerformance.TD;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM credit events\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_ANN_CE (\n        ANNTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns(State memory)\n    {\n        // handle maturity date\n        uint256 nonPerformingDate = (state.nonPerformingDate == 0)\n            ? shiftEventTime(\n                scheduleTime,\n                terms.businessDayConvention,\n                terms.calendar,\n                terms.maturityDate\n            ) : state.nonPerformingDate;\n\n        uint256 currentTimestamp = uint256(externalData);\n\n        bool isInGracePeriod = false;\n        if (terms.gracePeriod.isSet) {\n            uint256 graceDate = getTimestampPlusPeriod(terms.gracePeriod, nonPerformingDate);\n            if (currentTimestamp <= graceDate) {\n                state.contractPerformance = ContractPerformance.DL;\n                isInGracePeriod = true;\n            }\n        }\n\n        if (terms.delinquencyPeriod.isSet && !isInGracePeriod) {\n            uint256 delinquencyDate = getTimestampPlusPeriod(terms.delinquencyPeriod, nonPerformingDate);\n            if (currentTimestamp <= delinquencyDate) {\n                state.contractPerformance = ContractPerformance.DQ;\n            } else {\n                state.contractPerformance = ContractPerformance.DF;\n            }\n        }\n\n        if (state.nonPerformingDate == 0) {\n            // handle maturity date\n            state.nonPerformingDate = shiftEventTime(\n                scheduleTime,\n                terms.businessDayConvention,\n                terms.calendar,\n                terms.maturityDate\n            );\n        }\n\n        return state;\n    }\n\n    function STF_ANN_IED (\n        ANNTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        state.notionalPrincipal = roleSign(terms.contractRole) * terms.notionalPrincipal;\n        state.nominalInterestRate = terms.nominalInterestRate;\n        state.statusDate = scheduleTime;\n        state.accruedInterest = terms.accruedInterest;\n\n        return state;\n    }\n\n    function STF_ANN_IPCI (\n        ANNTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent;\n        {\n            timeFromLastEvent = yearFraction(\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                terms.dayCountConvention,\n                terms.maturityDate\n            );\n        }\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.accruedInterest\n            .add(\n                state.nominalInterestRate\n                .floatMult(state.notionalPrincipal)\n                .floatMult(timeFromLastEvent)\n            )\n        );\n        state.accruedInterest = 0;\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    function STF_ANN_IP (\n        ANNTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent;\n        {\n            timeFromLastEvent = yearFraction(\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                terms.dayCountConvention,\n                terms.maturityDate\n            );\n        }\n        state.accruedInterest = 0;\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    function STF_ANN_PR (\n        ANNTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent;\n        {\n            timeFromLastEvent = yearFraction(\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                terms.dayCountConvention,\n                terms.maturityDate\n            );\n        }\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.notionalPrincipal = state.notionalPrincipal\n        .sub(\n            roleSign(terms.contractRole)\n            * (\n                roleSign(terms.contractRole)\n                * state.notionalPrincipal\n            )\n            .min(\n                roleSign(terms.contractRole)\n                * (\n                    state.nextPrincipalRedemptionPayment\n                    .sub(state.accruedInterest)\n                )\n            )\n        );\n\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    function STF_ANN_MD (\n        ANNTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent;\n        {\n            timeFromLastEvent = yearFraction(\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                terms.dayCountConvention,\n                terms.maturityDate\n            );\n        }\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.notionalPrincipal = 0.0;\n        state.contractPerformance = ContractPerformance.MD;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    function STF_ANN_RR (\n        ANNTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        // riskFactor not supported\n        int256 rate = int256(uint256(externalData)).floatMult(terms.rateMultiplier).add(terms.rateSpread);\n        int256 deltaRate = rate.sub(state.nominalInterestRate);\n\n        // apply period cap/floor\n        if ((terms.lifeCap < deltaRate) && (terms.lifeCap < ((-1) * terms.periodFloor))) {\n            deltaRate = terms.lifeCap;\n        } else if (deltaRate < ((-1) * terms.periodFloor)) {\n            deltaRate = ((-1) * terms.periodFloor);\n        }\n        rate = state.nominalInterestRate.add(deltaRate);\n\n        // apply life cap/floor\n        if (terms.lifeCap < rate && terms.lifeCap < terms.lifeFloor) {\n            rate = terms.lifeCap;\n        } else if (rate < terms.lifeFloor) {\n            rate = terms.lifeFloor;\n        }\n\n        int256 timeFromLastEvent;\n        {\n            timeFromLastEvent = yearFraction(\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                terms.dayCountConvention,\n                terms.maturityDate\n            );\n        }\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.nominalInterestRate = rate;\n        state.nextPrincipalRedemptionPayment = 0; // annuity calculator not supported\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    function STF_ANN_SC (\n        ANNTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent;\n        {\n            timeFromLastEvent = yearFraction(\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                terms.dayCountConvention,\n                terms.maturityDate\n            );\n        }\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n\n        if ((terms.scalingEffect == ScalingEffect.I00) || (terms.scalingEffect == ScalingEffect.IN0)) {\n            state.interestScalingMultiplier = 0; // riskFactor not supported\n        }\n        if ((terms.scalingEffect == ScalingEffect._0N0) || (terms.scalingEffect == ScalingEffect.IN0)) {\n            state.notionalScalingMultiplier = 0; // riskFactor not supported\n        }\n\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n}\n"
    },
    "contracts/ACTUS/Engines/ANN/ANNPOF.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\n\nimport \"../../Core/Core.sol\";\nimport \"../../Core/SignedMath.sol\";\n\n\n/**\n * @title POF\n * @notice Contains all payoff functions (POFs) currently used by all Engines\n */\ncontract ANNPOF is Core {\n\n    using SignedSafeMath for int;\n    using SignedMath for int;\n\n\n    /**\n     * Calculate the pay-off for PAM Fees. The method how to calculate the fee\n     * heavily depends on the selected Fee Basis.\n     * @return the fee amount for PAM contracts\n     */\n    function POF_ANN_FP (\n        ANNTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        if (terms.feeBasis == FeeBasis.A) {\n            return (\n                roleSign(terms.contractRole)\n                * terms.feeRate\n            );\n        }\n\n        int256 timeFromLastEvent;\n        {\n            timeFromLastEvent = yearFraction(\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                terms.dayCountConvention,\n                terms.maturityDate\n            );\n        }\n\n        return (\n            state.feeAccrued\n            .add(\n                timeFromLastEvent\n                .floatMult(terms.feeRate)\n                .floatMult(state.notionalPrincipal)\n            )\n        );\n    }\n\n    /**\n     * Calculate the payoff for the initial exchange\n     * @return the payoff at iniitial exchange for PAM contracts\n     */\n    function POF_ANN_IED (\n        ANNTerms memory terms,\n        State memory /* state */,\n        uint256 /* scheduleTime */,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        return (\n            roleSign(terms.contractRole)\n            * (-1)\n            * terms.notionalPrincipal\n                .add(terms.premiumDiscountAtIED)\n        );\n    }\n\n    /**\n     * Calculate the interest payment payoff\n     * @return the interest amount to pay for PAM contracts\n     */\n    function POF_ANN_IP (\n        ANNTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        int256 timeFromLastEvent;\n        {\n            timeFromLastEvent = yearFraction(\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                terms.dayCountConvention,\n                terms.maturityDate\n            );\n        }\n\n        return (\n            state.interestScalingMultiplier\n            .floatMult(\n                state.accruedInterest\n                .add(\n                    timeFromLastEvent\n                    .floatMult(state.nominalInterestRate)\n                    .floatMult(state.notionalPrincipal)\n                )\n            )\n        );\n    }\n\n    /**\n     * Calculate the principal prepayment payoff\n     * @return the principal prepayment amount for PAM contracts\n     */\n    function POF_ANN_PP (\n        ANNTerms memory terms,\n        State memory state,\n        uint256 /* scheduleTime */,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        return (\n            roleSign(terms.contractRole)\n            * state.notionalPrincipal\n        );\n    }\n\n    /**\n     * Calculate the payoff in case of maturity\n     * @return the maturity payoff for PAM contracts\n     */\n    function POF_ANN_MD (\n        ANNTerms memory /* terms */,\n        State memory state,\n        uint256 /* scheduleTime */,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        return (\n            state.notionalScalingMultiplier\n                .floatMult(state.notionalPrincipal)\n        );\n    }\n\n    /**\n     * Calculate the payoff in case of termination of a contract\n     * @return the termination payoff amount for PAM contracts\n     */\n    function POF_ANN_TD (\n        ANNTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        int256 timeFromLastEvent;\n        {\n            timeFromLastEvent = yearFraction(\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                terms.dayCountConvention,\n                terms.maturityDate\n            );\n        }\n\n        return (\n            roleSign(terms.contractRole)\n            * terms.priceAtTerminationDate\n            .add(state.accruedInterest)\n            .add(\n                timeFromLastEvent\n                .floatMult(state.nominalInterestRate)\n                .floatMult(state.notionalPrincipal)\n            )\n        );\n    }\n\n    /**\n     * Calculate the payoff for principal redemption\n     * @dev This is a replacement of the POF_PR_NAM which we have not implemented, yet\n     * @return the principal redemption amount for ANN contracts\n     */\n    function POF_ANN_PR (\n        ANNTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        int256 timeFromLastEvent;\n        {\n            timeFromLastEvent = yearFraction(\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                terms.dayCountConvention,\n                terms.maturityDate\n            );\n        }\n\n        return (\n            (state.notionalScalingMultiplier * roleSign(terms.contractRole))\n            .floatMult(\n                (roleSign(terms.contractRole) * state.notionalPrincipal)\n                .min(\n                    roleSign(terms.contractRole)\n                    * (\n                        state.nextPrincipalRedemptionPayment\n                        .sub(state.accruedInterest)\n                        .sub(timeFromLastEvent\n                            .floatMult(state.nominalInterestRate)\n                            .floatMult(state.notionalPrincipal))\n                    )\n                )\n            )\n        );\n    }\n}\n"
    },
    "contracts/ACTUS/test/ANN/TestANNPOF.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../Engines/ANN/ANNPOF.sol\";\n\n/**\n* These helper contracts expose internal functions for unit testing.\n*/\ncontract TestANNPOF is ANNPOF {\n\n    function _POF_ANN_FP (\n        ANNTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns(int256)\n    {\n        return POF_ANN_FP(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _POF_ANN_IED (\n        ANNTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns(int256)\n    {\n         return POF_ANN_IED(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _POF_ANN_IP (\n        ANNTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns(int256)\n    {\n         return POF_ANN_IP(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _POF_ANN_PP (\n        ANNTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns(int256)\n    {\n         return POF_ANN_PP(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _POF_ANN_MD (\n        ANNTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns(int256)\n    {\n         return POF_ANN_MD(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _POF_ANN_TD (\n        ANNTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns(int256)\n    {\n         return POF_ANN_TD(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _POF_ANN_PR(\n        ANNTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (int256)\n    {\n        return POF_ANN_PR(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n}"
    },
    "contracts/ACTUS/test/ANN/TestANNSTF.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../Engines/ANN/ANNSTF.sol\";\n\n/**\n* These helper contracts expose internal functions for unit testing.\n*/\ncontract TestANNSTF is ANNSTF {\n\n    function _STF_ANN_NE(\n        ANNTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_ANN_NE(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_ANN_AD(\n        ANNTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_ANN_AD(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_ANN_FP(\n        ANNTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_ANN_FP(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_ANN_PP(\n        ANNTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_ANN_PP(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_ANN_RRF(\n        ANNTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_ANN_RRF(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_ANN_TD(\n        ANNTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_ANN_TD(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_ANN_CE(\n        ANNTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_ANN_CE(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_ANN_IED(\n        ANNTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_ANN_IED(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_ANN_IPCI(\n        ANNTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_ANN_IPCI(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_ANN_IP(\n        ANNTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_ANN_IP(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_ANN_PR(\n        ANNTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_ANN_PR(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_ANN_MD(\n        ANNTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_ANN_MD(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_ANN_RR(\n        ANNTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_ANN_RR(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_ANN_SC(\n        ANNTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_ANN_SC(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n}"
    },
    "contracts/ACTUS/Engines/CEG/CEGPOF.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\n\nimport \"../../Core/Core.sol\";\nimport \"../../Core/SignedMath.sol\";\n\n\n/**\n * @title POF\n * @notice Contains all payoff functions (POFs) currently used by all Engines\n */\ncontract CEGPOF is Core {\n\n    using SignedSafeMath for int;\n    using SignedMath for int;\n\n\n    /**\n     * Calculate the payoff in case of settlement\n     * @return the settlement payoff amount for CEG contracts\n     */\n    function POF_CEG_ST (\n        CEGTerms memory /* terms */,\n        State memory state,\n        uint256 /* scheduleTime */,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        return state.exerciseAmount.add(state.feeAccrued);\n    }\n\n    /**\n     * Calculate the pay-off for CEG Fees.\n     * @return the fee amount for CEG contracts\n     */\n    function POF_CEG_FP (\n        CEGTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        if (terms.feeBasis == FeeBasis.A) {\n            return (\n                roleSign(terms.contractRole)\n                * terms.feeRate\n            );\n        }\n\n        int256 timeFromLastEvent;\n        {\n            timeFromLastEvent = yearFraction(\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                terms.dayCountConvention,\n                terms.maturityDate\n            );\n        }\n\n        return (\n            state.feeAccrued\n            .add(\n                timeFromLastEvent\n                .floatMult(terms.feeRate)\n                .floatMult(state.notionalPrincipal)\n            )\n        );\n    }\n}\n"
    },
    "contracts/ACTUS/test/CEG/TestCEGPOF.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../Engines/CEG/CEGPOF.sol\";\n\n/**\n* These helper contracts expose internal functions for unit testing.\n*/\ncontract TestCEGPOF is CEGPOF {\n\n    function _POF_CEG_ST(\n        CEGTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (int256)\n    {\n        return POF_CEG_ST(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _POF_CEG_FP(\n        CEGTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (int256)\n    {\n        return POF_CEG_FP(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n}\n"
    },
    "contracts/ACTUS/Engines/CEG/CEGEngine.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\n\nimport \"../../Core/Core.sol\";\nimport \"../../Core/SignedMath.sol\";\nimport \"./ICEGEngine.sol\";\nimport \"./CEGSTF.sol\";\nimport \"./CEGPOF.sol\";\n\n\n/**\n * @title CEGEngine\n * @notice Inherits from BaseEngine by implementing STFs, POFs according to the ACTUS standard for a CEC contract\n * @dev All numbers except unix timestamp are represented as multiple of 10 ** 18\n * inputs have to be multiplied by 10 ** 18, outputs have to multplied by 10 ** -18\n */\ncontract CEGEngine is Core, CEGSTF, CEGPOF, ICEGEngine {\n\n    using SignedSafeMath for int;\n    using SignedMath for int;\n\n\n    function contractType() external pure override returns (ContractType) {\n        return ContractType.CEG;\n    }\n\n    /**\n     * Applys an event to the current state of a contract and returns the resulting contract state.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event to be applied to the contract state\n     * @param externalData external data needed for STF evaluation (e.g. rate for RR events)\n     * @return the resulting contract state\n     */\n    function computeStateForEvent(\n        CEGTerms calldata terms,\n        State calldata state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        external\n        pure\n        override\n        returns (State memory)\n    {\n        return stateTransitionFunction(\n            terms,\n            state,\n            _event,\n            externalData\n        );\n    }\n\n    /**\n     * Evaluates the payoff for an event under the current state of the contract.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which the payoff should be evaluated\n     * @param externalData external data needed for POF evaluation (e.g. fxRate)\n     * @return the payoff of the event\n     */\n    function computePayoffForEvent(\n        CEGTerms calldata terms,\n        State calldata state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        external\n        pure\n        override\n        returns (int256)\n    {\n        // if alternative settlementCurrency is set then apply fxRate to payoff\n        if (terms.settlementCurrency != address(0) && terms.currency != terms.settlementCurrency) {\n            return payoffFunction(\n                terms,\n                state,\n                _event,\n                externalData\n            ).floatMult(int256(externalData));\n        }\n\n        return payoffFunction(\n            terms,\n            state,\n            _event,\n            externalData\n        );\n    }\n\n    /**\n     * @notice Initialize contract state space based on the contract terms.\n     * @param terms terms of the contract\n     * @return initial state of the contract\n     */\n    function computeInitialState(CEGTerms calldata terms)\n        external\n        pure\n        override\n        returns (State memory)\n    {\n        State memory state;\n\n        state.contractPerformance = ContractPerformance.PF;\n        state.statusDate = terms.statusDate;\n        state.maturityDate = terms.maturityDate;\n        state.notionalPrincipal = roleSign(terms.contractRole) * terms.notionalPrincipal;\n        state.feeAccrued = terms.feeAccrued;\n\n        return state;\n    }\n\n    /**\n     * @notice Computes a schedule segment of non-cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @return segment of the non-cyclic schedule\n     */\n    function computeNonCyclicScheduleSegment(\n        CEGTerms calldata terms,\n        uint256 segmentStart,\n        uint256 segmentEnd\n    )\n        external\n        pure\n        override\n        returns (bytes32[] memory)\n    {\n        bytes32[MAX_EVENT_SCHEDULE_SIZE] memory events;\n        uint16 index;\n\n        // purchase\n        if (terms.purchaseDate != 0) {\n            if (isInSegment(terms.purchaseDate, segmentStart, segmentEnd)) {\n                events[index] = encodeEvent(EventType.PRD, terms.purchaseDate);\n                index++;\n            }\n        }\n\n        // maturity event\n        if (isInSegment(terms.maturityDate, segmentStart, segmentEnd) == true) {\n            events[index] = encodeEvent(EventType.MD, terms.maturityDate);\n            index++;\n        }\n\n        // remove null entries from returned array\n        bytes32[] memory schedule = new bytes32[](index);\n        for (uint256 i = 0; i < index; i++) {\n            schedule[i] = events[i];\n        }\n\n        return schedule;\n    }\n\n    /**\n     * @notice Computes a schedule segment of cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @param eventType eventType of the cyclic schedule\n     * @return event schedule segment\n     */\n    function computeCyclicScheduleSegment(\n        CEGTerms calldata terms,\n        uint256 segmentStart,\n        uint256 segmentEnd,\n        EventType eventType\n    )\n        external\n        pure\n        override\n        returns (bytes32[] memory)\n    {\n        bytes32[MAX_EVENT_SCHEDULE_SIZE] memory events;\n        uint256 index = 0;\n\n        if (eventType == EventType.FP) {\n            // fees\n            if (terms.cycleAnchorDateOfFee != 0) {\n                uint256[MAX_CYCLE_SIZE] memory feeSchedule = computeDatesFromCycleSegment(\n                    terms.cycleAnchorDateOfFee,\n                    terms.maturityDate,\n                    terms.cycleOfFee,\n                    terms.endOfMonthConvention,\n                    true,\n                    segmentStart,\n                    segmentEnd\n                );\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\n                    if (feeSchedule[i] == 0) break;\n                    if (isInSegment(feeSchedule[i], segmentStart, segmentEnd) == false) continue;\n                    events[index] = encodeEvent(EventType.FP, feeSchedule[i]);\n                    index++;\n                }\n            }\n        }\n\n        // remove null entries from returned array\n        bytes32[] memory schedule = new bytes32[](index);\n        for (uint256 i = 0; i < index; i++) {\n            schedule[i] = events[i];\n        }\n\n        return schedule;\n    }\n\n    /**\n     * @notice Computes the next non-cyclic contract events based on the contract terms\n     * and the timestamp on which the prev. event occured.\n     * @dev Assumes that non-cyclic events of the same event type have a unique schedule time\n     * @param terms terms of the contract\n     * @param lastNonCyclicEvent last non-cyclic event\n     * @return next non-cyclic event\n     */\n    function computeNextNonCyclicEvent(\n        CEGTerms calldata terms,\n        bytes32 lastNonCyclicEvent\n    )\n        external\n        pure\n        override\n        returns (bytes32)\n    {\n        (EventType lastEventType, uint256 lastScheduleTime) = decodeEvent(lastNonCyclicEvent);\n\n        EventType eventTypeNextEvent;\n        uint256 scheduleTimeNextEvent;\n\n        // EventTypes ordered after epoch offset - so we don't have make an additional epochOffset check\n\n        // purchase\n        if (\n            // date for event has to be set in terms and date of event can be in the past\n            (terms.purchaseDate != 0 && (lastScheduleTime <= terms.purchaseDate))\n            // date for event has to come before previous candidate for the next event\n            && (scheduleTimeNextEvent == 0 || terms.purchaseDate < scheduleTimeNextEvent)\n            // avoid endless loop by requiring that the event is not the lastNonCyclicEvent\n            && (lastScheduleTime != terms.purchaseDate || lastEventType != EventType.PRD)\n        ) {\n            eventTypeNextEvent = EventType.PRD;\n            scheduleTimeNextEvent = terms.purchaseDate;\n        }\n\n        // maturity event\n        if (\n            (terms.maturityDate != 0 && (lastScheduleTime <= terms.maturityDate))\n            && (scheduleTimeNextEvent == 0 || terms.maturityDate < scheduleTimeNextEvent)\n            && (lastScheduleTime != terms.maturityDate || lastEventType != EventType.MD)\n        ) {\n            eventTypeNextEvent = EventType.MD;\n            scheduleTimeNextEvent = terms.maturityDate;\n        }\n\n        return encodeEvent(eventTypeNextEvent, scheduleTimeNextEvent);\n    }\n\n    /**\n     * @notice Computes a schedule segment of cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param lastScheduleTime last occurrence of cyclic event\n     * @param eventType eventType of the cyclic schedule\n     * @return event schedule segment\n     */\n    function computeNextCyclicEvent(\n        CEGTerms calldata terms,\n        uint256 lastScheduleTime,\n        EventType eventType\n    )\n        external\n        pure\n        override\n        returns(bytes32)\n    {\n        // fees\n        if (eventType == EventType.FP) {\n            if (terms.cycleAnchorDateOfFee != 0) {\n                uint256 nextFeeDate = computeNextCycleDateFromPrecedingDate(\n                    terms.cycleOfFee,\n                    terms.endOfMonthConvention,\n                    terms.cycleAnchorDateOfFee,\n                    lastScheduleTime,\n                    true,\n                    terms.maturityDate\n                );\n                if (nextFeeDate == 0) return bytes32(0);\n                return encodeEvent(EventType.FP, nextFeeDate);\n            }\n        }\n\n        return bytes32(0);\n    }\n\n    /**\n     * @notice Verifies that the provided event is still scheduled under the terms, the current state of the\n     * contract and the current state of the underlying.\n     * @param _event event for which to check if its still scheduled\n     * param terms terms of the contract\n     * @param state current state of the contract\n     * @param hasUnderlying boolean indicating whether the contract has an underlying contract\n     * @param underlyingState state of the underlying (empty state object if non-existing)\n     * @return boolean indicating whether event is still scheduled\n     */\n    function isEventScheduled(\n        bytes32 _event,\n        CEGTerms calldata /* terms */,\n        State calldata state,\n        bool hasUnderlying,\n        State calldata underlyingState\n    )\n        external\n        pure\n        override\n        returns (bool)\n    {\n        if (\n            state.contractPerformance == ContractPerformance.DF\n            || state.contractPerformance == ContractPerformance.MD\n            || state.contractPerformance == ContractPerformance.TD\n        ) { return false; }\n\n        if (hasUnderlying) {\n            (EventType eventType,) = decodeEvent(_event);\n            // FP, MD events only scheduled up to execution of the Guarantee\n            if (\n                (eventType == EventType.FP || eventType == EventType.MD)\n                && underlyingState.exerciseAmount > int256(0)\n            ) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Implements abstract method which is defined in BaseEngine.\n     * Applies an event to the current state of the contract and returns the resulting state.\n     * The inheriting Engine contract has to map the events type to the designated STF.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which to evaluate the next state for\n     * @param externalData external data needed for STF evaluation (e.g. rate for RR events)\n     * @return the resulting contract state\n     */\n    function stateTransitionFunction(\n        CEGTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n\n        /*\n         * Note:\n         * Not supported: PRD (Purchase) events\n         */\n\n        if (eventType == EventType.FP) return STF_CEG_FP(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.EXE) return STF_CEG_EXE(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.ST) return STF_CEG_ST(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.MD) return STF_CEG_MD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.CE) return STF_CEG_CE(terms, state, scheduleTime, externalData);\n\n        revert(\"CEGEngine.stateTransitionFunction: ATTRIBUTE_NOT_FOUND\");\n    }\n\n    /**\n     * @notice Implements abstract method which is defined in BaseEngine.\n     * Computes the payoff for an event under the current state of the contract.\n     * The inheriting Engine contract has to map the events type to the designated POF.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which the payoff should be evaluated\n     * @param externalData external data needed for POF evaluation (e.g. fxRate)\n     * @return the payoff of the event\n     */\n    function payoffFunction(\n        CEGTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (int256)\n    {\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n\n        /*\n         * Note:\n         * Not supported: PRD (Purchase) events\n         */\n\n        if (eventType == EventType.CE) return 0;\n        if (eventType == EventType.FP) return POF_CEG_FP(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.EXE) return 0;\n        if (eventType == EventType.ST) return POF_CEG_ST(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.MD) return 0;\n\n        revert(\"CEGEngine.payoffFunction: ATTRIBUTE_NOT_FOUND\");\n    }\n}\n"
    },
    "contracts/ACTUS/Engines/CEG/CEGSTF.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\n\nimport \"../../Core/Core.sol\";\nimport \"../../Core/SignedMath.sol\";\n\n\n/**\n * @title STF\n * @notice Contains all state transition functions (STFs) currently used by all Engines\n */\ncontract CEGSTF is Core {\n\n    using SignedSafeMath for int;\n    using SignedMath for int;\n\n\n    /**\n     * State transition for PAM credit events\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_CEG_CE (\n        CEGTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns(State memory)\n    {\n        // handle maturity date\n        uint256 nonPerformingDate = (state.nonPerformingDate == 0)\n            ? shiftEventTime(\n                scheduleTime,\n                terms.businessDayConvention,\n                terms.calendar,\n                terms.maturityDate\n            ) : state.nonPerformingDate;\n\n        uint256 currentTimestamp = uint256(externalData);\n\n        bool isInGracePeriod = false;\n        if (terms.gracePeriod.isSet) {\n            uint256 graceDate = getTimestampPlusPeriod(terms.gracePeriod, nonPerformingDate);\n            if (currentTimestamp <= graceDate) {\n                state.contractPerformance = ContractPerformance.DL;\n                isInGracePeriod = true;\n            }\n        }\n\n        if (terms.delinquencyPeriod.isSet && !isInGracePeriod) {\n            uint256 delinquencyDate = getTimestampPlusPeriod(terms.delinquencyPeriod, nonPerformingDate);\n            if (currentTimestamp <= delinquencyDate) {\n                state.contractPerformance = ContractPerformance.DQ;\n            } else {\n                state.contractPerformance = ContractPerformance.DF;\n            }\n        }\n\n        if (state.nonPerformingDate == 0) {\n            // handle maturity date\n            state.nonPerformingDate = shiftEventTime(\n                scheduleTime,\n                terms.businessDayConvention,\n                terms.calendar,\n                terms.maturityDate\n            );\n        }\n\n        return state;\n    }\n\n    function STF_CEG_MD (\n        CEGTerms memory /* terms */,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        state.notionalPrincipal = 0;\n        state.contractPerformance = ContractPerformance.MD;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    function STF_CEG_EXE (\n        CEGTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent;\n        {\n            timeFromLastEvent = yearFraction(\n                shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar, terms.maturityDate),\n                terms.dayCountConvention,\n                terms.maturityDate\n            );\n        }\n        state.statusDate = scheduleTime;\n        // decode state.notionalPrincipal of underlying from externalData\n        state.exerciseAmount = terms.coverageOfCreditEnhancement.floatMult(int256(externalData));\n        state.exerciseDate = scheduleTime;\n\n        if (terms.feeBasis == FeeBasis.A) {\n            state.feeAccrued = roleSign(terms.contractRole) * terms.feeRate;\n        } else {\n            state.feeAccrued = state.feeAccrued\n            .add(\n                timeFromLastEvent\n                .floatMult(terms.feeRate)\n                .floatMult(state.notionalPrincipal)\n            );\n        }\n\n        return state;\n    }\n\n    function STF_CEG_ST (\n        CEGTerms memory /* terms */,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        state.notionalPrincipal = 0;\n        state.feeAccrued = 0;\n        state.contractPerformance = ContractPerformance.MD;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    function STF_CEG_PRD (\n        CEGTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        state.notionalPrincipal = roleSign(terms.contractRole) * terms.notionalPrincipal;\n        state.nominalInterestRate = terms.feeRate;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    function STF_CEG_FP (\n        CEGTerms memory /* terms */,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 /* externalData */\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        state.feeAccrued = 0;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n}\n"
    },
    "contracts/ACTUS/test/CEG/TestCEGSTF.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../Engines/CEG/CEGSTF.sol\";\n\n/**\n* These helper contracts expose internal functions for unit testing.\n*/\ncontract TestCEGSTF is CEGSTF {\n\n    function _STF_CEG_CE(\n        CEGTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_CEG_CE(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_CEG_MD(\n        CEGTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_CEG_MD(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_CEG_EXE(\n        CEGTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_CEG_EXE(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_CEG_ST(\n        CEGTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_CEG_ST(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_CEG_PRD(\n        CEGTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_CEG_PRD(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_CEG_FP(\n        CEGTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        public\n        pure\n        returns (State memory)\n    {\n        return STF_CEG_FP(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n}\n"
    },
    "contracts/Extensions/DvPSettlement.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.7.4;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\n/**\n * @title DvPSettlement\n * @dev Contract to manage any number of Delivery-versus-Payment Settlements\n */\ncontract DvPSettlement {\n\n    enum SettlementStatus { NOT_EXISTS, INITIALIZED, EXECUTED, EXPIRED }\n\n    struct Settlement {\n        address creator;\n        address creatorToken;\n        uint256 creatorAmount;\n        address creatorBeneficiary;\n        address counterparty;\n        address counterpartyToken;\n        uint256 counterpartyAmount;\n        uint256 expirationDate;\n        SettlementStatus status;\n    }\n\n    // stores the settlementId of the last created Settlement\n    uint256 public lastSettlementId;\n    // SettlementId => Settlement\n    mapping (uint256 => Settlement) public settlements;\n\n    event SettlementInitialized(uint256 indexed settlementId, Settlement settlement);\n    event SettlementExecuted(uint256 indexed settlementId, address indexed executor);\n    event SettlementExpired(uint256 indexed settlementId);\n\n\n    /**\n     * @notice Creates a new Settlement in the contract's storage and transfers creator's tokens into the contract\n     * @dev The creator must approve for this contract at least `creatorAmount` of tokens\n     * @param creatorToken address of creator's ERC20 token\n     * @param creatorAmount amount of creator's ERC20 token to be exchanged\n     * @param counterparty address of counterparty OR 0x0 for open settlement\n     * @param counterpartyToken address of counterparty's ERC20 token\n     * @param counterpartyAmount amount of counterparty's ERC20 token to be exchanged\n     * @param expirationDate unix timestamp in seconds\n     */\n    function createSettlement(\n        address creatorToken,\n        uint256 creatorAmount,\n        address creatorBeneficiary,\n        address counterparty,\n        address counterpartyToken,\n        uint256 counterpartyAmount,\n        uint256 expirationDate\n    )\n        external\n    {\n        require(\n            expirationDate > block.timestamp,\n            \"DvPSettlement.createSettlement: INVALID_EXPIRATION_DATE\"\n        );\n        require(\n            lastSettlementId < type(uint256).max,\n            \"DvPSettlement.createSettlement: INVALID_SETTLEMENT_ID\"\n        );\n\n        lastSettlementId++;\n\n        Settlement storage settlement = settlements[lastSettlementId];\n        settlement.creator = msg.sender;\n        settlement.creatorToken = creatorToken;\n        settlement.creatorAmount = creatorAmount;\n        settlement.creatorBeneficiary = creatorBeneficiary;\n        settlement.counterparty = counterparty;\n        settlement.counterpartyToken = counterpartyToken;\n        settlement.counterpartyAmount = counterpartyAmount;\n        settlement.expirationDate = expirationDate;\n        settlement.status = SettlementStatus.INITIALIZED;\n\n        require(\n            IERC20(settlement.creatorToken).transferFrom(settlement.creator, address(this), settlement.creatorAmount),\n            \"DvPSettlement.createSettlement: TRANFER_FAILED\"\n        );\n\n        emit SettlementInitialized(lastSettlementId, settlement);\n    }\n\n\n    /**\n     * @notice Executes an existing Settlement with the sender as the counterparty\n     * @dev This function can only be successfully called by the designated counterparty unless\n     * the counterparty address is empty (0x0) in which case anyone can fulfill and execute the settlement\n     * @dev The counterparty must approve for this contract at least `counterpartyAmount` of tokens\n     * @param settlementId Id of the Settlement to execute\n     */\n    function executeSettlement(uint256 settlementId) external {\n        Settlement storage settlement = settlements[settlementId];\n\n        require(\n            settlement.status == SettlementStatus.INITIALIZED,\n            \"DvPSettlement.executeSettlement: SETTLEMENT_NOT_INITIALIZED\"\n        );\n        require(\n            settlement.expirationDate > block.timestamp,\n            \"DvPSettlement.executeSettlement: SETTLEMENT_EXPIRED\"\n        );\n        require(\n            // if empty (0x0) counterparty address, consider it an \"open\" settlement\n            settlement.counterparty == address(0) || settlement.counterparty == msg.sender,\n            \"DvPSettlement.executeSettlement: UNAUTHORIZED_SENDER\"\n        );\n\n        // if empty (0x0) creatorBeneficiary address, send funds to creator\n        address creatorReveiver = (settlement.creatorBeneficiary == address(0))\n            ? settlement.creator\n            : settlement.creatorBeneficiary;\n\n        settlement.status = SettlementStatus.EXECUTED;\n\n        // transfer both tokens\n        require(\n            IERC20(settlement.counterpartyToken).transferFrom(msg.sender, creatorReveiver, settlement.counterpartyAmount)\n            && IERC20(settlement.creatorToken).transfer(msg.sender, settlement.creatorAmount),\n            \"DvPSettlement.executeSettlement: TRANSFER_FAILED\"\n        );\n\n        emit SettlementExecuted(settlementId, msg.sender);\n    }\n\n    /**\n     * @notice When called after a given settlement expires, it refunds tokens to the creator\n     * @dev This function can be called by anyone since there is no other possible outcome for\n     * a created settlement that has passed the expiration date\n     * @param settlementId Id of the Settlement to expire\n     */\n    function expireSettlement(uint256 settlementId) external {\n        Settlement storage settlement = settlements[settlementId];\n\n        require(\n            settlement.status == SettlementStatus.INITIALIZED,\n            \"DvPSettlement.expireSettlement: SETTLEMENT_NOT_INITIALIZED\"\n        );\n        require(\n            settlement.expirationDate < block.timestamp,\n            \"DvPSettlement.expireSettlement: SETTLEMENT_NOT_YET_EXPIRED\"\n        );\n\n        settlement.status = SettlementStatus.EXPIRED;\n\n        // refund creator of settlement\n        require(\n            IERC20(settlement.creatorToken).transfer(settlement.creator, settlement.creatorAmount),\n            \"DvPSettlement.expireSettlement: TRANSFER_FAILED\"\n        );\n        \n        emit SettlementExpired(settlementId);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}